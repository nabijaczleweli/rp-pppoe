From d95598c16f6a3feb4846db669601856bad15bb74 Mon Sep 17 00:00:00 2001
From: "David F. Skoll" <dfs@roaringpenguin.com>
Date: Tue, 22 Jan 2002 16:03:05 +0000
Subject: [PATCH] Added RADIUS suppport.

---
 PLUGINS                                       |   47 +-
 configure                                     |    4 +-
 pppd/auth.c                                   |   26 +-
 pppd/chap.c                                   |  102 +-
 pppd/chap.h                                   |    5 +-
 pppd/ipcp.c                                   |    8 +-
 pppd/main.c                                   |    6 +-
 pppd/plugins/Makefile.linux                   |    2 +-
 pppd/plugins/radius/Makefile.linux            |   49 +
 pppd/plugins/radius/pppd-radattr.8            |   44 +
 pppd/plugins/radius/pppd-radius.8             |   58 +
 pppd/plugins/radius/radattr.c                 |  102 +
 pppd/plugins/radius/radius.c                  |  694 ++++
 pppd/plugins/radius/radiusclient/BUGS         |   19 +
 pppd/plugins/radius/radiusclient/CHANGES      |  120 +
 pppd/plugins/radius/radiusclient/COPYRIGHT    |   90 +
 pppd/plugins/radius/radiusclient/Makefile.am  |   22 +
 pppd/plugins/radius/radiusclient/Makefile.in  |  331 ++
 pppd/plugins/radius/radiusclient/README       |   17 +
 .../radius/radiusclient/README.radexample     |   12 +
 pppd/plugins/radius/radiusclient/acconfig.h   |   36 +
 pppd/plugins/radius/radiusclient/aclocal.m4   |  331 ++
 pppd/plugins/radius/radiusclient/config.guess |  693 ++++
 pppd/plugins/radius/radiusclient/config.h.in  |  161 +
 pppd/plugins/radius/radiusclient/config.sub   |  921 +++++
 pppd/plugins/radius/radiusclient/configure    | 3275 +++++++++++++++++
 pppd/plugins/radius/radiusclient/configure.in |  189 +
 .../radius/radiusclient/doc/Makefile.am       |   15 +
 .../radius/radiusclient/doc/Makefile.in       |  187 +
 .../radius/radiusclient/doc/instop.html       |  451 +++
 .../radius/radiusclient/etc/Makefile.am       |   34 +
 .../radius/radiusclient/etc/Makefile.in       |  226 ++
 .../radius/radiusclient/etc/dictionary        |  229 ++
 .../radius/radiusclient/etc/dictionary.ascend |  295 ++
 .../radius/radiusclient/etc/dictionary.compat |   45 +
 .../radius/radiusclient/etc/dictionary.merit  |   17 +
 pppd/plugins/radius/radiusclient/etc/issue    |    5 +
 .../radius/radiusclient/etc/port-id-map       |   24 +
 .../radiusclient/etc/radiusclient.conf.in     |   78 +
 pppd/plugins/radius/radiusclient/etc/servers  |    4 +
 .../radius/radiusclient/include/Makefile.am   |   15 +
 .../radius/radiusclient/include/Makefile.in   |  230 ++
 .../radius/radiusclient/include/includes.h    |  150 +
 .../radius/radiusclient/include/messages.h    |   53 +
 .../radius/radiusclient/include/pathnames.h   |   28 +
 .../radiusclient/include/radiusclient.h       |  451 +++
 pppd/plugins/radius/radiusclient/install-sh   |  250 ++
 .../radius/radiusclient/lib/Makefile.am       |   34 +
 .../radius/radiusclient/lib/Makefile.in       |  356 ++
 pppd/plugins/radius/radiusclient/lib/avpair.c |  766 ++++
 .../radius/radiusclient/lib/buildreq.c        |  370 ++
 .../radius/radiusclient/lib/clientid.c        |  122 +
 pppd/plugins/radius/radiusclient/lib/config.c |  555 +++
 pppd/plugins/radius/radiusclient/lib/dict.c   |  426 +++
 pppd/plugins/radius/radiusclient/lib/env.c    |  144 +
 .../plugins/radius/radiusclient/lib/ip_util.c |  202 +
 pppd/plugins/radius/radiusclient/lib/lock.c   |   64 +
 pppd/plugins/radius/radiusclient/lib/log.c    |   53 +
 pppd/plugins/radius/radiusclient/lib/md5.c    |  348 ++
 pppd/plugins/radius/radiusclient/lib/memcmp.c |   22 +
 .../plugins/radius/radiusclient/lib/options.h |   58 +
 .../radius/radiusclient/lib/sendserver.c      |  504 +++
 .../radius/radiusclient/lib/strcasecmp.c      |   36 +
 pppd/plugins/radius/radiusclient/lib/strdup.c |   33 +
 .../radius/radiusclient/lib/strerror.c        |   40 +
 pppd/plugins/radius/radiusclient/lib/util.c   |  237 ++
 .../radiusclient/login.radius/Makefile.am     |   18 +
 .../radiusclient/login.radius/Makefile.in     |  304 ++
 .../radius/radiusclient/login.radius/README   |    9 +
 .../radiusclient/login.radius/login.radius    |   24 +
 .../login.radius/migs/Makefile.am             |   14 +
 .../login.radius/migs/Makefile.in             |  186 +
 .../radiusclient/login.radius/migs/README     |   10 +
 .../radiusclient/login.radius/migs/ip-down    |   69 +
 .../radiusclient/login.radius/migs/ip-up      |  121 +
 .../login.radius/migs/login.radius            |  312 ++
 pppd/plugins/radius/radiusclient/ltconfig     | 1064 ++++++
 pppd/plugins/radius/radiusclient/ltmain.sh    | 1813 +++++++++
 .../radius/radiusclient/man/Makefile.am       |   13 +
 .../radius/radiusclient/man/Makefile.in       |  185 +
 pppd/plugins/radius/radiusclient/missing      |  134 +
 .../plugins/radius/radiusclient/mkinstalldirs |   36 +
 .../radius/radiusclient/patches/Makefile.am   |   16 +
 .../radius/radiusclient/patches/Makefile.in   |  188 +
 .../radius/radiusclient/patches/README        |   31 +
 .../patches/merit-2.4.21-CHAP.diff            |   41 +
 .../patches/radiusd-1.16.accounting.diff      |   82 +
 .../patches/radiusd-1.16.shadow.diff          |   12 +
 .../radius/radiusclient/src/Makefile.am       |   28 +
 .../radius/radiusclient/src/Makefile.in       |  361 ++
 pppd/plugins/radius/radiusclient/src/local.c  |   84 +
 .../plugins/radius/radiusclient/src/radacct.c |  149 +
 .../radius/radiusclient/src/radexample-debug  |   61 +
 .../radius/radiusclient/src/radexample.c      |  112 +
 pppd/plugins/radius/radiusclient/src/radius.c |  230 ++
 .../radius/radiusclient/src/radlogin.c        |  385 ++
 .../radius/radiusclient/src/radlogin.h        |   32 +
 .../radius/radiusclient/src/radstatus.c       |  114 +
 pppd/plugins/radius/radiusclient/stamp-h.in   |    1 +
 pppd/plugins/rp-pppoe/plugin.c                |   11 +-
 pppd/pppd.h                                   |    9 +-
 101 files changed, 20722 insertions(+), 58 deletions(-)
 create mode 100644 pppd/plugins/radius/Makefile.linux
 create mode 100644 pppd/plugins/radius/pppd-radattr.8
 create mode 100644 pppd/plugins/radius/pppd-radius.8
 create mode 100644 pppd/plugins/radius/radattr.c
 create mode 100644 pppd/plugins/radius/radius.c
 create mode 100644 pppd/plugins/radius/radiusclient/BUGS
 create mode 100644 pppd/plugins/radius/radiusclient/CHANGES
 create mode 100644 pppd/plugins/radius/radiusclient/COPYRIGHT
 create mode 100644 pppd/plugins/radius/radiusclient/Makefile.am
 create mode 100644 pppd/plugins/radius/radiusclient/Makefile.in
 create mode 100644 pppd/plugins/radius/radiusclient/README
 create mode 100644 pppd/plugins/radius/radiusclient/README.radexample
 create mode 100644 pppd/plugins/radius/radiusclient/acconfig.h
 create mode 100644 pppd/plugins/radius/radiusclient/aclocal.m4
 create mode 100755 pppd/plugins/radius/radiusclient/config.guess
 create mode 100644 pppd/plugins/radius/radiusclient/config.h.in
 create mode 100755 pppd/plugins/radius/radiusclient/config.sub
 create mode 100755 pppd/plugins/radius/radiusclient/configure
 create mode 100644 pppd/plugins/radius/radiusclient/configure.in
 create mode 100644 pppd/plugins/radius/radiusclient/doc/Makefile.am
 create mode 100644 pppd/plugins/radius/radiusclient/doc/Makefile.in
 create mode 100644 pppd/plugins/radius/radiusclient/doc/instop.html
 create mode 100644 pppd/plugins/radius/radiusclient/etc/Makefile.am
 create mode 100644 pppd/plugins/radius/radiusclient/etc/Makefile.in
 create mode 100644 pppd/plugins/radius/radiusclient/etc/dictionary
 create mode 100644 pppd/plugins/radius/radiusclient/etc/dictionary.ascend
 create mode 100644 pppd/plugins/radius/radiusclient/etc/dictionary.compat
 create mode 100644 pppd/plugins/radius/radiusclient/etc/dictionary.merit
 create mode 100644 pppd/plugins/radius/radiusclient/etc/issue
 create mode 100644 pppd/plugins/radius/radiusclient/etc/port-id-map
 create mode 100644 pppd/plugins/radius/radiusclient/etc/radiusclient.conf.in
 create mode 100644 pppd/plugins/radius/radiusclient/etc/servers
 create mode 100644 pppd/plugins/radius/radiusclient/include/Makefile.am
 create mode 100644 pppd/plugins/radius/radiusclient/include/Makefile.in
 create mode 100644 pppd/plugins/radius/radiusclient/include/includes.h
 create mode 100644 pppd/plugins/radius/radiusclient/include/messages.h
 create mode 100644 pppd/plugins/radius/radiusclient/include/pathnames.h
 create mode 100644 pppd/plugins/radius/radiusclient/include/radiusclient.h
 create mode 100755 pppd/plugins/radius/radiusclient/install-sh
 create mode 100644 pppd/plugins/radius/radiusclient/lib/Makefile.am
 create mode 100644 pppd/plugins/radius/radiusclient/lib/Makefile.in
 create mode 100644 pppd/plugins/radius/radiusclient/lib/avpair.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/buildreq.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/clientid.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/config.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/dict.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/env.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/ip_util.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/lock.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/log.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/md5.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/memcmp.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/options.h
 create mode 100644 pppd/plugins/radius/radiusclient/lib/sendserver.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/strcasecmp.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/strdup.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/strerror.c
 create mode 100644 pppd/plugins/radius/radiusclient/lib/util.c
 create mode 100644 pppd/plugins/radius/radiusclient/login.radius/Makefile.am
 create mode 100644 pppd/plugins/radius/radiusclient/login.radius/Makefile.in
 create mode 100644 pppd/plugins/radius/radiusclient/login.radius/README
 create mode 100755 pppd/plugins/radius/radiusclient/login.radius/login.radius
 create mode 100644 pppd/plugins/radius/radiusclient/login.radius/migs/Makefile.am
 create mode 100644 pppd/plugins/radius/radiusclient/login.radius/migs/Makefile.in
 create mode 100644 pppd/plugins/radius/radiusclient/login.radius/migs/README
 create mode 100644 pppd/plugins/radius/radiusclient/login.radius/migs/ip-down
 create mode 100644 pppd/plugins/radius/radiusclient/login.radius/migs/ip-up
 create mode 100644 pppd/plugins/radius/radiusclient/login.radius/migs/login.radius
 create mode 100755 pppd/plugins/radius/radiusclient/ltconfig
 create mode 100644 pppd/plugins/radius/radiusclient/ltmain.sh
 create mode 100644 pppd/plugins/radius/radiusclient/man/Makefile.am
 create mode 100644 pppd/plugins/radius/radiusclient/man/Makefile.in
 create mode 100755 pppd/plugins/radius/radiusclient/missing
 create mode 100755 pppd/plugins/radius/radiusclient/mkinstalldirs
 create mode 100644 pppd/plugins/radius/radiusclient/patches/Makefile.am
 create mode 100644 pppd/plugins/radius/radiusclient/patches/Makefile.in
 create mode 100644 pppd/plugins/radius/radiusclient/patches/README
 create mode 100644 pppd/plugins/radius/radiusclient/patches/merit-2.4.21-CHAP.diff
 create mode 100644 pppd/plugins/radius/radiusclient/patches/radiusd-1.16.accounting.diff
 create mode 100644 pppd/plugins/radius/radiusclient/patches/radiusd-1.16.shadow.diff
 create mode 100644 pppd/plugins/radius/radiusclient/src/Makefile.am
 create mode 100644 pppd/plugins/radius/radiusclient/src/Makefile.in
 create mode 100644 pppd/plugins/radius/radiusclient/src/local.c
 create mode 100644 pppd/plugins/radius/radiusclient/src/radacct.c
 create mode 100755 pppd/plugins/radius/radiusclient/src/radexample-debug
 create mode 100644 pppd/plugins/radius/radiusclient/src/radexample.c
 create mode 100644 pppd/plugins/radius/radiusclient/src/radius.c
 create mode 100644 pppd/plugins/radius/radiusclient/src/radlogin.c
 create mode 100644 pppd/plugins/radius/radiusclient/src/radlogin.h
 create mode 100644 pppd/plugins/radius/radiusclient/src/radstatus.c
 create mode 100644 pppd/plugins/radius/radiusclient/stamp-h.in

diff --git a/PLUGINS b/PLUGINS
index 2cbb427..206f8fc 100644
--- a/PLUGINS
+++ b/PLUGINS
@@ -147,6 +147,42 @@ pppd's internal `plogout' function.  It can be used for accounting
 purposes.  This hook is deprecated and will be replaced by a notifier.
 
 
+int (*chap_check_hook)(void);
+int (*chap_passwd_hook)(char *user, char *passwd);
+int (*chap_auth_hook)(char *user, u_char *remmd,
+	             int remmd_len, chap_state *cstate);
+
+These hooks are designed to allow a plugin to replace the normal CHAP
+password processing in pppd with something different (e.g. contacting
+an external server).
+
+The chap_check_hook is called to check whether there is any possibility
+that the peer could authenticate itself to us.  If it returns 1, pppd
+will ask the peer to authenticate itself.  If it returns 0, pppd will
+not ask the peer to authenticate itself (but if authentication is
+required, pppd may exit, or terminate the link before network protocol
+negotiation).  If it returns -1, pppd will look in the chap-secrets
+file as it would normally.
+
+The chap_passwd_hook is called to determine what password
+pppd should use in authenticating itself to the peer with CHAP.  The
+user string will already be initialized, by the `user' option, the
+`name' option, or from the hostname, but can be changed if necessary.
+This hook is called only if pppd is a client, not if it is a server.
+
+MAXSECRETLEN bytes of space are available at *passwd.  If this hook
+returns 0, pppd will use the value *passwd; if it returns -1, pppd
+will fail to authenticate.
+
+The chap_auth_hook is called to determine whether the response
+to a CHAP challenge provided by the peer is valid.  user points to
+a null-terminated string containing the username supplied
+by the peer.  remmd points to the response provided by the peer, of
+length remmd_len bytes.  cstate is the internal CHAP state structure
+maintained by pppd.  chap_auth_hook is expected to return one of
+CHAP_SUCCESS or CHAP_FAILURE.
+
+
 int (*null_auth_hook)(struct wordlist **paddrs,
 		      struct wordlist **popts);
 
@@ -167,6 +203,15 @@ should be stored in *addrp.  If nothing is stored in *addrp, pppd will
 determine the peer's address in the usual manner.
 
 
+int (*allowed_address_hook)(u_int32_t addr)
+
+This hook is called to see if a peer is allowed to use the specified
+address.  If the hook returns 1, the address is accepted.  If it returns
+0, the address is rejected.  If it returns -1, the address is verified
+in the normal away against the appropriate options and secrets files.
+
+
+
 A plugin registers itself with a notifier by declaring a procedure of
 the form:
 
@@ -213,4 +258,4 @@ Here is a list of the currently-implemented notifiers in pppd.
 
 
 
-## $Id: PLUGINS,v 1.3 2001/05/21 08:34:33 paulus Exp $ ##
+## $Id: PLUGINS,v 1.4 2002/01/22 16:02:55 dfs Exp $ ##
diff --git a/configure b/configure
index 4c94baa..6238cf6 100755
--- a/configure
+++ b/configure
@@ -1,5 +1,5 @@
 #!/bin/sh
-# $Id: configure,v 1.27 2001/12/14 02:55:19 mostrows Exp $
+# $Id: configure,v 1.28 2002/01/22 16:02:56 dfs Exp $
 
 #  if [ -d /NextApps ]; then
 #    system="NeXTStep"
@@ -131,7 +131,7 @@ if [ -d "$ksrc" ]; then
       makext=$orig_makext 
     fi
   fi
-  for dir in pppd pppstats chat pppdump pppd/plugins pppd/plugins/rp-pppoe; do
+  for dir in pppd pppstats chat pppdump pppd/plugins pppd/plugins/rp-pppoe pppd/plugins/radius; do
     rm -f $dir/Makefile
     if [ -f $dir/Makefile.$makext ]; then
       ln -s Makefile.$makext $dir/Makefile
diff --git a/pppd/auth.c b/pppd/auth.c
index 3d232be..a5fc1bd 100644
--- a/pppd/auth.c
+++ b/pppd/auth.c
@@ -32,7 +32,7 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#define RCSID	"$Id: auth.c,v 1.72 2002/01/11 18:07:45 etbe Exp $"
+#define RCSID	"$Id: auth.c,v 1.73 2002/01/22 16:02:58 dfs Exp $"
 
 #include <stdio.h>
 #include <stddef.h>
@@ -138,6 +138,8 @@ int (*pap_passwd_hook) __P((char *user, char *passwd)) = NULL;
 int (*null_auth_hook) __P((struct wordlist **paddrs,
 			   struct wordlist **popts)) = NULL;
 
+int (*allowed_address_hook) __P((u_int32_t addr)) = NULL;
+
 /* A notifier for when the peer has authenticated itself,
    and we are proceeding to the network phase. */
 struct notifier *auth_up_notifier = NULL;
@@ -949,6 +951,9 @@ check_passwd(unit, auser, userlen, apasswd, passwdlen, msg)
 	    BZERO(passwd, sizeof(passwd));
 	    if (addrs != 0)
 		free_wordlist(addrs);
+	    if (opts != 0) {
+		free_wordlist(opts);
+	    }
 	    return ret? UPAP_AUTHACK: UPAP_AUTHNAK;
 	}
     }
@@ -1401,6 +1406,13 @@ have_chap_secret(client, server, need_ip, lacks_ipp)
     char *filename;
     struct wordlist *addrs;
 
+    if (chap_check_hook) {
+	ret = (*chap_check_hook)();
+	if (ret >= 0) {
+	    return ret;
+	}
+    }
+
     filename = _PATH_CHAPFILE;
     f = fopen(filename, "r");
     if (f == NULL)
@@ -1447,6 +1459,12 @@ get_secret(unit, client, server, secret, secret_len, am_server)
 
     if (!am_server && passwd[0] != 0) {
 	strlcpy(secbuf, passwd, sizeof(secbuf));
+    } else if (!am_server && chap_passwd_hook) {
+	if ( (*chap_passwd_hook)(client, secbuf) < 0) {
+	    error("Unable to obtain CHAP password for %s on %s from plugin",
+		  client, server);
+	    return 0;
+	}
     } else {
 	filename = _PATH_CHAPFILE;
 	addrs = NULL;
@@ -1656,11 +1674,17 @@ auth_ip_addr(unit, addr)
     if (bad_ip_adrs(addr))
 	return 0;
 
+    if (allowed_address_hook) {
+	ok = allowed_address_hook(addr);
+	if (ok >= 0) return ok;
+    }
+
     if (addresses[unit] != NULL) {
 	ok = ip_addr_check(addr, addresses[unit]);
 	if (ok >= 0)
 	    return ok;
     }
+
     if (auth_required)
 	return 0;		/* no addresses authorized */
     return allow_any_ip || privileged || !have_route_to(addr);
diff --git a/pppd/chap.c b/pppd/chap.c
index 3d7a660..9bd85b5 100644
--- a/pppd/chap.c
+++ b/pppd/chap.c
@@ -33,7 +33,7 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#define RCSID	"$Id: chap.c,v 1.25 2001/03/08 05:11:11 paulus Exp $"
+#define RCSID	"$Id: chap.c,v 1.26 2002/01/22 16:02:58 dfs Exp $"
 
 /*
  * TODO:
@@ -51,6 +51,18 @@
 #include "chap_ms.h"
 #endif
 
+/* Hook for a plugin to say if we can possibly authenticate a peer using CHAP */
+int (*chap_check_hook) __P((void)) = NULL;
+
+/* Hook for a plugin to get the CHAP password for authenticating us */
+int (*chap_passwd_hook) __P((char *user, char *passwd)) = NULL;
+
+/* Hook for a plugin to validate CHAP challenge */
+int (*chap_auth_hook) __P((char *user,
+			   u_char *remmd,
+			   int remmd_len,
+			   chap_state *cstate)) = NULL;
+
 static const char rcsid[] = RCSID;
 
 /*
@@ -161,7 +173,7 @@ ChapAuthWithPeer(unit, our_name, digest)
 
     /*
      * We get here as a result of LCP coming up.
-     * So even if CHAP was open before, we will 
+     * So even if CHAP was open before, we will
      * have to re-authenticate ourselves.
      */
     cstate->clientstate = CHAPCS_LISTEN;
@@ -178,7 +190,7 @@ ChapAuthPeer(unit, our_name, digest)
     int digest;
 {
     chap_state *cstate = &chap[unit];
-  
+
     cstate->chal_name = our_name;
     cstate->chal_type = digest;
 
@@ -203,7 +215,7 @@ ChapChallengeTimeout(arg)
     void *arg;
 {
     chap_state *cstate = (chap_state *) arg;
-  
+
     /* if we aren't sending challenges, don't worry.  then again we */
     /* probably shouldn't be here either */
     if (cstate->serverstate != CHAPSS_INITIAL_CHAL &&
@@ -268,7 +280,7 @@ ChapLowerUp(unit)
     int unit;
 {
     chap_state *cstate = &chap[unit];
-  
+
     if (cstate->clientstate == CHAPCS_INITIAL)
 	cstate->clientstate = CHAPCS_CLOSED;
     else if (cstate->clientstate == CHAPCS_PENDING)
@@ -294,7 +306,7 @@ ChapLowerDown(unit)
     int unit;
 {
     chap_state *cstate = &chap[unit];
-  
+
     /* Timeout(s) pending?  Cancel if so. */
     if (cstate->serverstate == CHAPSS_INITIAL_CHAL ||
 	cstate->serverstate == CHAPSS_RECHALLENGE)
@@ -342,7 +354,7 @@ ChapInput(unit, inpacket, packet_len)
     u_char *inp;
     u_char code, id;
     int len;
-  
+
     /*
      * Parse header (code, id and length).
      * If packet too short, drop it.
@@ -364,7 +376,7 @@ ChapInput(unit, inpacket, packet_len)
 	return;
     }
     len -= CHAP_HEADERLEN;
-  
+
     /*
      * Action depends on code (as in fact it usually does :-).
      */
@@ -372,11 +384,11 @@ ChapInput(unit, inpacket, packet_len)
     case CHAP_CHALLENGE:
 	ChapReceiveChallenge(cstate, inp, id, len);
 	break;
-    
+
     case CHAP_RESPONSE:
 	ChapReceiveResponse(cstate, inp, id, len);
 	break;
-    
+
     case CHAP_FAILURE:
 	ChapReceiveFailure(cstate, inp, id, len);
 	break;
@@ -409,7 +421,7 @@ ChapReceiveChallenge(cstate, inp, id, len)
     char rhostname[256];
     MD5_CTX mdContext;
     u_char hash[MD5_SIGNATURE_SIZE];
- 
+
     if (cstate->clientstate == CHAPCS_CLOSED ||
 	cstate->clientstate == CHAPCS_PENDING) {
 	CHAPDEBUG(("ChapReceiveChallenge: in state %d", cstate->clientstate));
@@ -457,7 +469,7 @@ ChapReceiveChallenge(cstate, inp, id, len)
     cstate->resp_transmits = 0;
 
     /*  generate MD based on negotiated type */
-    switch (cstate->resp_type) { 
+    switch (cstate->resp_type) {
 
     case CHAP_DIGEST_MD5:
 	MD5Init(&mdContext);
@@ -552,34 +564,42 @@ ChapReceiveResponse(cstate, inp, id, len)
      * do the hash ourselves, and compare the result.
      */
     code = CHAP_FAILURE;
-    if (!get_secret(cstate->unit, (explicit_remote? remote_name: rhostname),
-		    cstate->chal_name, secret, &secret_len, 1)) {
-	warn("No CHAP secret found for authenticating %q", rhostname);
-    } else {
 
-	/*  generate MD based on negotiated type */
-	switch (cstate->chal_type) { 
-
-	case CHAP_DIGEST_MD5:		/* only MD5 is defined for now */
-	    if (remmd_len != MD5_SIGNATURE_SIZE)
-		break;			/* it's not even the right length */
-	    MD5Init(&mdContext);
-	    MD5Update(&mdContext, &cstate->chal_id, 1);
-	    MD5Update(&mdContext, secret, secret_len);
-	    MD5Update(&mdContext, cstate->challenge, cstate->chal_len);
-	    MD5Final(hash, &mdContext); 
-
-	    /* compare local and remote MDs and send the appropriate status */
-	    if (memcmp (hash, remmd, MD5_SIGNATURE_SIZE) == 0)
-		code = CHAP_SUCCESS;	/* they are the same! */
-	    break;
-
-	default:
-	    CHAPDEBUG(("unknown digest type %d", cstate->chal_type));
+    /* If a plugin will verify the response, let the plugin do it. */
+    if (chap_auth_hook) {
+	code = (*chap_auth_hook) ( (explicit_remote ? remote_name : rhostname),
+				   remmd, (int) remmd_len,
+				   cstate );
+    } else {
+	if (!get_secret(cstate->unit, (explicit_remote? remote_name: rhostname),
+			cstate->chal_name, secret, &secret_len, 1)) {
+	    warn("No CHAP secret found for authenticating %q", rhostname);
+	} else {
+
+	    /*  generate MD based on negotiated type */
+	    switch (cstate->chal_type) {
+
+	    case CHAP_DIGEST_MD5:		/* only MD5 is defined for now */
+		if (remmd_len != MD5_SIGNATURE_SIZE)
+		    break;			/* it's not even the right length */
+		MD5Init(&mdContext);
+		MD5Update(&mdContext, &cstate->chal_id, 1);
+		MD5Update(&mdContext, secret, secret_len);
+		MD5Update(&mdContext, cstate->challenge, cstate->chal_len);
+		MD5Final(hash, &mdContext);
+
+		/* compare local and remote MDs and send the appropriate status */
+		if (memcmp (hash, remmd, MD5_SIGNATURE_SIZE) == 0)
+		    code = CHAP_SUCCESS;	/* they are the same! */
+		break;
+
+	    default:
+		CHAPDEBUG(("unknown digest type %d", cstate->chal_type));
+	    }
 	}
-    }
 
-    BZERO(secret, sizeof(secret));
+	BZERO(secret, sizeof(secret));
+    }
     ChapSendStatus(cstate, code);
 
     if (code == CHAP_SUCCESS) {
@@ -692,7 +712,7 @@ ChapSendChallenge(cstate)
     BCOPY(cstate->chal_name, outp, name_len);	/* append hostname */
 
     output(cstate->unit, outpacket_buf, outlen + PPP_HDRLEN);
-  
+
     TIMEOUT(ChapChallengeTimeout, cstate, cstate->timeouttime);
     ++cstate->chal_transmits;
 }
@@ -720,7 +740,7 @@ ChapSendStatus(cstate, code)
     outp = outpacket_buf;
 
     MAKEHEADER(outp, PPP_CHAP);	/* paste in a header */
-  
+
     PUTCHAR(code, outp);
     PUTCHAR(cstate->chal_id, outp);
     PUTSHORT(outlen, outp);
@@ -743,8 +763,8 @@ ChapGenChallenge(cstate)
     u_char *ptr = cstate->challenge;
     int i;
 
-    /* pick a random challenge length between MIN_CHALLENGE_LENGTH and 
-       MAX_CHALLENGE_LENGTH */  
+    /* pick a random challenge length between MIN_CHALLENGE_LENGTH and
+       MAX_CHALLENGE_LENGTH */
     chal_len =  (unsigned) ((drand48() *
 			     (MAX_CHALLENGE_LENGTH - MIN_CHALLENGE_LENGTH)) +
 			    MIN_CHALLENGE_LENGTH);
diff --git a/pppd/chap.h b/pppd/chap.h
index 313efff..37d1665 100644
--- a/pppd/chap.h
+++ b/pppd/chap.h
@@ -30,7 +30,7 @@
  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  *
- * $Id: chap.h,v 1.8 1999/11/15 01:44:41 paulus Exp $
+ * $Id: chap.h,v 1.9 2002/01/22 16:02:58 dfs Exp $
  */
 
 #ifndef __CHAP_INCLUDE__
@@ -85,6 +85,9 @@ typedef struct chap_state {
     char *resp_name;		/* Our name to send with response */
 } chap_state;
 
+/* We need the declaration of chap_state to use this prototype */
+extern int (*chap_auth_hook) __P((char *user, u_char *remmd,
+				  int remmd_len, chap_state *cstate));
 
 /*
  * Client (peer) states.
diff --git a/pppd/ipcp.c b/pppd/ipcp.c
index 5e8366b..3fc5f27 100644
--- a/pppd/ipcp.c
+++ b/pppd/ipcp.c
@@ -17,7 +17,7 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#define RCSID	"$Id: ipcp.c,v 1.59 2002/01/11 18:31:42 etbe Exp $"
+#define RCSID	"$Id: ipcp.c,v 1.60 2002/01/22 16:02:58 dfs Exp $"
 
 /*
  * TODO:
@@ -656,8 +656,12 @@ ipcp_resetci(f)
     *go = *wo;
     if (!ask_for_local)
 	go->ouraddr = 0;
-    if (ip_choose_hook)
+    if (ip_choose_hook) {
 	ip_choose_hook(&wo->hisaddr);
+	if (wo->hisaddr) {
+	    wo->accept_remote = 0;
+	}
+    }
 }
 
 
diff --git a/pppd/main.c b/pppd/main.c
index a80b0a5..124f640 100644
--- a/pppd/main.c
+++ b/pppd/main.c
@@ -17,7 +17,7 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#define RCSID	"$Id: main.c,v 1.110 2002/01/14 14:25:10 dfs Exp $"
+#define RCSID	"$Id: main.c,v 1.111 2002/01/22 16:02:58 dfs Exp $"
 
 #include <stdio.h>
 #include <ctype.h>
@@ -83,6 +83,7 @@ char hostname[MAXNAMELEN];	/* Our hostname */
 static char pidfilename[MAXPATHLEN];	/* name of pid file */
 static char linkpidfile[MAXPATHLEN];	/* name of linkname pid file */
 char ppp_devnam[MAXPATHLEN];	/* name of PPP tty (maybe ttypx) */
+char remote_number[MAXNAMELEN]; /* Remote telephone number, if available */
 uid_t uid;			/* Our real user-id */
 struct notifier *pidchange = NULL;
 struct notifier *phasechange = NULL;
@@ -97,7 +98,8 @@ volatile int status;		/* exit status for pppd */
 int unsuccess;			/* # unsuccessful connection attempts */
 int do_callback;		/* != 0 if we should do callback next */
 int doing_callback;		/* != 0 if we are doing callback */
-
+int ppp_session_number;		/* Session number, for channels with such a
+				   concept (eg PPPoE) */
 #ifdef USE_TDB
 TDB_CONTEXT *pppdb;		/* database for storing status etc. */
 #endif
diff --git a/pppd/plugins/Makefile.linux b/pppd/plugins/Makefile.linux
index 0cc916b..7cdfe42 100644
--- a/pppd/plugins/Makefile.linux
+++ b/pppd/plugins/Makefile.linux
@@ -3,7 +3,7 @@ CFLAGS	= -g -O2 -I.. -I../../include -D_linux_=1 -fPIC
 LDFLAGS	= -shared
 INSTALL	= install -o root
 
-SUBDIRS = rp-pppoe
+SUBDIRS = rp-pppoe radius
 PLUGINS = minconn.so passprompt.so
 
 # include dependencies if present
diff --git a/pppd/plugins/radius/Makefile.linux b/pppd/plugins/radius/Makefile.linux
new file mode 100644
index 0000000..1fa7ff9
--- /dev/null
+++ b/pppd/plugins/radius/Makefile.linux
@@ -0,0 +1,49 @@
+# Makefile for RADIUS plugin
+#
+# Copyright 2002 Roaring Penguin Software Inc.
+#
+
+MANDIR=/usr/man
+PLUGIN=radius.so radattr.so
+CFLAGS=-I../.. -Iradiusclient/include -O2
+
+all: $(PLUGIN)
+
+install: all
+	$(MAKE) $(MFLAGS) -C radiusclient install
+	$(INSTALL) -d -m 755 $(LIBDIR)
+	$(INSTALL) -s -c -m 755 radius.so $(LIBDIR)
+	$(INSTALL) -s -c -m 755 radattr.so $(LIBDIR)
+	$(INSTALL) -c -m 444 pppd-radius.8 $(MANDIR)/man8
+	$(INSTALL) -c -m 444 pppd-radattr.8 $(MANDIR)/man8
+
+radius.so: radiusclient/lib/.libs/libradiusclient.a radius.o
+	gcc -o radius.so -shared radius.o radiusclient/lib/.libs/libradiusclient.a
+
+radattr.so: radattr.o
+	gcc -o radattr.so -shared radattr.o
+
+radius.o: radius.c
+	gcc $(CFLAGS) -c -o radius.o -fPIC radius.c
+
+radattr.o: radattr.c
+	gcc $(CFLAGS) -c -o radattr.o -fPIC radattr.c
+
+radiusclient/lib/.libs/libradiusclient.a:
+	test -r radiusclient/Makefile ||           \
+		(cd radiusclient;                  \
+		 ./configure --prefix=/usr         \
+			     --sysconfdir=/etc     \
+			     --enable-shared       \
+			     --enable-static)
+	$(MAKE) -C radiusclient
+
+clean:
+	$(MAKE) $(MFLAGS) -C radiusclient clean
+	rm -f *.o *.so
+
+distclean:
+	rm -f *.o *.so
+	$(MAKE) $(MFLAGS) -C radiusclient distclean
+
+dist-clean: distclean
diff --git a/pppd/plugins/radius/pppd-radattr.8 b/pppd/plugins/radius/pppd-radattr.8
new file mode 100644
index 0000000..c585bb5
--- /dev/null
+++ b/pppd/plugins/radius/pppd-radattr.8
@@ -0,0 +1,44 @@
+.\" manual page [] for RADATTR plugin for pppd 2.4
+.\" $Id: pppd-radattr.8,v 1.1 2002/01/22 16:03:00 dfs Exp $
+.\" SH section heading
+.\" SS subsection heading
+.\" LP paragraph
+.\" IP indented paragraph
+.\" TP hanging label
+.TH PPPD-RADATTR 8
+.SH NAME
+radattr.so \- RADIUS utility plugin for
+.BR pppd (8)
+.SH SYNOPSIS
+.B pppd
+[
+.I options
+]
+plugin radius.so plugin radattr.so
+.SH DESCRIPTION
+.LP
+The radattr plugin for pppd causes all radius attributes returned by
+the RADIUS server at authentication time to be stoed in the file
+.I /var/run/radattr.pppN
+where
+.I pppN
+is the name of the PPP interface.  The RADIUS attributes are stored
+one per line in the format "Attribute-Name Attribute-Value".  This
+format is convenient for use in /etc/ppp/ip-up and /etc/ppp/ip-down
+scripts.
+.LP
+Note that you
+.I must
+load the radius.so plugin before loading the radattr.so plugin;
+radattr.so depends on symbols defined in radius.so.
+
+.SH USAGE
+To use the plugin, simply supply the
+.B plugin radius.so plugin radattr.so
+options to pppd.
+
+.SH SEE ALSO
+.BR pppd (8) " pppd-radius" (8)
+
+.SH AUTHOR
+David F. Skoll <dfs@roaringpenguin.com>
diff --git a/pppd/plugins/radius/pppd-radius.8 b/pppd/plugins/radius/pppd-radius.8
new file mode 100644
index 0000000..4b9cddd
--- /dev/null
+++ b/pppd/plugins/radius/pppd-radius.8
@@ -0,0 +1,58 @@
+.\" manual page [] for RADIUS plugin for pppd 2.4
+.\" $Id: pppd-radius.8,v 1.1 2002/01/22 16:03:00 dfs Exp $
+.\" SH section heading
+.\" SS subsection heading
+.\" LP paragraph
+.\" IP indented paragraph
+.\" TP hanging label
+.TH PPPD-RADIUS 8
+.SH NAME
+radius.so \- RADIUS authentication plugin for
+.BR pppd (8)
+.SH SYNOPSIS
+.B pppd
+[
+.I options
+]
+plugin radius.so
+.SH DESCRIPTION
+.LP
+The RADIUS plugin for pppd permits pppd to perform CHAP and PAP authentication
+against a RADIUS server instead of the usual
+.I /etc/ppp/pap-secrets
+and
+.I /etc/ppp/chap-secrets
+files.
+.LP
+The RADIUS plugin is built on a library called
+.B radiusclient
+which has its own configuration files (usually in \fI/etc/radiusclient\fR),
+consult those files for more information on configuring the RADIUS
+plugin
+
+.SH OPTIONS
+The RADIUS plugin introduces one additional pppd option:
+.TP
+.BI "radius-config-file " filename
+The file
+.I filename
+is taken as the radiusclient configuration file.  If this option is not
+used, then the plugin uses
+.I /etc/radiusclient/radiusclient.conf
+as the configuration file.
+
+.SH USAGE
+To use the plugin, simply supply the
+.B plugin radius.so
+option to pppd, and edit
+.I /etc/radiusclient/radiusclient.conf
+appropriately.  If you use the RADIUS plugin, the normal pppd authentication
+schemes (login, checking the /etc/ppp/*-secrets files) are skipped.  The
+RADIUS server should assign an IP address to the peer using the RADIUS
+Framed-IP-Address attribute.
+
+.SH SEE ALSO
+.BR pppd (8) " pppd-radattr" (8)
+
+.SH AUTHOR
+David F. Skoll <dfs@roaringpenguin.com>
diff --git a/pppd/plugins/radius/radattr.c b/pppd/plugins/radius/radattr.c
new file mode 100644
index 0000000..77fc61d
--- /dev/null
+++ b/pppd/plugins/radius/radattr.c
@@ -0,0 +1,102 @@
+/***********************************************************************
+*
+* radattr.c
+*
+* A plugin which is stacked on top of radius.so.  This plugin writes
+* all RADIUS attributes from the server's authentication confirmation
+* into /var/run/radattr.pppN.  These attributes are available for
+* consumption by /etc/ppp/ip-{up,down} scripts.
+*
+* Copyright (C) 2002 Roaring Penguin Software Inc.
+*
+* This plugin may be distributed according to the terms of the GNU
+* General Public License, version 2 or (at your option) any later version.
+*
+***********************************************************************/
+
+static char const RCSID[] =
+"$Id: radattr.c,v 1.1 2002/01/22 16:03:00 dfs Exp $";
+
+#include "pppd.h"
+#include "radiusclient.h"
+#include <stdio.h>
+
+extern void (*radius_attributes_hook)(VALUE_PAIR *);
+static void print_attributes(VALUE_PAIR *);
+static void cleanup(void *opaque, int arg);
+
+char pppd_version[] = VERSION;
+
+/**********************************************************************
+* %FUNCTION: plugin_init
+* %ARGUMENTS:
+*  None
+* %RETURNS:
+*  Nothing
+* %DESCRIPTION:
+*  Initializes radattr plugin.
+***********************************************************************/
+void
+plugin_init(void)
+{
+    radius_attributes_hook = print_attributes;
+
+    add_notifier(&link_down_notifier, cleanup, NULL);
+
+    /* Just in case... */
+    add_notifier(&exitnotify, cleanup, NULL);
+    info("RADATTR plugin initialized.");
+}
+
+/**********************************************************************
+* %FUNCTION: print_attributes
+* %ARGUMENTS:
+*  vp -- linked-list of RADIUS attribute-value pairs
+* %RETURNS:
+*  Nothing
+* %DESCRIPTION:
+*  Prints the attribute pairs to /var/run/radattr.pppN.  Each line of the
+*  file contains "name value" pairs.
+***********************************************************************/
+static void
+print_attributes(VALUE_PAIR *vp)
+{
+    FILE *fp;
+    char fname[512];
+    char name[2048];
+    char value[2048];
+
+    slprintf(fname, sizeof(fname), "/var/run/radattr.%s", ifname);
+    fp = fopen(fname, "w");
+    if (!fp) {
+	warn("radattr plugin: Could not open %s for writing: %m", fname);
+	return;
+    }
+
+    for (; vp; vp=vp->next) {
+	if (rc_avpair_tostr(vp, name, sizeof(name), value, sizeof(value)) < 0) {
+	    continue;
+	}
+	fprintf(fp, "%s %s\n", name, value);
+    }
+    fclose(fp);
+}
+
+/**********************************************************************
+* %FUNCTION: cleanup
+* %ARGUMENTS:
+*  opaque -- not used
+*  arg -- not used
+* %RETURNS:
+*  Nothing
+* %DESCRIPTION:
+*  Deletes /var/run/radattr.pppN
+***********************************************************************/
+static void
+cleanup(void *opaque, int arg)
+{
+    char fname[512];
+
+    slprintf(fname, sizeof(fname), "/var/run/radattr.%s", ifname);
+    (void) remove(fname);
+}
diff --git a/pppd/plugins/radius/radius.c b/pppd/plugins/radius/radius.c
new file mode 100644
index 0000000..3ef6454
--- /dev/null
+++ b/pppd/plugins/radius/radius.c
@@ -0,0 +1,694 @@
+/***********************************************************************
+*
+* radius.c
+*
+* RADIUS plugin for pppd.  Performs PAP and CHAP authentication using
+* RADIUS.
+*
+* Copyright (C) 2002 Roaring Penguin Software Inc.
+*
+* Based on a patch for ipppd, which is:
+*    Copyright (C) 1996, Matjaz Godec <gody@elgo.si>
+*    Copyright (C) 1996, Lars Fenneberg <in5y050@public.uni-hamburg.de>
+*    Copyright (C) 1997, Miguel A.L. Paraz <map@iphil.net>
+*
+* Uses radiusclient library, which is:
+*    Copyright (C) 1995,1996,1997,1998 Lars Fenneberg <lf@elemental.net>
+*    Copyright (C) 2002 Roaring Penguin Software Inc.
+*
+* This plugin may be distributed according to the terms of the GNU
+* General Public License, version 2 or (at your option) any later version.
+*
+***********************************************************************/
+static char const RCSID[] =
+"$Id: radius.c,v 1.1 2002/01/22 16:03:00 dfs Exp $";
+
+#include "pppd.h"
+#include "chap.h"
+#include "radiusclient.h"
+#include "fsm.h"
+#include "ipcp.h"
+#include <syslog.h>
+#include <sys/types.h>
+#include <sys/time.h>
+
+#define BUF_LEN 1024
+
+static char *config_file = NULL;
+
+static option_t Options[] = {
+    { "radius-config-file", o_string, &config_file },
+    { NULL }
+};
+
+static int radius_secret_check(void);
+static int radius_pap_auth(char *user,
+			   char *passwd,
+			   char **msgp,
+			   struct wordlist **paddrs,
+			   struct wordlist **popts);
+static int radius_chap_auth(char *user,
+			    u_char *remmd,
+			    int remmd_len,
+			    chap_state *cstate);
+
+static void radius_ip_up(void *opaque, int arg);
+static void radius_ip_down(void *opaque, int arg);
+static void make_username_realm(char *user);
+static int radius_setparams(VALUE_PAIR *vp, char *msg);
+static void radius_choose_ip(u_int32_t *addrp);
+static int radius_init(char *msg);
+static int get_client_port(char *ifname);
+static int radius_allowed_address(u_int32_t addr);
+
+void (*radius_attributes_hook)(VALUE_PAIR *) = NULL;
+
+#ifndef MAXSESSIONID
+#define MAXSESSIONID 32
+#endif
+
+struct radius_state {
+    int accounting_started;
+    int initialized;
+    int client_port;
+    int choose_ip;
+    int any_ip_addr_ok;
+    int done_chap_once;
+    u_int32_t ip_addr;
+    char user[MAXNAMELEN];
+    char config_file[MAXPATHLEN];
+    char session_id[MAXSESSIONID + 1];
+    time_t start_time;
+};
+
+static struct radius_state rstate;
+
+char pppd_version[] = VERSION;
+
+/**********************************************************************
+* %FUNCTION: plugin_init
+* %ARGUMENTS:
+*  None
+* %RETURNS:
+*  Nothing
+* %DESCRIPTION:
+*  Initializes RADIUS plugin.
+***********************************************************************/
+void
+plugin_init(void)
+{
+    pap_check_hook = radius_secret_check;
+    pap_auth_hook = radius_pap_auth;
+
+    chap_check_hook = radius_secret_check;
+    chap_auth_hook = radius_chap_auth;
+
+    ip_choose_hook = radius_choose_ip;
+    allowed_address_hook = radius_allowed_address;
+
+    add_notifier(&ip_up_notifier, radius_ip_up, NULL);
+    add_notifier(&ip_down_notifier, radius_ip_down, NULL);
+
+    memset(&rstate, 0, sizeof(rstate));
+
+    strlcpy(rstate.config_file, "/etc/radiusclient/radiusclient.conf",
+	    sizeof(rstate.config_file));
+
+    add_options(Options);
+
+    info("RADIUS plugin initialized.");
+}
+
+/**********************************************************************
+* %FUNCTION: radius_secret_check
+* %ARGUMENTS:
+*  None
+* %RETURNS:
+*  1 -- we are ALWAYS willing to supply a secret. :-)
+* %DESCRIPTION:
+* Tells pppd that we will try to authenticate the peer, and not to
+* worry about looking in /etc/ppp/*-secrets
+***********************************************************************/
+static int
+radius_secret_check(void)
+{
+    return 1;
+}
+
+/**********************************************************************
+* %FUNCTION: radius_choose_ip
+* %ARGUMENTS:
+*  addrp -- where to store the IP address
+* %RETURNS:
+*  Nothing
+* %DESCRIPTION:
+*  If RADIUS server has specified an IP address, it is stored in *addrp.
+***********************************************************************/
+static void
+radius_choose_ip(u_int32_t *addrp)
+{
+    if (rstate.choose_ip) {
+	*addrp = rstate.ip_addr;
+    }
+}
+
+/**********************************************************************
+* %FUNCTION: radius_pap_auth
+* %ARGUMENTS:
+*  user -- user-name of peer
+*  passwd -- password supplied by peer
+*  msgp -- Message which will be sent in PAP response
+*  paddrs -- set to a list of possible peer IP addresses
+*  popts -- set to a list of additional pppd options
+* %RETURNS:
+*  1 if we can authenticate, -1 if we cannot.
+* %DESCRIPTION:
+* Performs PAP authentication using RADIUS
+***********************************************************************/
+static int
+radius_pap_auth(char *user,
+		char *passwd,
+		char **msgp,
+		struct wordlist **paddrs,
+		struct wordlist **popts)
+{
+    VALUE_PAIR *send, *received;
+    UINT4 av_type;
+    int result;
+    static char radius_msg[BUF_LEN];
+
+    radius_msg[0] = 0;
+    *msgp = radius_msg;
+
+    if (radius_init(radius_msg) < 0) {
+	return 0;
+    }
+
+    send = NULL;
+    received = NULL;
+
+    /* Hack... the "port" is the ppp interface number.  Should really be
+       the tty */
+    rstate.client_port = get_client_port(ifname);
+
+    av_type = PW_FRAMED;
+    rc_avpair_add(&send, PW_SERVICE_TYPE, &av_type, 0, VENDOR_NONE);
+
+    av_type = PW_PPP;
+    rc_avpair_add(&send, PW_FRAMED_PROTOCOL, &av_type, 0, VENDOR_NONE);
+
+    /* Put user with potentially realm added in rstate.user */
+    make_username_realm(user);
+
+    rc_avpair_add(&send, PW_USER_NAME, rstate.user , 0, VENDOR_NONE);
+    rc_avpair_add(&send, PW_USER_PASSWORD, passwd, 0, VENDOR_NONE);
+    if (*remote_number) {
+	rc_avpair_add(&send, PW_CALLING_STATION_ID, remote_number, 0,
+		       VENDOR_NONE);
+    }
+
+    result = rc_auth(rstate.client_port, send, &received, radius_msg);
+
+    if (result == OK_RC) {
+	if (radius_setparams(received, radius_msg) < 0) {
+	    result = ERROR_RC;
+	}
+    }
+
+    /* free value pairs */
+    rc_avpair_free(received);
+    rc_avpair_free(send);
+
+    return (result == OK_RC) ? 1 : 0;
+}
+
+/**********************************************************************
+* %FUNCTION: radius_chap_auth
+* %ARGUMENTS:
+*  user -- user-name of peer
+*  remmd -- hash received from peer
+*  remmd_len -- length of remmd
+*  cstate -- pppd's chap_state structure
+* %RETURNS:
+*  CHAP_SUCCESS if we can authenticate, CHAP_FAILURE if we cannot.
+* %DESCRIPTION:
+* Performs CHAP authentication using RADIUS
+***********************************************************************/
+static int
+radius_chap_auth(char *user,
+		 u_char *remmd,
+		 int remmd_len,
+		 chap_state *cstate)
+{
+    VALUE_PAIR *send, *received;
+    UINT4 av_type;
+    static char radius_msg[BUF_LEN];
+    int result;
+    u_char cpassword[MD5_SIGNATURE_SIZE+1];
+    radius_msg[0] = 0;
+
+    if (radius_init(radius_msg) < 0) {
+	error("%s", radius_msg);
+	return CHAP_FAILURE;
+    }
+
+    /* we handle md5 digest at the moment */
+    if (cstate->chal_type != CHAP_DIGEST_MD5) {
+	error("RADIUS: Challenge type not MD5");
+	return CHAP_FAILURE;
+    }
+
+    /* Put user with potentially realm added in rstate.user */
+    if (!rstate.done_chap_once) {
+	make_username_realm(user);
+	rstate.client_port = get_client_port (ifname);
+    }
+
+    send = received = NULL;
+
+    av_type = PW_FRAMED;
+    rc_avpair_add (&send, PW_SERVICE_TYPE, &av_type, 0, VENDOR_NONE);
+
+    av_type = PW_PPP;
+    rc_avpair_add (&send, PW_FRAMED_PROTOCOL, &av_type, 0, VENDOR_NONE);
+
+    rc_avpair_add (&send, PW_USER_NAME, rstate.user , 0, VENDOR_NONE);
+
+    /*
+     * add the CHAP-Password and CHAP-Challenge fields
+     */
+
+    cpassword[0] = cstate->chal_id;
+
+    memcpy(&cpassword[1], remmd, MD5_SIGNATURE_SIZE);
+
+    rc_avpair_add(&send, PW_CHAP_PASSWORD, cpassword, MD5_SIGNATURE_SIZE + 1, VENDOR_NONE);
+
+    rc_avpair_add(&send, PW_CHAP_CHALLENGE, cstate->challenge, cstate->chal_len, VENDOR_NONE);
+
+    /*
+     * make authentication with RADIUS server
+     */
+
+    result = rc_auth (rstate.client_port, send, &received, radius_msg);
+
+    if (result == OK_RC) {
+	if (!rstate.done_chap_once) {
+	    if (radius_setparams(received, radius_msg) < 0) {
+		error("%s", radius_msg);
+		result = ERROR_RC;
+	    } else {
+		rstate.done_chap_once = 1;
+	    }
+	}
+    }
+
+    rc_avpair_free(received);
+    rc_avpair_free (send);
+    return (result == OK_RC) ? CHAP_SUCCESS : CHAP_FAILURE;
+}
+
+/**********************************************************************
+* %FUNCTION: make_username_realm
+* %ARGUMENTS:
+*  user -- the user given to pppd
+* %RETURNS:
+*  Nothing
+* %DESCRIPTION:
+*  Copies user into rstate.user.  If it lacks a realm (no "@domain" part),
+* then the default realm from the radiusclient config file is added.
+***********************************************************************/
+static void
+make_username_realm(char *user)
+{
+    char *default_realm;
+
+    if ( user != NULL ) {
+	strlcpy(rstate.user, user, sizeof(rstate.user));
+    }  else {
+	rstate.user[0] = 0;
+    }
+
+    default_realm = rc_conf_str("default_realm");
+
+    if (!strchr(rstate.user, '@') &&
+	default_realm &&
+	(*default_realm != '\0')) {
+	strlcat(rstate.user, "@", sizeof(rstate.user));
+	strlcat(rstate.user, default_realm, sizeof(rstate.user));
+    }
+}
+
+/**********************************************************************
+* %FUNCTION: radius_setparams
+* %ARGUMENTS:
+*  vp -- received value-pairs
+*  msg -- buffer in which to place error message.  Holds up to BUF_LEN chars
+* %RETURNS:
+*  >= 0 on success; -1 on failure
+* %DESCRIPTION:
+*  Parses attributes sent by RADIUS server and sets them in pppd.  Currently,
+*  used only to set IP address.
+***********************************************************************/
+static int
+radius_setparams(VALUE_PAIR *vp, char *msg)
+{
+    u_int32_t remote;
+
+    /* Send RADIUS attributes to anyone else who might be interested */
+    if (radius_attributes_hook) {
+	(*radius_attributes_hook)(vp);
+    }
+
+    /*
+     * service type (if not framed then quit),
+     * new IP address (RADIUS can define static IP for some users),
+     */
+
+    while (vp) {
+	switch (vp->attribute) {
+	case PW_SERVICE_TYPE:
+	    /* check for service type       */
+	    /* if not FRAMED then exit      */
+	    if (vp->lvalue != PW_FRAMED) {
+		slprintf(msg, BUF_LEN, "RADIUS: wrong service type %ld for %s",
+			 vp->lvalue, rstate.user);
+		return -1;
+	    }
+	    break;
+	case PW_FRAMED_PROTOCOL:
+	    /* check for framed protocol type       */
+	    /* if not PPP then also exit            */
+	    if (vp->lvalue != PW_PPP) {
+		slprintf(msg, BUF_LEN, "RADIUS: wrong framed protocol %ld for %s",
+			 vp->lvalue, rstate.user);
+		return -1;
+	    }
+	    break;
+
+	case PW_FRAMED_IP_ADDRESS:
+	    /* seting up remote IP addresses */
+	    remote = vp->lvalue;
+	    if (remote == 0xffffffff) {
+		/* 0xffffffff means user should be allowed to select one */
+		rstate.any_ip_addr_ok = 1;
+	    } else if (remote != 0xfffffffe) {
+		/* 0xfffffffe means NAS should select an ip address */
+		remote = htonl(vp->lvalue);
+		if (bad_ip_adrs (remote)) {
+		    slprintf(msg, BUF_LEN, "RADIUS: bad remote IP address %I for %s",
+			     remote, rstate.user);
+		    return -1;
+		}
+		rstate.choose_ip = 1;
+		rstate.ip_addr = remote;
+	    }
+	    break;
+	}
+	vp = vp->next;
+    }
+    return 0;
+}
+
+/**********************************************************************
+* %FUNCTION: radius_acct_start
+* %ARGUMENTS:
+*  None
+* %RETURNS:
+*  Nothing
+* %DESCRIPTION:
+*  Sends a "start" accounting message to the RADIUS server.
+***********************************************************************/
+static void
+radius_acct_start(void)
+{
+    UINT4 av_type;
+    int result;
+    VALUE_PAIR *send = NULL;
+    ipcp_options *ho = &ipcp_hisoptions[0];
+    u_int32_t hisaddr;
+
+    if (!rstate.initialized) {
+	return;
+    }
+
+    rstate.start_time = time(NULL);
+
+    strncpy(rstate.session_id, rc_mksid(), sizeof(rstate.session_id));
+
+    rc_avpair_add(&send, PW_ACCT_SESSION_ID,
+		   rstate.session_id, 0, VENDOR_NONE);
+    rc_avpair_add(&send, PW_USER_NAME,
+		   rstate.user, 0, VENDOR_NONE);
+
+    av_type = PW_STATUS_START;
+    rc_avpair_add(&send, PW_ACCT_STATUS_TYPE, &av_type, 0, VENDOR_NONE);
+
+    av_type = PW_FRAMED;
+    rc_avpair_add(&send, PW_SERVICE_TYPE, &av_type, 0, VENDOR_NONE);
+
+    av_type = PW_PPP;
+    rc_avpair_add(&send, PW_FRAMED_PROTOCOL, &av_type, 0, VENDOR_NONE);
+
+    if (*remote_number) {
+	rc_avpair_add(&send, PW_CALLING_STATION_ID,
+		       remote_number, 0, VENDOR_NONE);
+    }
+
+    av_type = PW_RADIUS;
+    rc_avpair_add(&send, PW_ACCT_AUTHENTIC, &av_type, 0, VENDOR_NONE);
+
+
+    av_type = PW_ASYNC;
+    rc_avpair_add(&send, PW_NAS_PORT_TYPE, &av_type, 0, VENDOR_NONE);
+
+    hisaddr = ho->hisaddr;
+    av_type = htonl(hisaddr);
+    rc_avpair_add(&send, PW_FRAMED_IP_ADDRESS , &av_type , 0, VENDOR_NONE);
+
+    result = rc_acct(rstate.client_port, send);
+
+    rc_avpair_free(send);
+
+    if (result != OK_RC) {
+	/* RADIUS server could be down so make this a warning */
+	syslog(LOG_WARNING,
+		"Accounting START failed for %s", rstate.user);
+    } else {
+	rstate.accounting_started = 1;
+    }
+}
+
+/**********************************************************************
+* %FUNCTION: radius_acct_stop
+* %ARGUMENTS:
+*  None
+* %RETURNS:
+*  Nothing
+* %DESCRIPTION:
+*  Sends a "stop" accounting message to the RADIUS server.
+***********************************************************************/
+static void
+radius_acct_stop(void)
+{
+    UINT4 av_type;
+    VALUE_PAIR *send = NULL;
+    ipcp_options *ho = &ipcp_hisoptions[0];
+    u_int32_t hisaddr;
+    int result;
+
+    if (!rstate.initialized) {
+	return;
+    }
+
+    if (!rstate.accounting_started) {
+	return;
+    }
+
+    rstate.accounting_started = 0;
+    rc_avpair_add(&send, PW_ACCT_SESSION_ID, rstate.session_id,
+		   0, VENDOR_NONE);
+
+    rc_avpair_add(&send, PW_USER_NAME, rstate.user, 0, VENDOR_NONE);
+
+    av_type = PW_STATUS_STOP;
+    rc_avpair_add(&send, PW_ACCT_STATUS_TYPE, &av_type, 0, VENDOR_NONE);
+
+    av_type = PW_FRAMED;
+    rc_avpair_add(&send, PW_SERVICE_TYPE, &av_type, 0, VENDOR_NONE);
+
+    av_type = PW_PPP;
+    rc_avpair_add(&send, PW_FRAMED_PROTOCOL, &av_type, 0, VENDOR_NONE);
+
+    av_type = PW_RADIUS;
+    rc_avpair_add(&send, PW_ACCT_AUTHENTIC, &av_type, 0, VENDOR_NONE);
+
+
+    if (link_stats_valid) {
+	av_type = link_connect_time;
+	rc_avpair_add(&send, PW_ACCT_SESSION_TIME, &av_type, 0, VENDOR_NONE);
+
+	av_type = link_stats.bytes_out;
+	rc_avpair_add(&send, PW_ACCT_OUTPUT_OCTETS, &av_type, 0, VENDOR_NONE);
+
+	av_type = link_stats.bytes_in;
+	rc_avpair_add(&send, PW_ACCT_INPUT_OCTETS, &av_type, 0, VENDOR_NONE);
+
+	av_type = link_stats.pkts_out;
+	rc_avpair_add(&send, PW_ACCT_OUTPUT_PACKETS, &av_type, 0, VENDOR_NONE);
+
+	av_type = link_stats.pkts_in;
+	rc_avpair_add(&send, PW_ACCT_INPUT_PACKETS, &av_type, 0, VENDOR_NONE);
+    }
+
+    if (*remote_number) {
+	rc_avpair_add(&send, PW_CALLING_STATION_ID,
+		       remote_number, 0, VENDOR_NONE);
+    }
+
+    av_type = PW_ASYNC;
+    rc_avpair_add(&send, PW_NAS_PORT_TYPE, &av_type, 0, VENDOR_NONE);
+
+    hisaddr = ho->hisaddr;
+    av_type = htonl(hisaddr);
+    rc_avpair_add(&send, PW_FRAMED_IP_ADDRESS , &av_type , 0, VENDOR_NONE);
+
+    result = rc_acct(rstate.client_port, send);
+    if (result != OK_RC) {
+	/* RADIUS server could be down so make this a warning */
+	syslog(LOG_WARNING,
+		"Accounting STOP failed for %s", rstate.user);
+    }
+    rc_avpair_free(send);
+}
+
+/**********************************************************************
+* %FUNCTION: radius_ip_up
+* %ARGUMENTS:
+*  opaque -- ignored
+*  arg -- ignored
+* %RETURNS:
+*  Nothing
+* %DESCRIPTION:
+*  Called when IPCP is up.  We'll do a start-accounting record.
+***********************************************************************/
+static void
+radius_ip_up(void *opaque, int arg)
+{
+    radius_acct_start();
+}
+
+/**********************************************************************
+* %FUNCTION: radius_ip_down
+* %ARGUMENTS:
+*  opaque -- ignored
+*  arg -- ignored
+* %RETURNS:
+*  Nothing
+* %DESCRIPTION:
+*  Called when IPCP is down.  We'll do a stop-accounting record.
+***********************************************************************/
+static void
+radius_ip_down(void *opaque, int arg)
+{
+    radius_acct_stop();
+}
+
+/**********************************************************************
+* %FUNCTION: radius_init
+* %ARGUMENTS:
+*  msg -- buffer of size BUF_LEN for error message
+* %RETURNS:
+*  negative on failure; non-negative on success
+* %DESCRIPTION:
+*  Initializes radiusclient library
+***********************************************************************/
+static int
+radius_init(char *msg)
+{
+    if (rstate.initialized) {
+	return 0;
+    }
+
+    if (config_file && *config_file) {
+	strlcpy(rstate.config_file, config_file, MAXPATHLEN-1);
+    }
+
+    rstate.initialized = 1;
+
+    if (rc_read_config(rstate.config_file) != 0) {
+	slprintf(msg, BUF_LEN, "RADIUS: Can't read config file %s",
+		 rstate.config_file);
+	return -1;
+    }
+
+    if (rc_read_dictionary(rc_conf_str("dictionary")) != 0) {
+	slprintf(msg, BUF_LEN, "RADIUS: Can't read dictionary file %s",
+		 rc_conf_str("dictionary"));
+	return -1;
+    }
+
+    if (rc_read_mapfile(rc_conf_str("mapfile")) != 0)	{
+	slprintf(msg, BUF_LEN, "RADIUS: Can't read map file %s",
+		 rc_conf_str("mapfile"));
+	return -1;
+    }
+    return 0;
+}
+
+/**********************************************************************
+* %FUNCTION: get_client_port
+* %ARGUMENTS:
+*  ifname -- PPP interface name (e.g. "ppp7")
+* %RETURNS:
+*  The NAS port number (e.g. 7)
+* %DESCRIPTION:
+*  Extracts the port number from the interface name
+***********************************************************************/
+static int
+get_client_port(char *ifname)
+{
+    int port;
+    if (sscanf(ifname, "ppp%d", &port) == 1) {
+	return port;
+    }
+    return rc_map2id(ifname);
+}
+
+/**********************************************************************
+* %FUNCTION: radius_allowed_address
+* %ARGUMENTS:
+*  addr -- IP address
+* %RETURNS:
+*  1 if we're allowed to use that IP address; 0 if not; -1 if we do
+*  not know.
+***********************************************************************/
+static int
+radius_allowed_address(u_int32_t addr)
+{
+    ipcp_options *wo = &ipcp_wantoptions[0];
+
+    if (!rstate.choose_ip) {
+	/* If RADIUS server said any address is OK, then fine... */
+	if (rstate.any_ip_addr_ok) {
+	    return 1;
+	}
+
+	/* Sigh... if an address was supplied for remote host in pppd
+	   options, it has to match that.  */
+	if (wo->hisaddr != 0 && wo->hisaddr == addr) {
+	    return 1;
+	}
+
+	return 0;
+    }
+    if (addr == rstate.ip_addr) return 1;
+    return 0;
+}
+
+/* Useful for other plugins */
+char *radius_logged_in_user(void)
+{
+    return rstate.user;
+}
+
diff --git a/pppd/plugins/radius/radiusclient/BUGS b/pppd/plugins/radius/radiusclient/BUGS
new file mode 100644
index 0000000..8d7954d
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/BUGS
@@ -0,0 +1,19 @@
+$Id: BUGS,v 1.1 2002/01/22 16:03:00 dfs Exp $
+
+Testing can show the presense of bugs, but not their absence.
+                -- Dijkstra
+
+The get_seqnbr function in build_req.c sometimes returns the same
+number, if invoked from multiple processes at the same time. This
+occurs only if a lot of process try to read the sequence file,
+so I suspect a race condition in the locking code, but I can't
+find one. Any help is appreciated.
+
+Radlogin respectively send_server in sendserver.c does not honour a 
+ACCESS_CHALLENGE packet from the RADIUS server. 
+
+There are interoperability problems with radiusd 1.16... but all the Merit
+radiusds I tried worked (last one I tried 2.4.21). There is an option to
+configure (--enable-radius-116) to kludge around this... It turned out to be
+a bug in radiusd 1.16: it doesn't include the shared secret in the digest
+calculation. See patches/radiusd-1.16.accounting.diff for a real fix.
diff --git a/pppd/plugins/radius/radiusclient/CHANGES b/pppd/plugins/radius/radiusclient/CHANGES
new file mode 100644
index 0000000..8c73f11
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/CHANGES
@@ -0,0 +1,120 @@
+$Id: CHANGES,v 1.1 2002/01/22 16:03:00 dfs Exp $
+
+This file only documents fixed bugs and new features.. well, if I am not
+too lazy...
+
+01-06-99	Added support for RFC compliant accounting request digest
+		calculation.
+		Added new attributes and value defines to radiusclient.h.
+		Deleted an fclose at the wrong place (could lead to SIGSEGV).
+		Add newlines when constructing message from Reply-Message
+		attributes.
+		Output warning message when --enable-radius-116 is enabled.
+
+07-19-98	Changed licensing terms (GPL -> BSD style).
+		Added pointer to pppd patches in patches/README.
+
+03-06-98	Added patch patches/radiusd-1.16.accounting.diff.
+
+02-10-98	IMPORTANT! Changed the name of the "clients" config file
+		directive and the file name itself to "servers". This should
+		better reflect its content. Furthermore "servers" is now
+		installed mode 600 and not 644. Thanks go to Tilman
+		Mueller-Gerbes <tmg@suse.de> for pointing this out.
+
+01-15-98	Fixed two bugs in lib/sendserver.c, rc_random_vector:
+			- file descriptor leak (found by Michael Lausch)
+			- vector was not increased with each read
+
+01-14-98	Portability changes for NetBSD and BSDI. It compiles cleanly
+		on both platforms, now. But I haven't been able to test the
+		resulting executables. Many thanks go to Meno Abels
+		<Meno.Abels@Technical.Adviser.com> for providing accounts on
+		a NetBSD and BSDI machine. Furthermore I'd like to thank
+		Dave Burgess <burgess@cynjut.neonramp.com> for his help.
+
+Dezember 1997, 	Lots of portability changes. 
+January 1998	Switched to autconf, automake and libtool.
+		Change all occurences of radclient to radiusclient (in file and 
+		directory names). 
+		Added shared libradiusclient.
+		Removed check for login_radius in lib/config.c.	
+		Fixed bug in src/radacct.c which lead to a SIGSEGV
+		when calling ttyname(3).
+		Added support for longer passwords (mostly untested).
+		Integrated includes/config.h into the configure script.
+
+09-15-96	intermediate release: changed my email address and homepage.
+			included the new (working) pppd patch.
+
+06-01-96	patch to pppd included, contributed by Matjaz Godec
+		<gody@elgo.si>, heavily changed and broken by me.
+
+06-01-96	ppptraffic is gone, it wasn't really useful as the kernel
+		ppp clears the stats right when the device goes done.
+		Maybe it's possible to add this functionality to pppd
+		directly.
+
+05-13-96	rc_mksid is back in libradiusclient.a
+
+05-12-96	Fixed some bugs in the files MCONFIG and Makefile (reported by
+		Matjaz Godec <gody@elgo.si>).
+
+05-12-96	rc_avpair_add, rc_avpair_new, rc_avpair_assign have a new
+		last argument: the length of the attribute. This can
+		normally always be zero and is needed only in the special
+		case when you want to send raw data strings which might
+		contain a \0 character.
+
+05-11-96	rc_map2id now preceeds its argument with /dev/ if neccessary
+
+05-03-96	I changed the tabbing style, so from now on tabs are 4
+		characters so that there's more space for full blown and
+		complicated if, switch, etc. structures. Remember this when
+		you look at the source.
+
+05-03-96	improved error checking in a few places and changed
+		logging so that now everything goes into syslog.
+		facility is configurable in config.h (SYSLOG_FACILITY)
+
+05-02-96	added admin logins: you can now change the radiusclient
+		config file from remote. much is still missing. to use this
+		feature define a RADIUS user with a service type of
+		Administrative.
+
+05-01-96	MERIT_GRANDFATHER compatability define removed again,
+		it's simply broken. You HAVE to compile Merit radiusd
+		without this define for outbound and admin logins to work.
+
+05-01-96	config.c rewritten, the syntax of more than one authserver
+		or acctserver directive in radiusclient.conf is no longer
+		supported. instead mutliple servers have to be specified
+		in one line seperated by comma.
+
+05-01-96	added outbound support to radlogin, usably via telnet or
+		pseudo tty (rport sets this tty up on a remote host).
+
+03-19-96	added support for /etc/nologin, new config option "nologin"
+		in radiusclient.conf
+
+03-18-96	Linux (>=1.3.x): added support for /dev/urandom for more
+		secure user passwords
+
+03-17-96	normal usage messages are now seperate in src/messages.h
+		(thanks go to Migs, who pointed out that this would
+		be usefull)
+
+03-15-96	added SCP define, to derive a service type from a user
+		name prefix and supply it to the RADIUS server
+
+03-14-96	added RADIUS_116 define, accounting should now "work" with
+		Livingston radiusd v1.16.
+
+		cleaned up the enviroment handling, the global setenv was
+		a mess.
+
+01-07-95	added ppptraffic which reads out the ppp statistics just
+		like pppstats.
+		this works only for ppp as slip has no such statistics
+		(besides packets sent/received which is not very
+		 useful).
diff --git a/pppd/plugins/radius/radiusclient/COPYRIGHT b/pppd/plugins/radius/radiusclient/COPYRIGHT
new file mode 100644
index 0000000..3a0f999
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/COPYRIGHT
@@ -0,0 +1,90 @@
+See the respective source files to find out which copyrights apply.
+
+------------------------------------------------------------------------------
+Copyright (C) 2002 Roaring Penguin Software Inc.
+
+Permission to use, copy, modify, and distribute this software for any
+purpose and without fee is hereby granted, provided that this
+copyright and permission notice appear on all copies and supporting
+documentation, the name of Roaring Penguin Software Inc. not be used
+in advertising or publicity pertaining to distribution of the program
+without specific prior permission, and notice be given in supporting
+documentation that copying and distribution is by permission of
+Roaring Penguin Software Inc..
+
+Roaring Penguin Software Inc. makes no representations about the
+suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+------------------------------------------------------------------------------
+Copyright (C) 1995,1996,1997,1998 Lars Fenneberg <lf@elemental.net>
+
+Permission to use, copy, modify, and distribute this software for any
+purpose and without fee is hereby granted, provided that this copyright and
+permission notice appear on all copies and supporting documentation, the
+name of Lars Fenneberg not be used in advertising or publicity pertaining to
+distribution of the program without specific prior permission, and notice be
+given in supporting documentation that copying and distribution is by
+permission of Lars Fenneberg.
+
+Lars Fenneberg makes no representations about the suitability of this
+software for any purpose.  It is provided "as is" without express or implied
+warranty.
+
+------------------------------------------------------------------------------
+Copyright 1992 Livingston Enterprises, Inc.
+Livingston Enterprises, Inc. 6920 Koll Center Parkway Pleasanton, CA  94566
+
+Permission to use, copy, modify, and distribute this software for any
+purpose and without fee is hereby granted, provided that this copyright
+and permission notice appear on all copies and supporting documentation,
+the name of Livingston Enterprises, Inc. not be used in advertising or
+publicity pertaining to distribution of the program without specific
+prior permission, and notice be given in supporting documentation that
+copying and distribution is by permission of Livingston Enterprises, Inc.
+
+Livingston Enterprises, Inc. makes no representations about the suitability
+of this software for any purpose.  It is provided "as is" without express
+or implied warranty.
+------------------------------------------------------------------------------
+[C] The Regents of the University of Michigan and Merit Network, Inc. 1992,
+1993, 1994, 1995 All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted, provided
+that the above copyright notice and this permission notice appear in all
+copies of the software and derivative works or modified versions thereof,
+and that both the copyright notice and this permission and disclaimer
+notice appear in supporting documentation.
+
+THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
+EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE REGENTS OF THE
+UNIVERSITY OF MICHIGAN AND MERIT NETWORK, INC. DO NOT WARRANT THAT THE
+FUNCTIONS CONTAINED IN THE SOFTWARE WILL MEET LICENSEE'S REQUIREMENTS OR
+THAT OPERATION WILL BE UNINTERRUPTED OR ERROR FREE.  The Regents of the
+University of Michigan and Merit Network, Inc. shall not be liable for any
+special, indirect, incidental or consequential damages with respect to any
+claim by Licensee or any third party arising from use of the software.
+------------------------------------------------------------------------------
+Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991.
+All rights reserved.
+
+License to copy and use this software is granted provided that it
+is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+Algorithm" in all material mentioning or referencing this software
+or this function.
+
+License is also granted to make and use derivative works provided
+that such works are identified as "derived from the RSA Data
+Security, Inc. MD5 Message-Digest Algorithm" in all material
+mentioning or referencing the derived work.
+
+RSA Data Security, Inc. makes no representations concerning either
+the merchantability of this software or the suitability of this
+software for any particular purpose. It is provided "as is"
+without express or implied warranty of any kind.
+
+These notices must be retained in any copies of any part of this
+documentation and/or software.
+------------------------------------------------------------------------------
diff --git a/pppd/plugins/radius/radiusclient/Makefile.am b/pppd/plugins/radius/radiusclient/Makefile.am
new file mode 100644
index 0000000..06ee310
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/Makefile.am
@@ -0,0 +1,22 @@
+# 
+#  $Id: Makefile.am,v 1.1 2002/01/22 16:03:00 dfs Exp $
+# 
+#  Copyright (C) 1997 Lars Fenneberg
+# 
+#  See the file COPYRIGHT for the respective terms and conditions. 
+#  If the file is missing contact me at lf@elemental.net 
+#  and I'll send you a copy.
+# 
+#
+
+AUTOMAKE_OPTIONS = foreign
+
+INCLUDES = -D_GNU_SOURCE
+
+ACLOCAL = @ACLOCAL@
+LTLIBOBJS = @LTLIBOBJS@
+
+SUBDIRS = include lib src etc man doc patches login.radius
+EXTRA_DIST = BUGS CHANGES COPYRIGHT README README.radexample
+
+CLEANFILES = *~
diff --git a/pppd/plugins/radius/radiusclient/Makefile.in b/pppd/plugins/radius/radiusclient/Makefile.in
new file mode 100644
index 0000000..dc30ebf
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/Makefile.in
@@ -0,0 +1,331 @@
+# Makefile.in generated automatically by automake 1.3 from Makefile.am
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+# 
+#  $Id: Makefile.in,v 1.1 2002/01/22 16:03:00 dfs Exp $
+# 
+#  Copyright (C) 1997 Lars Fenneberg
+# 
+#  See the file COPYRIGHT for the respective terms and conditions. 
+#  If the file is missing contact me at lf@elemental.net 
+#  and I'll send you a copy.
+# 
+#
+
+
+SHELL = /bin/sh
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+sbindir = @sbindir@
+libexecdir = @libexecdir@
+datadir = @datadir@
+sysconfdir = @sysconfdir@
+sharedstatedir = @sharedstatedir@
+localstatedir = @localstatedir@
+libdir = @libdir@
+infodir = @infodir@
+mandir = @mandir@
+includedir = @includedir@
+oldincludedir = /usr/include
+
+DISTDIR =
+
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+
+top_builddir = .
+AUTOCONF = @AUTOCONF@
+AUTOMAKE = @AUTOMAKE@
+AUTOHEADER = @AUTOHEADER@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+transform = @program_transform_name@
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_alias = @build_alias@
+build_triplet = @build@
+host_alias = @host_alias@
+host_triplet = @host@
+target_alias = @target_alias@
+target_triplet = @target@
+AR = @AR@
+CC = @CC@
+LD = @LD@
+LIBTOOL = @LIBTOOL@
+LIBVERSION = @LIBVERSION@
+LN_S = @LN_S@
+MAKEINFO = @MAKEINFO@
+NM = @NM@
+PACKAGE = @PACKAGE@
+RANLIB = @RANLIB@
+RC_LOG_FACILITY = @RC_LOG_FACILITY@
+RC_SECURE_PATH = @RC_SECURE_PATH@
+VERSION = @VERSION@
+pkgsysconfdir = @pkgsysconfdir@
+
+AUTOMAKE_OPTIONS = foreign
+
+INCLUDES = -D_GNU_SOURCE
+
+ACLOCAL = @ACLOCAL@
+LTLIBOBJS = @LTLIBOBJS@
+
+SUBDIRS = include lib src etc man doc patches login.radius
+EXTRA_DIST = BUGS CHANGES COPYRIGHT README README.radexample
+
+CLEANFILES = *~
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = config.h
+CONFIG_CLEAN_FILES = 
+DIST_COMMON =  README Makefile.am Makefile.in acconfig.h aclocal.m4 \
+config.guess config.h.in config.sub configure configure.in install-sh \
+ltconfig ltmain.sh missing mkinstalldirs stamp-h.in
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = tar
+GZIP = --best
+all: all-recursive-am all-am
+
+.SUFFIXES:
+
+config.h: stamp-h
+	@:
+stamp-h: $(srcdir)/config.h.in $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES= CONFIG_HEADERS=config.h \
+	     $(SHELL) ./config.status
+	@echo timestamp > stamp-h
+$(srcdir)/config.h.in: $(srcdir)/stamp-h.in
+$(srcdir)/stamp-h.in: $(top_srcdir)/configure.in $(ACLOCAL_M4) acconfig.h
+	cd $(top_srcdir) && $(AUTOHEADER)
+	@echo timestamp > $(srcdir)/stamp-h.in
+
+mostlyclean-hdr:
+
+clean-hdr:
+
+distclean-hdr:
+	-rm -f config.h
+
+maintainer-clean-hdr:
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+
+@SET_MAKE@
+
+all-recursive install-data-recursive install-exec-recursive \
+installdirs-recursive install-recursive uninstall-recursive  \
+check-recursive installcheck-recursive info-recursive dvi-recursive:
+	@set fnord $(MAKEFLAGS); amf=$$2; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  target=`echo $@ | sed s/-recursive//`; \
+	  echo "Making $$target in $$subdir"; \
+	  (cd $$subdir && $(MAKE) $$target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done && test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@set fnord $(MAKEFLAGS); amf=$$2; \
+	rev=''; list='$(SUBDIRS)'; for subdir in $$list; do \
+	  rev="$$subdir $$rev"; \
+	done; \
+	for subdir in $$rev; do \
+	  target=`echo $@ | sed s/-recursive//`; \
+	  echo "Making $$target in $$subdir"; \
+	  (cd $$subdir && $(MAKE) $$target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  (cd $$subdir && $(MAKE) tags); \
+	done
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP)
+	here=`pwd` && cd $(srcdir) \
+	  && mkid -f$$here/ID $(SOURCES) $(HEADERS) $(LISP)
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test -f $$subdir/TAGS && tags="$$tags -i $$here/$$subdir/TAGS"; \
+	done; \
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)config.h.in$$unique$(LISP)$$tags" \
+	  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags config.h.in $$unique $(LISP) -o $$here/TAGS)
+
+mostlyclean-tags:
+
+clean-tags:
+
+distclean-tags:
+	-rm -f TAGS ID
+
+maintainer-clean-tags:
+
+distdir = $(PACKAGE)-$(VERSION)
+top_distdir = $(distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	-rm -rf $(distdir)
+	GZIP=$(GZIP) $(TAR) zxf $(distdir).tar.gz
+	mkdir $(distdir)/=build
+	mkdir $(distdir)/=inst
+	dc_install_base=`cd $(distdir)/=inst && pwd`; \
+	cd $(distdir)/=build \
+	  && ../configure --srcdir=.. --prefix=$$dc_install_base \
+	  && $(MAKE) \
+	  && $(MAKE) dvi \
+	  && $(MAKE) check \
+	  && $(MAKE) install \
+	  && $(MAKE) installcheck \
+	  && $(MAKE) dist
+	-rm -rf $(distdir)
+	@echo "========================"; \
+	echo "$(distdir).tar.gz is ready for distribution"; \
+	echo "========================"
+dist: distdir
+	-chmod -R a+r $(distdir)
+	GZIP=$(GZIP) $(TAR) chozf $(distdir).tar.gz $(distdir)
+	-rm -rf $(distdir)
+dist-all: distdir
+	-chmod -R a+r $(distdir)
+	GZIP=$(GZIP) $(TAR) chozf $(distdir).tar.gz $(distdir)
+	-rm -rf $(distdir)
+distdir: $(DISTFILES)
+	-rm -rf $(distdir)
+	mkdir $(distdir)
+	-chmod 777 $(distdir)
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  test -f $(distdir)/$$file \
+	  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	  || cp -p $$d/$$file $(distdir)/$$file; \
+	done
+	for subdir in $(SUBDIRS); do \
+	  test -d $(distdir)/$$subdir \
+	  || mkdir $(distdir)/$$subdir \
+	  || exit 1; \
+	  chmod 777 $(distdir)/$$subdir; \
+	  (cd $$subdir && $(MAKE) top_distdir=../$(distdir) distdir=../$(distdir)/$$subdir distdir) \
+	    || exit 1; \
+	done
+info: info-recursive
+dvi: dvi-recursive
+check: all-am
+	$(MAKE) check-recursive
+installcheck: installcheck-recursive
+all-recursive-am: config.h
+	$(MAKE) all-recursive
+
+all-am: Makefile config.h
+
+install-exec: install-exec-recursive
+	@$(NORMAL_INSTALL)
+
+install-data: install-data-recursive
+	@$(NORMAL_INSTALL)
+
+install: install-recursive
+	@:
+
+uninstall: uninstall-recursive
+
+install-strip:
+	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install
+installdirs: installdirs-recursive
+
+
+mostlyclean-generic:
+	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-rm -f Makefile $(DISTCLEANFILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+mostlyclean-am:  mostlyclean-hdr mostlyclean-tags mostlyclean-generic
+
+clean-am:  clean-hdr clean-tags clean-generic mostlyclean-am
+
+distclean-am:  distclean-hdr distclean-tags distclean-generic clean-am
+
+maintainer-clean-am:  maintainer-clean-hdr maintainer-clean-tags \
+		maintainer-clean-generic distclean-am
+
+mostlyclean:  mostlyclean-recursive mostlyclean-am
+
+clean:  clean-recursive clean-am
+
+distclean:  distclean-recursive distclean-am
+	-rm -f config.status
+	-rm -f libtool
+
+maintainer-clean:  maintainer-clean-recursive maintainer-clean-am
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+	-rm -f config.status
+
+.PHONY: mostlyclean-hdr distclean-hdr clean-hdr maintainer-clean-hdr \
+install-data-recursive uninstall-data-recursive install-exec-recursive \
+uninstall-exec-recursive installdirs-recursive uninstalldirs-recursive \
+all-recursive check-recursive installcheck-recursive info-recursive \
+dvi-recursive mostlyclean-recursive distclean-recursive clean-recursive \
+maintainer-clean-recursive tags tags-recursive mostlyclean-tags \
+distclean-tags clean-tags maintainer-clean-tags distdir info dvi \
+installcheck all-recursive-am all-am install-exec install-data install \
+uninstall all installdirs mostlyclean-generic distclean-generic \
+clean-generic maintainer-clean-generic clean mostlyclean distclean \
+maintainer-clean
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/pppd/plugins/radius/radiusclient/README b/pppd/plugins/radius/radiusclient/README
new file mode 100644
index 0000000..4f7accd
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/README
@@ -0,0 +1,17 @@
+$Id: README,v 1.1 2002/01/22 16:03:00 dfs Exp $
+
+Please view doc/instop.html with your favourite WWW browser, e.g lynx or
+netscape.
+
+Currently radiusclient will compile on the following platforms:
+
+	Compiled on:
+
+		i386-pc-bsdi2.1
+		sparc-unknown-netbsd1.2.1
+		i386-unknown-freebsd2.2.6
+	
+	Compiled and tested on:
+
+		i486-pc-linux
+		sparc-sun-solaris2.5.1
diff --git a/pppd/plugins/radius/radiusclient/README.radexample b/pppd/plugins/radius/radiusclient/README.radexample
new file mode 100644
index 0000000..ce80c4d
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/README.radexample
@@ -0,0 +1,12 @@
+$Id: README.radexample,v 1.1 2002/01/22 16:03:00 dfs Exp $
+
+In src/radexample.c is a small example on how to use the library
+lib/libradclient.a. 
+
+You only need to include radiusclient.h into your applications and link
+against the library. For this example to work your radiusclient config file
+has to be setup right.
+
+I make no guarantees that the library interface stays the same as
+radiusclient evolves, but I think that the whole thing is so simple that the
+changes to source code which uses this library should always be trivial.
diff --git a/pppd/plugins/radius/radiusclient/acconfig.h b/pppd/plugins/radius/radiusclient/acconfig.h
new file mode 100644
index 0000000..f1d8e13
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/acconfig.h
@@ -0,0 +1,36 @@
+/*
+ * $Id: acconfig.h,v 1.1 2002/01/22 16:03:00 dfs Exp $
+ *
+ * Copyright (C) 1996,1997 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+@TOP@
+
+/* does /dev/urandom exist ? */
+#undef HAVE_DEV_URANDOM
+
+/* shadow password support */
+#undef HAVE_SHADOW_PASSWORDS
+
+/* struct utsname has domainname field */
+#undef HAVE_STRUCT_UTSNAME_DOMAINNAME
+
+/* do you need the sig* prototypes ? */
+#undef NEED_SIG_PROTOTYPES
+
+/* package name */
+#undef PACKAGE
+
+/* include code to kludge aroung Livingston's RADIUS server 1.16 */
+#undef RADIUS_116
+
+/* SCP support */
+#undef SCP
+
+/* package version */
+#undef VERSION
diff --git a/pppd/plugins/radius/radiusclient/aclocal.m4 b/pppd/plugins/radius/radiusclient/aclocal.m4
new file mode 100644
index 0000000..5532ad1
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/aclocal.m4
@@ -0,0 +1,331 @@
+dnl aclocal.m4 generated automatically by aclocal 1.3
+
+dnl Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+dnl This Makefile.in is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl This program is distributed in the hope that it will be useful,
+dnl but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+dnl even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+dnl PARTICULAR PURPOSE.
+
+# Do all the work for Automake.  This macro actually does too much --
+# some checks are only needed if your package does certain things.
+# But this isn't really a big deal.
+
+# serial 1
+
+dnl Usage:
+dnl AM_INIT_AUTOMAKE(package,version, [no-define])
+
+AC_DEFUN(AM_INIT_AUTOMAKE,
+[AC_REQUIRE([AM_PROG_INSTALL])
+PACKAGE=[$1]
+AC_SUBST(PACKAGE)
+VERSION=[$2]
+AC_SUBST(VERSION)
+dnl test to see if srcdir already configured
+if test "`cd $srcdir && pwd`" != "`pwd`" && test -f $srcdir/config.status; then
+  AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
+fi
+ifelse([$3],,
+AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE")
+AC_DEFINE_UNQUOTED(VERSION, "$VERSION"))
+AC_REQUIRE([AM_SANITY_CHECK])
+AC_REQUIRE([AC_ARG_PROGRAM])
+dnl FIXME This is truly gross.
+missing_dir=`cd $ac_aux_dir && pwd`
+AM_MISSING_PROG(ACLOCAL, aclocal, $missing_dir)
+AM_MISSING_PROG(AUTOCONF, autoconf, $missing_dir)
+AM_MISSING_PROG(AUTOMAKE, automake, $missing_dir)
+AM_MISSING_PROG(AUTOHEADER, autoheader, $missing_dir)
+AM_MISSING_PROG(MAKEINFO, makeinfo, $missing_dir)
+AC_REQUIRE([AC_PROG_MAKE_SET])])
+
+
+# serial 1
+
+AC_DEFUN(AM_PROG_INSTALL,
+[AC_REQUIRE([AC_PROG_INSTALL])
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'
+AC_SUBST(INSTALL_SCRIPT)dnl
+])
+
+#
+# Check to make sure that the build environment is sane.
+#
+
+AC_DEFUN(AM_SANITY_CHECK,
+[AC_MSG_CHECKING([whether build environment is sane])
+# Just in case
+sleep 1
+echo timestamp > conftestfile
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt $srcdir/configure conftestfile 2> /dev/null`
+   if test "[$]*" = "X"; then
+      # -L didn't work.
+      set X `ls -t $srcdir/configure conftestfile`
+   fi
+   if test "[$]*" != "X $srcdir/configure conftestfile" \
+      && test "[$]*" != "X conftestfile $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+alias in your environment])
+   fi
+
+   test "[$]2" = conftestfile
+   )
+then
+   # Ok.
+   :
+else
+   AC_MSG_ERROR([newly created file is older than distributed files!
+Check your system clock])
+fi
+rm -f conftest*
+AC_MSG_RESULT(yes)])
+
+dnl AM_MISSING_PROG(NAME, PROGRAM, DIRECTORY)
+dnl The program must properly implement --version.
+AC_DEFUN(AM_MISSING_PROG,
+[AC_MSG_CHECKING(for working $2)
+# Run test in a subshell; some versions of sh will print an error if
+# an executable is not found, even if stderr is redirected.
+# Redirect stdin to placate older versions of autoconf.  Sigh.
+if ($2 --version) < /dev/null > /dev/null 2>&1; then
+   $1=$2
+   AC_MSG_RESULT(found)
+else
+   $1="$3/missing $2"
+   AC_MSG_RESULT(missing)
+fi
+AC_SUBST($1)])
+
+
+# serial 18 AM_PROG_LIBTOOL
+AC_DEFUN(AM_PROG_LIBTOOL,
+[AC_REQUIRE([AC_CANONICAL_HOST])
+AC_REQUIRE([AC_PROG_RANLIB])
+AC_REQUIRE([AC_PROG_CC])
+AC_REQUIRE([AM_PROG_LD])
+AC_REQUIRE([AM_PROG_NM])
+AC_REQUIRE([AC_PROG_LN_S])
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+AC_SUBST(LIBTOOL)
+
+dnl Allow the --disable-shared flag to stop us from building shared libs.
+AC_ARG_ENABLE(shared,
+[  --enable-shared         build shared libraries [default=yes]],
+[if test "$enableval" = no; then
+  libtool_enable_shared=no
+else
+  libtool_enable_shared=yes
+fi])
+test -n "$libtool_enable_shared" && enable_shared="$libtool_enable_shared"
+libtool_shared=
+test "$enable_shared" = no && libtool_shared=" --disable-shared"
+
+dnl Allow the --disable-static flag to stop us from building static libs.
+AC_ARG_ENABLE(static,
+[  --enable-static         build static libraries [default=yes]],
+[if test "$enableval" = no; then
+  libtool_enable_static=no
+else
+  libtool_enable_static=yes
+fi])
+test -n "$libtool_enable_static" && enable_static="$libtool_enable_static"
+libtool_static=
+test "$enable_static" = no && libtool_static=" --disable-static"
+
+libtool_flags="$libtool_shared$libtool_static"
+test "$silent" = yes && libtool_flags="$libtool_flags --silent"
+test "$ac_cv_prog_gcc" = yes && libtool_flags="$libtool_flags --with-gcc"
+test "$ac_cv_prog_gnu_ld" = yes && libtool_flags="$libtool_flags --with-gnu-ld"
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+[case "$host" in
+*-*-irix6*)
+  ac_save_CFLAGS="$CFLAGS"
+  flag_passed=no
+  for f in -32 -64 -n32 ABI -cckr -mips1 -mips2 -mips3 -mips4; do
+    case "$f" in
+    ABI)
+      test -n "$SGI_ABI" && flag_passed=yes
+      if test "$flag_passed" = no && test "$ac_cv_prog_gcc" = yes; then
+	# Choose the ABI flag according to GCC's specs.
+	if $CC -dumpspecs 2>&1 | sed '/^\*link:$/,/^$/!d' | egrep -e '[ 	]-32' >/dev/null; then
+	  LD="${LD-ld} -32"
+	else
+	  LD="${LD-ld} -n32"
+	fi
+      fi
+      ;;
+
+    *)
+      if echo " $CC $CFLAGS " | egrep -e "[ 	]$f[	 ]" > /dev/null; then
+	flag_passed=yes
+	LD="${LD-ld} $f"
+      fi
+      ;;
+    esac
+  done
+  CFLAGS="$ac_save_CFLAGS"
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  CFLAGS="$CFLAGS -belf"
+  ;;
+esac]
+
+# Actually configure libtool.  ac_aux_dir is where install-sh is found.
+CC="$CC" CFLAGS="$CFLAGS" CPPFLAGS="$CPPFLAGS" \
+LD="$LD" NM="$NM" RANLIB="$RANLIB" LN_S="$LN_S" \
+${CONFIG_SHELL-/bin/sh} $ac_aux_dir/ltconfig \
+$libtool_flags --no-verify $ac_aux_dir/ltmain.sh $host \
+|| AC_MSG_ERROR([libtool configure failed])
+])
+
+# AM_PROG_LD - find the path to the GNU or non-GNU linker
+AC_DEFUN(AM_PROG_LD,
+[AC_ARG_WITH(gnu-ld,
+[  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]],
+test "$withval" = no || with_gnu_ld=yes, with_gnu_ld=no)
+AC_REQUIRE([AC_PROG_CC])
+ac_prog=ld
+if test "$ac_cv_prog_gcc" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  AC_MSG_CHECKING([for ld used by GCC])
+  ac_prog=`($CC -print-prog-name=ld) 2>&5`
+  case "$ac_prog" in
+  # Accept absolute paths.
+  /*)
+    test -z "$LD" && LD="$ac_prog"
+    ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  AC_MSG_CHECKING([for GNU ld])
+else
+  AC_MSG_CHECKING([for non-GNU ld])
+fi
+AC_CACHE_VAL(ac_cv_path_LD,
+[if test -z "$LD"; then
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog"; then
+      ac_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some GNU ld's only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      if "$ac_cv_path_LD" -v 2>&1 < /dev/null | egrep '(GNU|with BFD)' > /dev/null; then
+	test "$with_gnu_ld" != no && break
+      else
+        test "$with_gnu_ld" != yes && break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+else
+  ac_cv_path_LD="$LD" # Let the user override the test with a path.
+fi])
+LD="$ac_cv_path_LD"
+if test -n "$LD"; then
+  AC_MSG_RESULT($LD)
+else
+  AC_MSG_RESULT(no)
+fi
+test -z "$LD" && AC_MSG_ERROR([no acceptable ld found in \$PATH])
+AC_SUBST(LD)
+AM_PROG_LD_GNU
+])
+
+AC_DEFUN(AM_PROG_LD_GNU,
+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], ac_cv_prog_gnu_ld,
+[# I'd rather use --version here, but apparently some GNU ld's only accept -v.
+if $LD -v 2>&1 </dev/null | egrep '(GNU|with BFD)' 1>&5; then
+  ac_cv_prog_gnu_ld=yes
+else
+  ac_cv_prog_gnu_ld=no
+fi])
+])
+
+# AM_PROG_NM - find the path to a BSD-compatible name lister
+AC_DEFUN(AM_PROG_NM,
+[AC_MSG_CHECKING([for BSD-compatible nm])
+AC_CACHE_VAL(ac_cv_path_NM,
+[case "$NM" in
+/*)
+  ac_cv_path_NM="$NM" # Let the user override the test with a path.
+  ;;
+*)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in /usr/ucb /usr/ccs/bin $PATH /bin; do
+    test -z "$ac_dir" && dir=.
+    if test -f $ac_dir/nm; then
+      # Check to see if the nm accepts a BSD-compat flag.
+      # Adding the `sed 1!d' prevents false positives on HP-UX, which says:
+      #   nm: unknown option "B" ignored
+      if ($ac_dir/nm -B /dev/null 2>&1 | sed '1!d'; exit 0) | egrep /dev/null >/dev/null; then
+        ac_cv_path_NM="$ac_dir/nm -B"
+      elif ($ac_dir/nm -p /dev/null 2>&1 | sed '1!d'; exit 0) | egrep /dev/null >/dev/null; then
+        ac_cv_path_NM="$ac_dir/nm -p"
+      else
+        ac_cv_path_NM="$ac_dir/nm"
+      fi
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_NM" && ac_cv_path_NM=nm
+  ;;
+esac])
+NM="$ac_cv_path_NM"
+AC_MSG_RESULT([$NM])
+AC_SUBST(NM)
+])
+
+# Like AC_CONFIG_HEADER, but automatically create stamp file.
+
+AC_DEFUN(AM_CONFIG_HEADER,
+[AC_PREREQ([2.12])
+AC_CONFIG_HEADER([$1])
+dnl When config.status generates a header, we must update the stamp-h file.
+dnl This file resides in the same directory as the config header
+dnl that is generated.  We must strip everything past the first ":",
+dnl and everything past the last "/".
+AC_OUTPUT_COMMANDS(changequote(<<,>>)dnl
+ifelse(patsubst(<<$1>>, <<[^ ]>>, <<>>), <<>>,
+<<test -z "<<$>>CONFIG_HEADERS" || echo timestamp > patsubst(<<$1>>, <<^\([^:]*/\)?.*>>, <<\1>>)stamp-h<<>>dnl>>,
+<<am_indx=1
+for am_file in <<$1>>; do
+  case " <<$>>CONFIG_HEADERS " in
+  *" <<$>>am_file "*<<)>>
+    echo timestamp > `echo <<$>>am_file | sed -e 's%:.*%%' -e 's%[^/]*$%%'`stamp-h$am_indx
+    ;;
+  esac
+  am_indx=`expr "<<$>>am_indx" + 1`
+done<<>>dnl>>)
+changequote([,]))])
+
diff --git a/pppd/plugins/radius/radiusclient/config.guess b/pppd/plugins/radius/radiusclient/config.guess
new file mode 100755
index 0000000..d0e202f
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/config.guess
@@ -0,0 +1,693 @@
+#! /bin/sh
+# Attempt to guess a canonical system name.
+#   Copyright (C) 1992, 93, 94, 95, 1996 Free Software Foundation, Inc.
+#
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Written by Per Bothner <bothner@cygnus.com>.
+# The master version of this file is at the FSF in /home/gd/gnu/lib.
+#
+# This script attempts to guess a canonical system name similar to
+# config.sub.  If it succeeds, it prints the system name on stdout, and
+# exits with 0.  Otherwise, it exits with 1.
+#
+# The plan is that this can be called by configure scripts if you
+# don't specify an explicit system type (host/target name).
+#
+# Only a few systems have been added to this list; please add others
+# (but try to keep the structure clean).
+#
+
+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+# (ghazi@noc.rutgers.edu 8/24/94.)
+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
+	PATH=$PATH:/.attbin ; export PATH
+fi
+
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+trap 'rm -f dummy.c dummy.o dummy; exit 1' 1 2 15
+
+# Note: order is significant - the case branches are not exclusive.
+
+case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+    alpha:OSF1:*:*)
+	# A Vn.n version is a released version.
+	# A Tn.n version is a released field test version.
+	# A Xn.n version is an unreleased experimental baselevel.
+	# 1.2 uses "1.2" for uname -r.
+	echo alpha-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//'`
+	exit 0 ;;
+    21064:Windows_NT:50:3)
+	echo alpha-dec-winnt3.5
+	exit 0 ;;
+    Amiga*:UNIX_System_V:4.0:*)
+	echo m68k-cbm-sysv4
+	exit 0;;
+    amiga:NetBSD:*:*)
+      echo m68k-cbm-netbsd${UNAME_RELEASE}
+      exit 0 ;;
+    amiga:OpenBSD:*:*)
+      echo m68k-cbm-openbsd${UNAME_RELEASE}
+      exit 0 ;;
+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+	echo arm-acorn-riscix${UNAME_RELEASE}
+	exit 0;;
+    Pyramid*:OSx*:*:*|MIS*:OSx*:*:*)
+	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+		echo pyramid-pyramid-sysv3
+	else
+		echo pyramid-pyramid-bsd
+	fi
+	exit 0 ;;
+    NILE:*:*:dcosx)
+	echo pyramid-pyramid-svr4
+	exit 0 ;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    i86pc:SunOS:5.*:*)
+	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sun4*:SunOS:6*:*)
+	# According to config.sub, this is the proper way to canonicalize
+	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+	# it's likely to be more like Solaris than SunOS4.
+	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sun4*:SunOS:*:*)
+	case "`/usr/bin/arch -k`" in
+	    Series*|S4*)
+		UNAME_RELEASE=`uname -v`
+		;;
+	esac
+	# Japanese Language versions have a version number like `4.1.3-JL'.
+	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
+	exit 0 ;;
+    sun3*:SunOS:*:*)
+	echo m68k-sun-sunos${UNAME_RELEASE}
+	exit 0 ;;
+    aushp:SunOS:*:*)
+	echo sparc-auspex-sunos${UNAME_RELEASE}
+	exit 0 ;;
+    atari*:NetBSD:*:*)
+	echo m68k-atari-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    atari*:OpenBSD:*:*)
+	echo m68k-atari-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sun3*:NetBSD:*:*)
+	echo m68k-sun-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sun3*:OpenBSD:*:*)
+	echo m68k-sun-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mac68k:NetBSD:*:*)
+	echo m68k-apple-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mac68k:OpenBSD:*:*)
+	echo m68k-apple-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    powerpc:machten:*:*)
+	echo powerpc-apple-machten${UNAME_RELEASE}
+	exit 0 ;;
+    RISC*:Mach:*:*)
+	echo mips-dec-mach_bsd4.3
+	exit 0 ;;
+    RISC*:ULTRIX:*:*)
+	echo mips-dec-ultrix${UNAME_RELEASE}
+	exit 0 ;;
+    VAX*:ULTRIX*:*:*)
+	echo vax-dec-ultrix${UNAME_RELEASE}
+	exit 0 ;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	sed 's/^	//' << EOF >dummy.c
+	int main (argc, argv) int argc; char **argv; {
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	${CC-cc} dummy.c -o dummy \
+	  && ./dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
+	  && rm dummy.c dummy && exit 0
+	rm -f dummy.c dummy
+	echo mips-mips-riscos${UNAME_RELEASE}
+	exit 0 ;;
+    Night_Hawk:Power_UNIX:*:*)
+	echo powerpc-harris-powerunix
+	exit 0 ;;
+    m88k:CX/UX:7*:*)
+	echo m88k-harris-cxux7
+	exit 0 ;;
+    m88k:*:4*:R4*)
+	echo m88k-motorola-sysv4
+	exit 0 ;;
+    m88k:*:3*:R3*)
+	echo m88k-motorola-sysv3
+	exit 0 ;;
+    AViiON:dgux:*:*)
+        # DG/UX returns AViiON for all architectures
+        UNAME_PROCESSOR=`/usr/bin/uname -p`
+        if [ $UNAME_PROCESSOR = mc88100 -o $UNAME_PROCESSOR = mc88110 ] ; then
+	if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx \
+	     -o ${TARGET_BINARY_INTERFACE}x = x ] ; then
+		echo m88k-dg-dgux${UNAME_RELEASE}
+	else
+		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+	fi
+        else echo i586-dg-dgux${UNAME_RELEASE}
+        fi
+ 	exit 0 ;;
+    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+	echo m88k-dolphin-sysv3
+	exit 0 ;;
+    M88*:*:R3*:*)
+	# Delta 88k system running SVR3
+	echo m88k-motorola-sysv3
+	exit 0 ;;
+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+	echo m88k-tektronix-sysv3
+	exit 0 ;;
+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+	echo m68k-tektronix-bsd
+	exit 0 ;;
+    *:IRIX*:*:*)
+	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
+	exit 0 ;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
+	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
+    i?86:AIX:*:*)
+	echo i386-ibm-aix
+	exit 0 ;;
+    *:AIX:2:3)
+	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+		sed 's/^		//' << EOF >dummy.c
+		#include <sys/systemcfg.h>
+
+		main()
+			{
+			if (!__power_pc())
+				exit(1);
+			puts("powerpc-ibm-aix3.2.5");
+			exit(0);
+			}
+EOF
+		${CC-cc} dummy.c -o dummy && ./dummy && rm dummy.c dummy && exit 0
+		rm -f dummy.c dummy
+		echo rs6000-ibm-aix3.2.5
+	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+		echo rs6000-ibm-aix3.2.4
+	else
+		echo rs6000-ibm-aix3.2
+	fi
+	exit 0 ;;
+    *:AIX:*:4)
+	if /usr/sbin/lsattr -EHl proc0 | grep POWER >/dev/null 2>&1; then
+		IBM_ARCH=rs6000
+	else
+		IBM_ARCH=powerpc
+	fi
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=4.${UNAME_RELEASE}
+	fi
+	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
+	exit 0 ;;
+    *:AIX:*:*)
+	echo rs6000-ibm-aix
+	exit 0 ;;
+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
+	echo romp-ibm-bsd4.4
+	exit 0 ;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC NetBSD and
+	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+	exit 0 ;;                           # report: romp-ibm BSD 4.3
+    *:BOSX:*:*)
+	echo rs6000-bull-bosx
+	exit 0 ;;
+    DPX/2?00:B.O.S.:*:*)
+	echo m68k-bull-sysv3
+	exit 0 ;;
+    9000/[34]??:4.3bsd:1.*:*)
+	echo m68k-hp-bsd
+	exit 0 ;;
+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+	echo m68k-hp-bsd4.4
+	exit 0 ;;
+    9000/[3478]??:HP-UX:*:*)
+	case "${UNAME_MACHINE}" in
+	    9000/31? )            HP_ARCH=m68000 ;;
+	    9000/[34]?? )         HP_ARCH=m68k ;;
+	    9000/7?? | 9000/8?[1679] ) HP_ARCH=hppa1.1 ;;
+	    9000/8?? )            HP_ARCH=hppa1.0 ;;
+	esac
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
+	exit 0 ;;
+    3050*:HI-UX:*:*)
+	sed 's/^	//' << EOF >dummy.c
+	#include <unistd.h>
+	int
+	main ()
+	{
+	  long cpu = sysconf (_SC_CPU_VERSION);
+	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
+	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
+	     results, however.  */
+	  if (CPU_IS_PA_RISC (cpu))
+	    {
+	      switch (cpu)
+		{
+		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
+		  default: puts ("hppa-hitachi-hiuxwe2"); break;
+		}
+	    }
+	  else if (CPU_IS_HP_MC68K (cpu))
+	    puts ("m68k-hitachi-hiuxwe2");
+	  else puts ("unknown-hitachi-hiuxwe2");
+	  exit (0);
+	}
+EOF
+	${CC-cc} dummy.c -o dummy && ./dummy && rm dummy.c dummy && exit 0
+	rm -f dummy.c dummy
+	echo unknown-hitachi-hiuxwe2
+	exit 0 ;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
+	echo hppa1.1-hp-bsd
+	exit 0 ;;
+    9000/8??:4.3bsd:*:*)
+	echo hppa1.0-hp-bsd
+	exit 0 ;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
+	echo hppa1.1-hp-osf
+	exit 0 ;;
+    hp8??:OSF1:*:*)
+	echo hppa1.0-hp-osf
+	exit 0 ;;
+    i?86:OSF1:*:*)
+	if [ -x /usr/sbin/sysversion ] ; then
+	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	else
+	    echo ${UNAME_MACHINE}-unknown-osf1
+	fi
+	exit 0 ;;
+    parisc*:Lites*:*:*)
+	echo hppa1.1-hp-lites
+	exit 0 ;;
+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+	echo c1-convex-bsd
+        exit 0 ;;
+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+        exit 0 ;;
+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+	echo c34-convex-bsd
+        exit 0 ;;
+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+	echo c38-convex-bsd
+        exit 0 ;;
+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+	echo c4-convex-bsd
+        exit 0 ;;
+    CRAY*X-MP:*:*:*)
+	echo xmp-cray-unicos
+        exit 0 ;;
+    CRAY*Y-MP:*:*:*)
+	echo ymp-cray-unicos${UNAME_RELEASE}
+	exit 0 ;;
+    CRAY*[A-Z]90:*:*:*)
+	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/
+	exit 0 ;;
+    CRAY*TS:*:*:*)
+	echo t90-cray-unicos${UNAME_RELEASE}
+	exit 0 ;;
+    CRAY-2:*:*:*)
+	echo cray2-cray-unicos
+        exit 0 ;;
+    F300:UNIX_System_V:*:*)
+        FUJITSU_SYS=`uname -p | tr [A-Z] [a-z] | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+        echo "f300-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+        exit 0 ;;
+    F301:UNIX_System_V:*:*)
+       echo f301-fujitsu-uxpv`echo $UNAME_RELEASE | sed 's/ .*//'`
+       exit 0 ;;
+    hp3[0-9][05]:NetBSD:*:*)
+	echo m68k-hp-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    hp3[0-9][05]:OpenBSD:*:*)
+	echo m68k-hp-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    i?86:BSD/386:*:* | *:BSD/OS:*:*)
+	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+	exit 0 ;;
+    *:FreeBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit 0 ;;
+    *:NetBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
+    *:OpenBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
+    i*:CYGWIN*:*)
+	echo i386-pc-cygwin32
+	exit 0 ;;
+    p*:CYGWIN*:*)
+	echo powerpcle-unknown-cygwin32
+	exit 0 ;;
+    prep*:SunOS:5.*:*)
+	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    *:GNU:*:*)
+	echo `echo ${UNAME_MACHINE}|sed -e 's,/.*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	exit 0 ;;
+    *:Linux:*:*)
+	# The BFD linker knows what the default object file format is, so
+	# first see if it will tell us.
+	ld_help_string=`ld --help 2>&1`
+	if echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: elf_i.86"; then
+	  echo "${UNAME_MACHINE}-pc-linux" ; exit 0
+	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: i.86linux"; then
+	  echo "${UNAME_MACHINE}-pc-linux-aout" ; exit 0
+	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: i.86coff"; then
+	  echo "${UNAME_MACHINE}-pc-linux-coff" ; exit 0
+	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: m68kelf"; then
+	  echo "${UNAME_MACHINE}-unknown-linux" ; exit 0
+	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: m68klinux"; then
+	  echo "${UNAME_MACHINE}-unknown-linux-aout" ; exit 0
+	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: elf32ppc"; then
+	  echo "powerpc-unknown-linux" ; exit 0
+	elif test "${UNAME_MACHINE}" = "alpha" ; then
+	  echo alpha-unknown-linux ; exit 0
+	elif test "${UNAME_MACHINE}" = "sparc" ; then
+	  echo sparc-unknown-linux ; exit 0
+	else
+	  # Either a pre-BFD a.out linker (linux-oldld) or one that does not give us
+	  # useful --help.  Gcc wants to distinguish between linux-oldld and linux-aout.
+	  test ! -d /usr/lib/ldscripts/. \
+	    && echo "${UNAME_MACHINE}-pc-linux-oldld" && exit 0
+	  # Determine whether the default compiler is a.out or elf
+	  cat >dummy.c <<EOF
+main(argc, argv)
+int argc;
+char *argv[];
+{
+#ifdef __ELF__
+  printf ("%s-pc-linux\n", argv[1]);
+#else
+  printf ("%s-pc-linux-aout\n", argv[1]);
+#endif
+  return 0;
+}
+EOF
+	  ${CC-cc} dummy.c -o dummy 2>/dev/null && ./dummy "${UNAME_MACHINE}" && rm dummy.c dummy && exit 0
+	  rm -f dummy.c dummy
+	fi ;;
+# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.  earlier versions
+# are messed up and put the nodename in both sysname and nodename.
+    i?86:DYNIX/ptx:4*:*)
+	echo i386-sequent-sysv4
+	exit 0 ;;
+    i?86:*:4.*:* | i?86:SYSTEM_V:4.*:*)
+	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_RELEASE}
+	else
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_RELEASE}
+	fi
+	exit 0 ;;
+    i?86:*:3.2:*)
+	if test -f /usr/options/cb.name; then
+		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+		UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|egrep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) \
+			&& UNAME_MACHINE=i586
+		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+	else
+		echo ${UNAME_MACHINE}-pc-sysv32
+	fi
+	exit 0 ;;
+    Intel:Mach:3*:*)
+	echo i386-pc-mach3
+	exit 0 ;;
+    paragon:*:*:*)
+	echo i860-intel-osf1
+	exit 0 ;;
+    i860:*:4.*:*) # i860-SVR4
+	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+	else # Add other i860-SVR4 vendors below as they are discovered.
+	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+	fi
+	exit 0 ;;
+    mini*:CTIX:SYS*5:*)
+	# "miniframe"
+	echo m68010-convergent-sysv
+	exit 0 ;;
+    M68*:*:R3V[567]*:*)
+	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
+    3[34]??:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 4850:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+          && echo i486-ncr-sysv4 && exit 0 ;;
+    m68*:LynxOS:2.*:*)
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    mc68030:UNIX_System_V:4.*:*)
+	echo m68k-atari-sysv4
+	exit 0 ;;
+    i?86:LynxOS:2.*:*)
+	echo i386-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    TSUNAMI:LynxOS:2.*:*)
+	echo sparc-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    rs6000:LynxOS:2.*:* | PowerPC:LynxOS:2.*:*)
+	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    SM[BE]S:UNIX_SV:*:*)
+	echo mips-dde-sysv${UNAME_RELEASE}
+	exit 0 ;;
+    RM*:SINIX-*:*:*)
+	echo mips-sni-sysv4
+	exit 0 ;;
+    *:SINIX-*:*:*)
+	if uname -p 2>/dev/null >/dev/null ; then
+		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		echo ${UNAME_MACHINE}-sni-sysv4
+	else
+		echo ns32k-sni-sysv
+	fi
+	exit 0 ;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes@openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	echo hppa1.1-stratus-sysv4
+	exit 0 ;;
+    *:*:*:FTX*)
+	# From seanf@swdc.stratus.com.
+	echo i860-stratus-sysv4
+	exit 0 ;;
+    mc68*:A/UX:*:*)
+	echo m68k-apple-aux${UNAME_RELEASE}
+	exit 0 ;;
+    R3000:*System_V*:*:* | R4000:UNIX_SYSV:*:*)
+	if [ -d /usr/nec ]; then
+	        echo mips-nec-sysv${UNAME_RELEASE}
+	else
+	        echo mips-unknown-sysv${UNAME_RELEASE}
+	fi
+        exit 0 ;;
+    PENTIUM:CPunix:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+                           # says <Richard.M.Bartel@ccMail.Census.GOV>
+        echo i586-unisys-sysv4
+        exit 0 ;;
+esac
+
+#echo '(No uname command or uname output not recognized.)' 1>&2
+#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
+
+cat >dummy.c <<EOF
+#ifdef _SEQUENT_
+# include <sys/types.h>
+# include <sys/utsname.h>
+#endif
+main ()
+{
+#if defined (sony)
+#if defined (MIPSEB)
+  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
+     I don't know....  */
+  printf ("mips-sony-bsd\n"); exit (0);
+#else
+#include <sys/param.h>
+  printf ("m68k-sony-newsos%s\n",
+#ifdef NEWSOS4
+          "4"
+#else
+	  ""
+#endif
+         ); exit (0);
+#endif
+#endif
+
+#if defined (__arm) && defined (__acorn) && defined (__unix)
+  printf ("arm-acorn-riscix"); exit (0);
+#endif
+
+#if defined (hp300) && !defined (hpux)
+  printf ("m68k-hp-bsd\n"); exit (0);
+#endif
+
+#if defined (NeXT)
+#if !defined (__ARCHITECTURE__)
+#define __ARCHITECTURE__ "m68k"
+#endif
+  int version;
+  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
+  printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
+  exit (0);
+#endif
+
+#if defined (MULTIMAX) || defined (n16)
+#if defined (UMAXV)
+  printf ("ns32k-encore-sysv\n"); exit (0);
+#else
+#if defined (CMU)
+  printf ("ns32k-encore-mach\n"); exit (0);
+#else
+  printf ("ns32k-encore-bsd\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (__386BSD__)
+  printf ("i386-pc-bsd\n"); exit (0);
+#endif
+
+#if defined (sequent)
+#if defined (i386)
+  printf ("i386-sequent-dynix\n"); exit (0);
+#endif
+#if defined (ns32000)
+  printf ("ns32k-sequent-dynix\n"); exit (0);
+#endif
+#endif
+
+#if defined (_SEQUENT_)
+    struct utsname un;
+
+    uname(&un);
+
+    if (strncmp(un.version, "V2", 2) == 0) {
+	printf ("i386-sequent-ptx2\n"); exit (0);
+    }
+    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+	printf ("i386-sequent-ptx1\n"); exit (0);
+    }
+    printf ("i386-sequent-ptx\n"); exit (0);
+
+#endif
+
+#if defined (vax)
+#if !defined (ultrix)
+  printf ("vax-dec-bsd\n"); exit (0);
+#else
+  printf ("vax-dec-ultrix\n"); exit (0);
+#endif
+#endif
+
+#if defined (alliant) && defined (i860)
+  printf ("i860-alliant-bsd\n"); exit (0);
+#endif
+
+  exit (1);
+}
+EOF
+
+${CC-cc} dummy.c -o dummy 2>/dev/null && ./dummy && rm dummy.c dummy && exit 0
+rm -f dummy.c dummy
+
+# Apollos put the system type in the environment.
+
+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
+
+# Convex versions that predate uname can use getsysinfo(1)
+
+if [ -x /usr/convex/getsysinfo ]
+then
+    case `getsysinfo -f cpu_type` in
+    c1*)
+	echo c1-convex-bsd
+	exit 0 ;;
+    c2*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+	exit 0 ;;
+    c34*)
+	echo c34-convex-bsd
+	exit 0 ;;
+    c38*)
+	echo c38-convex-bsd
+	exit 0 ;;
+    c4*)
+	echo c4-convex-bsd
+	exit 0 ;;
+    esac
+fi
+
+#echo '(Unable to guess system type)' 1>&2
+
+exit 1
diff --git a/pppd/plugins/radius/radiusclient/config.h.in b/pppd/plugins/radius/radiusclient/config.h.in
new file mode 100644
index 0000000..5bbb137
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/config.h.in
@@ -0,0 +1,161 @@
+/* config.h.in.  Generated automatically from configure.in by autoheader.  */
+/*
+ * $Id: config.h.in,v 1.1 2002/01/22 16:03:00 dfs Exp $
+ *
+ * Copyright (C) 1996,1997 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+
+/* Define to empty if the keyword does not work.  */
+#undef const
+
+/* Define if you have the strftime function.  */
+#undef HAVE_STRFTIME
+
+/* Define to `long' if <sys/types.h> doesn't define.  */
+#undef off_t
+
+/* Define as the return type of signal handlers (int or void).  */
+#undef RETSIGTYPE
+
+/* Define if the setvbuf function takes the buffering type as its second
+   argument and the buffer pointer as the third, as on System V
+   before release 3.  */
+#undef SETVBUF_REVERSED
+
+/* Define to `unsigned' if <sys/types.h> doesn't define.  */
+#undef size_t
+
+/* Define if you have the ANSI C header files.  */
+#undef STDC_HEADERS
+
+/* Define if you can safely include both <sys/time.h> and <time.h>.  */
+#undef TIME_WITH_SYS_TIME
+
+/* Define if your <sys/time.h> declares struct tm.  */
+#undef TM_IN_SYS_TIME
+
+/* does /dev/urandom exist ? */
+#undef HAVE_DEV_URANDOM
+
+/* shadow password support */
+#undef HAVE_SHADOW_PASSWORDS
+
+/* struct utsname has domainname field */
+#undef HAVE_STRUCT_UTSNAME_DOMAINNAME
+
+/* package name */
+#undef PACKAGE
+
+/* include code to kludge aroung Livingston's RADIUS server 1.16 */
+#undef RADIUS_116
+
+/* SCP support */
+#undef SCP
+
+/* package version */
+#undef VERSION
+
+/* Define if you have the fcntl function.  */
+#undef HAVE_FCNTL
+
+/* Define if you have the flock function.  */
+#undef HAVE_FLOCK
+
+/* Define if you have the getdomainname function.  */
+#undef HAVE_GETDOMAINNAME
+
+/* Define if you have the gethostname function.  */
+#undef HAVE_GETHOSTNAME
+
+/* Define if you have the rand function.  */
+#undef HAVE_RAND
+
+/* Define if you have the random function.  */
+#undef HAVE_RANDOM
+
+/* Define if you have the snprintf function.  */
+#undef HAVE_SNPRINTF
+
+/* Define if you have the strcasecmp function.  */
+#undef HAVE_STRCASECMP
+
+/* Define if you have the strdup function.  */
+#undef HAVE_STRDUP
+
+/* Define if you have the strerror function.  */
+#undef HAVE_STRERROR
+
+/* Define if you have the stricmp function.  */
+#undef HAVE_STRICMP
+
+/* Define if you have the sysinfo function.  */
+#undef HAVE_SYSINFO
+
+/* Define if you have the uname function.  */
+#undef HAVE_UNAME
+
+/* Define if you have the vsnprintf function.  */
+#undef HAVE_VSNPRINTF
+
+/* Define if you have the <crypt.h> header file.  */
+#undef HAVE_CRYPT_H
+
+/* Define if you have the <dirent.h> header file.  */
+#undef HAVE_DIRENT_H
+
+/* Define if you have the <fcntl.h> header file.  */
+#undef HAVE_FCNTL_H
+
+/* Define if you have the <getopt.h> header file.  */
+#undef HAVE_GETOPT_H
+
+/* Define if you have the <ndir.h> header file.  */
+#undef HAVE_NDIR_H
+
+/* Define if you have the <signal.h> header file.  */
+#undef HAVE_SIGNAL_H
+
+/* Define if you have the <sys/dir.h> header file.  */
+#undef HAVE_SYS_DIR_H
+
+/* Define if you have the <sys/fcntl.h> header file.  */
+#undef HAVE_SYS_FCNTL_H
+
+/* Define if you have the <sys/file.h> header file.  */
+#undef HAVE_SYS_FILE_H
+
+/* Define if you have the <sys/ioctl.h> header file.  */
+#undef HAVE_SYS_IOCTL_H
+
+/* Define if you have the <sys/ndir.h> header file.  */
+#undef HAVE_SYS_NDIR_H
+
+/* Define if you have the <sys/signal.h> header file.  */
+#undef HAVE_SYS_SIGNAL_H
+
+/* Define if you have the <sys/stat.h> header file.  */
+#undef HAVE_SYS_STAT_H
+
+/* Define if you have the <sys/utsname.h> header file.  */
+#undef HAVE_SYS_UTSNAME_H
+
+/* Define if you have the <termios.h> header file.  */
+#undef HAVE_TERMIOS_H
+
+/* Define if you have the <unistd.h> header file.  */
+#undef HAVE_UNISTD_H
+
+/* Define if you have the crypt library (-lcrypt).  */
+#undef HAVE_LIBCRYPT
+
+/* Define if you have the nsl library (-lnsl).  */
+#undef HAVE_LIBNSL
+
+/* Define if you have the socket library (-lsocket).  */
+#undef HAVE_LIBSOCKET
diff --git a/pppd/plugins/radius/radiusclient/config.sub b/pppd/plugins/radius/radiusclient/config.sub
new file mode 100755
index 0000000..08cbd46
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/config.sub
@@ -0,0 +1,921 @@
+#! /bin/sh
+# Configuration validation subroutine script, version 1.1.
+#   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
+# This file is (in principle) common to ALL GNU software.
+# The presence of a machine in this file suggests that SOME GNU software
+# can handle that machine.  It does not imply ALL GNU software can.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330,
+# Boston, MA 02111-1307, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Configuration subroutine to validate and canonicalize a configuration type.
+# Supply the specified configuration type as an argument.
+# If it is invalid, we print an error message on stderr and exit with code 1.
+# Otherwise, we print the canonical config type on stdout and succeed.
+
+# This file is supposed to be the same for all GNU packages
+# and recognize all the CPU types, system types and aliases
+# that are meaningful with *any* GNU software.
+# Each package is responsible for reporting which valid configurations
+# it does not support.  The user should be able to distinguish
+# a failure to support a valid configuration from a meaningless
+# configuration.
+
+# The goal of this file is to map all the various variations of a given
+# machine specification into a single specification in the form:
+#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# It is wrong to echo any other type of specification.
+
+if [ x$1 = x ]
+then
+	echo Configuration name missing. 1>&2
+	echo "Usage: $0 CPU-MFR-OPSYS" 1>&2
+	echo "or     $0 ALIAS" 1>&2
+	echo where ALIAS is a recognized configuration type. 1>&2
+	exit 1
+fi
+
+# First pass through any local machine types.
+case $1 in
+	*local*)
+		echo $1
+		exit 0
+		;;
+	*)
+	;;
+esac
+
+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
+# Here we must recognize all the valid KERNEL-OS combinations.
+maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+case $maybe_os in
+  linux*)
+    os=-$maybe_os
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    ;;
+  *)
+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
+    if [ $basic_machine != $1 ]
+    then os=`echo $1 | sed 's/.*-/-/'`
+    else os=; fi
+    ;;
+esac
+
+### Let's recognize common machines as not being operating systems so
+### that things like config.sub decstation-3100 work.  We also
+### recognize some manufacturers as not being operating systems, so we
+### can provide default operating systems below.
+case $os in
+	-sun*os*)
+		# Prevent following clause from handling this invalid input.
+		;;
+	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
+	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
+	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
+	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
+	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
+	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
+	-apple)
+		os=
+		basic_machine=$1
+		;;
+	-hiux*)
+		os=-hiuxwe2
+		;;
+	-sco5)
+		os=sco3.2v5
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco4)
+		os=-sco3.2v4
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2.[4-9]*)
+		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2v[4-9]*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco*)
+		os=-sco3.2v2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-isc)
+		os=-isc2.2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-clix*)
+		basic_machine=clipper-intergraph
+		;;
+	-isc*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-lynx*)
+		os=-lynxos
+		;;
+	-ptx*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
+		;;
+	-windowsnt*)
+		os=`echo $os | sed -e 's/windowsnt/winnt/'`
+		;;
+	-psos*)
+		os=-psos
+		;;
+esac
+
+# Decode aliases for certain CPU-COMPANY combinations.
+case $basic_machine in
+	# Recognize the basic CPU types without company name.
+	# Some are omitted here because they have special meanings below.
+	tahoe | i860 | m68k | m68000 | m88k | ns32k | arm \
+		| arme[lb] | pyramid \
+		| tron | a29k | 580 | i960 | h8300 | hppa | hppa1.0 | hppa1.1 \
+		| alpha | we32k | ns16k | clipper | i370 | sh \
+		| powerpc | powerpcle | 1750a | dsp16xx | mips64 | mipsel \
+		| pdp11 | mips64el | mips64orion | mips64orionel \
+		| sparc | sparclet | sparclite | sparc64)
+		basic_machine=$basic_machine-unknown
+		;;
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i[3456]86)
+	  basic_machine=$basic_machine-pc
+	  ;;
+	# Object if more than one company name word.
+	*-*-*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+	# Recognize the basic CPU types with company name.
+	vax-* | tahoe-* | i[3456]86-* | i860-* | m68k-* | m68000-* | m88k-* \
+	      | sparc-* | ns32k-* | fx80-* | arm-* | c[123]* \
+	      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* | power-* \
+	      | none-* | 580-* | cray2-* | h8300-* | i960-* | xmp-* | ymp-* \
+	      | hppa-* | hppa1.0-* | hppa1.1-* | alpha-* | we32k-* | cydra-* | ns16k-* \
+	      | pn-* | np1-* | xps100-* | clipper-* | orion-* | sparclite-* \
+	      | pdp11-* | sh-* | powerpc-* | powerpcle-* | sparc64-* | mips64-* | mipsel-* \
+	      | mips64el-* | mips64orion-* | mips64orionel-* | f301-*)
+		;;
+	# Recognize the various machine names and aliases which stand
+	# for a CPU type and a company and sometimes even an OS.
+	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
+		basic_machine=m68000-att
+		;;
+	3b*)
+		basic_machine=we32k-att
+		;;
+	alliant | fx80)
+		basic_machine=fx80-alliant
+		;;
+	altos | altos3068)
+		basic_machine=m68k-altos
+		;;
+	am29k)
+		basic_machine=a29k-none
+		os=-bsd
+		;;
+	amdahl)
+		basic_machine=580-amdahl
+		os=-sysv
+		;;
+	amiga | amiga-*)
+		basic_machine=m68k-cbm
+		;;
+	amigados)
+		basic_machine=m68k-cbm
+		os=-amigados
+		;;
+	amigaunix | amix)
+		basic_machine=m68k-cbm
+		os=-sysv4
+		;;
+	apollo68)
+		basic_machine=m68k-apollo
+		os=-sysv
+		;;
+	aux)
+		basic_machine=m68k-apple
+		os=-aux
+		;;
+	balance)
+		basic_machine=ns32k-sequent
+		os=-dynix
+		;;
+	convex-c1)
+		basic_machine=c1-convex
+		os=-bsd
+		;;
+	convex-c2)
+		basic_machine=c2-convex
+		os=-bsd
+		;;
+	convex-c32)
+		basic_machine=c32-convex
+		os=-bsd
+		;;
+	convex-c34)
+		basic_machine=c34-convex
+		os=-bsd
+		;;
+	convex-c38)
+		basic_machine=c38-convex
+		os=-bsd
+		;;
+	cray | ymp)
+		basic_machine=ymp-cray
+		os=-unicos
+		;;
+	cray2)
+		basic_machine=cray2-cray
+		os=-unicos
+		;;
+	[ctj]90-cray)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
+	crds | unos)
+		basic_machine=m68k-crds
+		;;
+	da30 | da30-*)
+		basic_machine=m68k-da30
+		;;
+	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
+		basic_machine=mips-dec
+		;;
+	delta | 3300 | motorola-3300 | motorola-delta \
+	      | 3300-motorola | delta-motorola)
+		basic_machine=m68k-motorola
+		;;
+	delta88)
+		basic_machine=m88k-motorola
+		os=-sysv3
+		;;
+	dpx20 | dpx20-*)
+		basic_machine=rs6000-bull
+		os=-bosx
+		;;
+	dpx2* | dpx2*-bull)
+		basic_machine=m68k-bull
+		os=-sysv3
+		;;
+	ebmon29k)
+		basic_machine=a29k-amd
+		os=-ebmon
+		;;
+	elxsi)
+		basic_machine=elxsi-elxsi
+		os=-bsd
+		;;
+	encore | umax | mmax)
+		basic_machine=ns32k-encore
+		;;
+	fx2800)
+		basic_machine=i860-alliant
+		;;
+	genix)
+		basic_machine=ns32k-ns
+		;;
+	gmicro)
+		basic_machine=tron-gmicro
+		os=-sysv
+		;;
+	h3050r* | hiux*)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	h8300hms)
+		basic_machine=h8300-hitachi
+		os=-hms
+		;;
+	harris)
+		basic_machine=m88k-harris
+		os=-sysv3
+		;;
+	hp300-*)
+		basic_machine=m68k-hp
+		;;
+	hp300bsd)
+		basic_machine=m68k-hp
+		os=-bsd
+		;;
+	hp300hpux)
+		basic_machine=m68k-hp
+		os=-hpux
+		;;
+	hp9k2[0-9][0-9] | hp9k31[0-9])
+		basic_machine=m68000-hp
+		;;
+	hp9k3[2-9][0-9])
+		basic_machine=m68k-hp
+		;;
+	hp9k7[0-9][0-9] | hp7[0-9][0-9] | hp9k8[0-9]7 | hp8[0-9]7)
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][0-9] | hp8[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hppa-next)
+		os=-nextstep3
+		;;
+	i370-ibm* | ibm*)
+		basic_machine=i370-ibm
+		os=-mvs
+		;;
+# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
+	i[3456]86v32)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv32
+		;;
+	i[3456]86v4*)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv4
+		;;
+	i[3456]86v)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv
+		;;
+	i[3456]86sol2)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-solaris2
+		;;
+	iris | iris4d)
+		basic_machine=mips-sgi
+		case $os in
+		    -irix*)
+			;;
+		    *)
+			os=-irix4
+			;;
+		esac
+		;;
+	isi68 | isi)
+		basic_machine=m68k-isi
+		os=-sysv
+		;;
+	m88k-omron*)
+		basic_machine=m88k-omron
+		;;
+	magnum | m3230)
+		basic_machine=mips-mips
+		os=-sysv
+		;;
+	merlin)
+		basic_machine=ns32k-utek
+		os=-sysv
+		;;
+	miniframe)
+		basic_machine=m68000-convergent
+		;;
+	mips3*-*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
+		;;
+	mips3*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
+		;;
+	ncr3000)
+		basic_machine=i486-ncr
+		os=-sysv4
+		;;
+	news | news700 | news800 | news900)
+		basic_machine=m68k-sony
+		os=-newsos
+		;;
+	news1000)
+		basic_machine=m68030-sony
+		os=-newsos
+		;;
+	news-3600 | risc-news)
+		basic_machine=mips-sony
+		os=-newsos
+		;;
+	next | m*-next )
+		basic_machine=m68k-next
+		case $os in
+		    -nextstep* )
+			;;
+		    -ns2*)
+		      os=-nextstep2
+			;;
+		    *)
+		      os=-nextstep3
+			;;
+		esac
+		;;
+	nh3000)
+		basic_machine=m68k-harris
+		os=-cxux
+		;;
+	nh[45]000)
+		basic_machine=m88k-harris
+		os=-cxux
+		;;
+	nindy960)
+		basic_machine=i960-intel
+		os=-nindy
+		;;
+	np1)
+		basic_machine=np1-gould
+		;;
+	pa-hitachi)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	paragon)
+		basic_machine=i860-intel
+		os=-osf
+		;;
+	pbd)
+		basic_machine=sparc-tti
+		;;
+	pbb)
+		basic_machine=m68k-tti
+		;;
+        pc532 | pc532-*)
+		basic_machine=ns32k-pc532
+		;;
+	pentium | p5)
+		basic_machine=i586-intel
+		;;
+	pentiumpro | p6)
+		basic_machine=i686-intel
+		;;
+	pentium-* | p5-*)
+		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumpro-* | p6-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	k5)
+		# We don't have specific support for AMD's K5 yet, so just call it a Pentium
+		basic_machine=i586-amd
+		;;
+	nexen)
+		# We don't have specific support for Nexgen yet, so just call it a Pentium
+		basic_machine=i586-nexgen
+		;;
+	pn)
+		basic_machine=pn-gould
+		;;
+	power)	basic_machine=rs6000-ibm
+		;;
+	ppc)	basic_machine=powerpc-unknown
+	        ;;
+	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppcle | powerpclittle | ppc-le | powerpc-little)
+		basic_machine=powerpcle-unknown
+	        ;;
+	ppcle-* | powerpclittle-*)
+		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ps2)
+		basic_machine=i386-ibm
+		;;
+	rm[46]00)
+		basic_machine=mips-siemens
+		;;
+	rtpc | rtpc-*)
+		basic_machine=romp-ibm
+		;;
+	sequent)
+		basic_machine=i386-sequent
+		;;
+	sh)
+		basic_machine=sh-hitachi
+		os=-hms
+		;;
+	sps7)
+		basic_machine=m68k-bull
+		os=-sysv2
+		;;
+	spur)
+		basic_machine=spur-unknown
+		;;
+	sun2)
+		basic_machine=m68000-sun
+		;;
+	sun2os3)
+		basic_machine=m68000-sun
+		os=-sunos3
+		;;
+	sun2os4)
+		basic_machine=m68000-sun
+		os=-sunos4
+		;;
+	sun3os3)
+		basic_machine=m68k-sun
+		os=-sunos3
+		;;
+	sun3os4)
+		basic_machine=m68k-sun
+		os=-sunos4
+		;;
+	sun4os3)
+		basic_machine=sparc-sun
+		os=-sunos3
+		;;
+	sun4os4)
+		basic_machine=sparc-sun
+		os=-sunos4
+		;;
+	sun4sol2)
+		basic_machine=sparc-sun
+		os=-solaris2
+		;;
+	sun3 | sun3-*)
+		basic_machine=m68k-sun
+		;;
+	sun4)
+		basic_machine=sparc-sun
+		;;
+	sun386 | sun386i | roadrunner)
+		basic_machine=i386-sun
+		;;
+	symmetry)
+		basic_machine=i386-sequent
+		os=-dynix
+		;;
+	tower | tower-32)
+		basic_machine=m68k-ncr
+		;;
+	udi29k)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	ultra3)
+		basic_machine=a29k-nyu
+		os=-sym1
+		;;
+	vaxv)
+		basic_machine=vax-dec
+		os=-sysv
+		;;
+	vms)
+		basic_machine=vax-dec
+		os=-vms
+		;;
+       vpp*|vx|vx-*)
+               basic_machine=f301-fujitsu
+               ;;
+	vxworks960)
+		basic_machine=i960-wrs
+		os=-vxworks
+		;;
+	vxworks68)
+		basic_machine=m68k-wrs
+		os=-vxworks
+		;;
+	vxworks29k)
+		basic_machine=a29k-wrs
+		os=-vxworks
+		;;
+	xmp)
+		basic_machine=xmp-cray
+		os=-unicos
+		;;
+        xps | xps100)
+		basic_machine=xps100-honeywell
+		;;
+	none)
+		basic_machine=none-none
+		os=-none
+		;;
+
+# Here we handle the default manufacturer of certain CPU types.  It is in
+# some cases the only manufacturer, in others, it is the most popular.
+	mips)
+		basic_machine=mips-mips
+		;;
+	romp)
+		basic_machine=romp-ibm
+		;;
+	rs6000)
+		basic_machine=rs6000-ibm
+		;;
+	vax)
+		basic_machine=vax-dec
+		;;
+	pdp11)
+		basic_machine=pdp11-dec
+		;;
+	we32k)
+		basic_machine=we32k-att
+		;;
+	sparc)
+		basic_machine=sparc-sun
+		;;
+        cydra)
+		basic_machine=cydra-cydrome
+		;;
+	orion)
+		basic_machine=orion-highlevel
+		;;
+	orion105)
+		basic_machine=clipper-highlevel
+		;;
+	*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+esac
+
+# Here we canonicalize certain aliases for manufacturers.
+case $basic_machine in
+	*-digital*)
+		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
+		;;
+	*-commodore*)
+		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
+		;;
+	*)
+		;;
+esac
+
+# Decode manufacturer-specific aliases for certain operating systems.
+
+if [ x"$os" != x"" ]
+then
+case $os in
+        # First match some system type aliases
+        # that might get confused with valid system types.
+	# -solaris* is a basic system type, with this one exception.
+	-solaris1 | -solaris1.*)
+		os=`echo $os | sed -e 's|solaris1|sunos4|'`
+		;;
+	-solaris)
+		os=-solaris2
+		;;
+	-unixware* | svr4*)
+		os=-sysv4
+		;;
+	# First accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST END IN A *, to match a version number.
+	# -sysv* is not here because it comes later, after sysvr4.
+	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
+	      | -amigados* | -msdos* | -newsos* | -unicos* | -aof* | -aos* \
+	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
+	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* \
+	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
+	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
+	      | -cygwin32* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -linux* | -uxpv*)
+	# Remember, each alternative MUST END IN *, to match a version number.
+		;;
+	-sunos5*)
+		os=`echo $os | sed -e 's|sunos5|solaris2|'`
+		;;
+	-sunos6*)
+		os=`echo $os | sed -e 's|sunos6|solaris3|'`
+		;;
+	-osfrose*)
+		os=-osfrose
+		;;
+	-osf*)
+		os=-osf
+		;;
+	-utek*)
+		os=-bsd
+		;;
+	-dynix*)
+		os=-bsd
+		;;
+	-acis*)
+		os=-aos
+		;;
+	-ctix* | -uts*)
+		os=-sysv
+		;;
+	-ns2 )
+	        os=-nextstep2
+		;;
+	# Preserve the version number of sinix5.
+	-sinix5.*)
+		os=`echo $os | sed -e 's|sinix|sysv|'`
+		;;
+	-sinix*)
+		os=-sysv4
+		;;
+	-triton*)
+		os=-sysv3
+		;;
+	-oss*)
+		os=-sysv3
+		;;
+	-svr4)
+		os=-sysv4
+		;;
+	-svr3)
+		os=-sysv3
+		;;
+	-sysvr4)
+		os=-sysv4
+		;;
+	# This must come after -sysvr4.
+	-sysv*)
+		;;
+	-xenix)
+		os=-xenix
+		;;
+	-none)
+		;;
+	*)
+		# Get rid of the `-' at the beginning of $os.
+		os=`echo $os | sed 's/[^-]*-//'`
+		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
+		exit 1
+		;;
+esac
+else
+
+# Here we handle the default operating systems that come with various machines.
+# The value should be what the vendor currently ships out the door with their
+# machine or put another way, the most popular os provided with the machine.
+
+# Note that if you're going to try to match "-MANUFACTURER" here (say,
+# "-sun"), then you have to tell the case statement up towards the top
+# that MANUFACTURER isn't an operating system.  Otherwise, code above
+# will signal an error saying that MANUFACTURER isn't an operating
+# system, and we'll never get to this point.
+
+case $basic_machine in
+	*-acorn)
+		os=-riscix1.2
+		;;
+	arm*-semi)
+		os=-aout
+		;;
+        pdp11-*)
+		os=-none
+		;;
+	*-dec | vax-*)
+		os=-ultrix4.2
+		;;
+	m68*-apollo)
+		os=-domain
+		;;
+	i386-sun)
+		os=-sunos4.0.2
+		;;
+	m68000-sun)
+		os=-sunos3
+		# This also exists in the configure program, but was not the
+		# default.
+		# os=-sunos4
+		;;
+	*-tti)	# must be before sparc entry or we get the wrong os.
+		os=-sysv3
+		;;
+	sparc-* | *-sun)
+		os=-sunos4.1.1
+		;;
+	*-ibm)
+		os=-aix
+		;;
+	*-hp)
+		os=-hpux
+		;;
+	*-hitachi)
+		os=-hiux
+		;;
+	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
+		os=-sysv
+		;;
+	*-cbm)
+		os=-amigados
+		;;
+	*-dg)
+		os=-dgux
+		;;
+	*-dolphin)
+		os=-sysv3
+		;;
+	m68k-ccur)
+		os=-rtu
+		;;
+	m88k-omron*)
+		os=-luna
+		;;
+	*-next )
+		os=-nextstep
+		;;
+	*-sequent)
+		os=-ptx
+		;;
+	*-crds)
+		os=-unos
+		;;
+	*-ns)
+		os=-genix
+		;;
+	i370-*)
+		os=-mvs
+		;;
+	*-next)
+		os=-nextstep3
+		;;
+        *-gould)
+		os=-sysv
+		;;
+        *-highlevel)
+		os=-bsd
+		;;
+	*-encore)
+		os=-bsd
+		;;
+        *-sgi)
+		os=-irix
+		;;
+        *-siemens)
+		os=-sysv4
+		;;
+	*-masscomp)
+		os=-rtu
+		;;
+	f301-fujitsu)
+		os=-uxpv
+		;;
+	*)
+		os=-none
+		;;
+esac
+fi
+
+# Here we handle the case where we know the os, and the CPU type, but not the
+# manufacturer.  We pick the logical manufacturer.
+vendor=unknown
+case $basic_machine in
+	*-unknown)
+		case $os in
+			-riscix*)
+				vendor=acorn
+				;;
+			-sunos*)
+				vendor=sun
+				;;
+			-aix*)
+				vendor=ibm
+				;;
+			-hpux*)
+				vendor=hp
+				;;
+			-hiux*)
+				vendor=hitachi
+				;;
+			-unos*)
+				vendor=crds
+				;;
+			-dgux*)
+				vendor=dg
+				;;
+			-luna*)
+				vendor=omron
+				;;
+			-genix*)
+				vendor=ns
+				;;
+			-mvs*)
+				vendor=ibm
+				;;
+			-ptx*)
+				vendor=sequent
+				;;
+			-vxsim* | -vxworks*)
+				vendor=wrs
+				;;
+			-aux*)
+				vendor=apple
+				;;
+		esac
+		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
+		;;
+esac
+
+echo $basic_machine$os
diff --git a/pppd/plugins/radius/radiusclient/configure b/pppd/plugins/radius/radiusclient/configure
new file mode 100755
index 0000000..020ed23
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/configure
@@ -0,0 +1,3275 @@
+#! /bin/sh
+
+# Guess values for system-dependent variables and create Makefiles.
+# Generated automatically using autoconf version 2.12 
+# Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+
+# Defaults:
+ac_help=
+ac_default_prefix=/usr/local
+# Any additions from configure.in:
+ac_help="$ac_help
+  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]"
+ac_help="$ac_help
+  --enable-shared         build shared libraries [default=yes]"
+ac_help="$ac_help
+  --enable-static         build static libraries [default=yes]"
+ac_help="$ac_help
+  --enable-shadow         Enable shadow password support"
+ac_help="$ac_help
+  --with-secure-path      PATH setting for exec'ed programs"
+ac_help="$ac_help
+  --with-facility         Syslog facility to use"
+ac_help="$ac_help
+  --enable-radius-116     Include support for Livingston's RADIUS server 1.16"
+ac_help="$ac_help
+  --enable-scp            Add service type hints derived from username prefix"
+
+# Initialize some variables set by options.
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+build=NONE
+cache_file=./config.cache
+exec_prefix=NONE
+host=NONE
+no_create=
+nonopt=NONE
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+target=NONE
+verbose=
+x_includes=NONE
+x_libraries=NONE
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+# Initialize some other variables.
+subdirs=
+MFLAGS= MAKEFLAGS=
+# Maximum number of lines to put in a shell here document.
+ac_max_here_lines=12
+
+ac_prev=
+for ac_option
+do
+
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  case "$ac_option" in
+  -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
+  *) ac_optarg= ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case "$ac_option" in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir="$ac_optarg" ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build="$ac_optarg" ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file="$ac_optarg" ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir="$ac_optarg" ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`echo $ac_option|sed -e 's/-*disable-//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_feature| sed 's/[-a-zA-Z0-9_]//g'`"; then
+      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
+    fi
+    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
+    eval "enable_${ac_feature}=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`echo $ac_option|sed -e 's/-*enable-//' -e 's/=.*//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_feature| sed 's/[-_a-zA-Z0-9]//g'`"; then
+      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
+    fi
+    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
+    case "$ac_option" in
+      *=*) ;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_${ac_feature}='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix="$ac_optarg" ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he)
+    # Omit some internal or obsolete options to make the list less imposing.
+    # This message is too long to be a string in the A/UX 3.1 sh.
+    cat << EOF
+Usage: configure [options] [host]
+Options: [defaults in brackets after descriptions]
+Configuration:
+  --cache-file=FILE       cache test results in FILE
+  --help                  print this message
+  --no-create             do not create output files
+  --quiet, --silent       do not print \`checking...' messages
+  --version               print the version of autoconf that created configure
+Directory and file names:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [same as prefix]
+  --bindir=DIR            user executables in DIR [EPREFIX/bin]
+  --sbindir=DIR           system admin executables in DIR [EPREFIX/sbin]
+  --libexecdir=DIR        program executables in DIR [EPREFIX/libexec]
+  --datadir=DIR           read-only architecture-independent data in DIR
+                          [PREFIX/share]
+  --sysconfdir=DIR        read-only single-machine data in DIR [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data in DIR
+                          [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data in DIR [PREFIX/var]
+  --libdir=DIR            object code libraries in DIR [EPREFIX/lib]
+  --includedir=DIR        C header files in DIR [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc in DIR [/usr/include]
+  --infodir=DIR           info documentation in DIR [PREFIX/info]
+  --mandir=DIR            man documentation in DIR [PREFIX/man]
+  --srcdir=DIR            find the sources in DIR [configure dir or ..]
+  --program-prefix=PREFIX prepend PREFIX to installed program names
+  --program-suffix=SUFFIX append SUFFIX to installed program names
+  --program-transform-name=PROGRAM
+                          run sed PROGRAM on installed program names
+EOF
+    cat << EOF
+Host type:
+  --build=BUILD           configure for building on BUILD [BUILD=HOST]
+  --host=HOST             configure for HOST [guessed]
+  --target=TARGET         configure for TARGET [TARGET=HOST]
+Features and packages:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --x-includes=DIR        X include files are in DIR
+  --x-libraries=DIR       X library files are in DIR
+EOF
+    if test -n "$ac_help"; then
+      echo "--enable and --with options recognized:$ac_help"
+    fi
+    exit 0 ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host="$ac_optarg" ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir="$ac_optarg" ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir="$ac_optarg" ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir="$ac_optarg" ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir="$ac_optarg" ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir="$ac_optarg" ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir="$ac_optarg" ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir="$ac_optarg" ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix="$ac_optarg" ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix="$ac_optarg" ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix="$ac_optarg" ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name="$ac_optarg" ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir="$ac_optarg" ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir="$ac_optarg" ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site="$ac_optarg" ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir="$ac_optarg" ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir="$ac_optarg" ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target="$ac_optarg" ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers)
+    echo "configure generated by autoconf version 2.12"
+    exit 0 ;;
+
+  -with-* | --with-*)
+    ac_package=`echo $ac_option|sed -e 's/-*with-//' -e 's/=.*//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_package| sed 's/[-_a-zA-Z0-9]//g'`"; then
+      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
+    fi
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case "$ac_option" in
+      *=*) ;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_${ac_package}='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`echo $ac_option|sed -e 's/-*without-//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_package| sed 's/[-a-zA-Z0-9_]//g'`"; then
+      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
+    fi
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    eval "with_${ac_package}=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes="$ac_optarg" ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries="$ac_optarg" ;;
+
+  -*) { echo "configure: error: $ac_option: invalid option; use --help to show usage" 1>&2; exit 1; }
+    ;;
+
+  *)
+    if test -n "`echo $ac_option| sed 's/[-a-z0-9.]//g'`"; then
+      echo "configure: warning: $ac_option: invalid host type" 1>&2
+    fi
+    if test "x$nonopt" != xNONE; then
+      { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; }
+    fi
+    nonopt="$ac_option"
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  { echo "configure: error: missing argument to --`echo $ac_prev | sed 's/_/-/g'`" 1>&2; exit 1; }
+fi
+
+trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
+
+# File descriptor usage:
+# 0 standard input
+# 1 file creation
+# 2 errors and warnings
+# 3 some systems may open it to /dev/tty
+# 4 used on the Kubota Titan
+# 6 checking for... messages and results
+# 5 compiler messages saved in config.log
+if test "$silent" = yes; then
+  exec 6>/dev/null
+else
+  exec 6>&1
+fi
+exec 5>./config.log
+
+echo "\
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+" 1>&5
+
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Also quote any args containing shell metacharacters.
+ac_configure_args=
+for ac_arg
+do
+  case "$ac_arg" in
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c) ;;
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
+  *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
+  ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+  *) ac_configure_args="$ac_configure_args $ac_arg" ;;
+  esac
+done
+
+# NLS nuisances.
+# Only set these to C if already set.  These must not be set unconditionally
+# because not all systems understand e.g. LANG=C (notably SCO).
+# Fixing LC_MESSAGES prevents Solaris sh from translating var values in `set'!
+# Non-C LC_CTYPE values break the ctype check.
+if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
+if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
+if test "${LC_MESSAGES+set}" = set; then LC_MESSAGES=C; export LC_MESSAGES; fi
+if test "${LC_CTYPE+set}"    = set; then LC_CTYPE=C;    export LC_CTYPE;    fi
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo > confdefs.h
+
+# A filename unique to this package, relative to the directory that
+# configure is in, which we can look for to find out if srcdir is correct.
+ac_unique_file=src/radlogin.c
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_prog=$0
+  ac_confdir=`echo $ac_prog|sed 's%/[^/][^/]*$%%'`
+  test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "configure: error: can not find sources in $ac_confdir or .." 1>&2; exit 1; }
+  else
+    { echo "configure: error: can not find sources in $srcdir" 1>&2; exit 1; }
+  fi
+fi
+srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`
+
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    echo "loading site script $ac_site_file"
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  echo "loading cache $cache_file"
+  . $cache_file
+else
+  echo "creating cache $cache_file"
+  > $cache_file
+fi
+
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
+  # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
+  if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
+    ac_n= ac_c='
+' ac_t='	'
+  else
+    ac_n=-n ac_c= ac_t=
+  fi
+else
+  ac_n= ac_c='\c' ac_t=
+fi
+
+
+ac_aux_dir=
+for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { echo "configure: error: can not find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." 1>&2; exit 1; }
+fi
+ac_config_guess=$ac_aux_dir/config.guess
+ac_config_sub=$ac_aux_dir/config.sub
+ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.
+
+
+# Do some error checking and defaulting for the host and target type.
+# The inputs are:
+#    configure --host=HOST --target=TARGET --build=BUILD NONOPT
+#
+# The rules are:
+# 1. You are not allowed to specify --host, --target, and nonopt at the
+#    same time.
+# 2. Host defaults to nonopt.
+# 3. If nonopt is not specified, then host defaults to the current host,
+#    as determined by config.guess.
+# 4. Target and build default to nonopt.
+# 5. If nonopt is not specified, then target and build default to host.
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+case $host---$target---$nonopt in
+NONE---*---* | *---NONE---* | *---*---NONE) ;;
+*) { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; } ;;
+esac
+
+
+# Make sure we can run config.sub.
+if $ac_config_sub sun4 >/dev/null 2>&1; then :
+else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
+fi
+
+echo $ac_n "checking host system type""... $ac_c" 1>&6
+echo "configure:585: checking host system type" >&5
+
+host_alias=$host
+case "$host_alias" in
+NONE)
+  case $nonopt in
+  NONE)
+    if host_alias=`$ac_config_guess`; then :
+    else { echo "configure: error: can not guess host type; you must specify one" 1>&2; exit 1; }
+    fi ;;
+  *) host_alias=$nonopt ;;
+  esac ;;
+esac
+
+host=`$ac_config_sub $host_alias`
+host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$host" 1>&6
+
+echo $ac_n "checking target system type""... $ac_c" 1>&6
+echo "configure:606: checking target system type" >&5
+
+target_alias=$target
+case "$target_alias" in
+NONE)
+  case $nonopt in
+  NONE) target_alias=$host_alias ;;
+  *) target_alias=$nonopt ;;
+  esac ;;
+esac
+
+target=`$ac_config_sub $target_alias`
+target_cpu=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$target" 1>&6
+
+echo $ac_n "checking build system type""... $ac_c" 1>&6
+echo "configure:624: checking build system type" >&5
+
+build_alias=$build
+case "$build_alias" in
+NONE)
+  case $nonopt in
+  NONE) build_alias=$host_alias ;;
+  *) build_alias=$nonopt ;;
+  esac ;;
+esac
+
+build=`$ac_config_sub $build_alias`
+build_cpu=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$build" 1>&6
+
+test "$host_alias" != "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+
+
+case "$target" in
+	*)
+	;;
+esac
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# ./install, which can be erroneously created by make from ./install.sh.
+echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
+echo "configure:663: checking for a BSD compatible install" >&5
+if test -z "$INSTALL"; then
+if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+    IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    # Account for people who put trailing slashes in PATH elements.
+    case "$ac_dir/" in
+    /|./|.//|/etc/*|/usr/sbin/*|/usr/etc/*|/sbin/*|/usr/afsws/bin/*|/usr/ucb/*) ;;
+    *)
+      # OSF1 and SCO ODT 3.0 have their own names for install.
+      for ac_prog in ginstall installbsd scoinst install; do
+        if test -f $ac_dir/$ac_prog; then
+	  if test $ac_prog = install &&
+            grep dspmsg $ac_dir/$ac_prog >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    # OSF/1 installbsd also uses dspmsg, but is usable.
+	    :
+	  else
+	    ac_cv_path_install="$ac_dir/$ac_prog -c"
+	    break 2
+	  fi
+	fi
+      done
+      ;;
+    esac
+  done
+  IFS="$ac_save_IFS"
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL="$ac_cv_path_install"
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL="$ac_install_sh"
+  fi
+fi
+echo "$ac_t""$INSTALL" 1>&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'
+
+echo $ac_n "checking whether build environment is sane""... $ac_c" 1>&6
+echo "configure:716: checking whether build environment is sane" >&5
+# Just in case
+sleep 1
+echo timestamp > conftestfile
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt $srcdir/configure conftestfile 2> /dev/null`
+   if test "$*" = "X"; then
+      # -L didn't work.
+      set X `ls -t $srcdir/configure conftestfile`
+   fi
+   if test "$*" != "X $srcdir/configure conftestfile" \
+      && test "$*" != "X conftestfile $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      { echo "configure: error: ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" 1>&2; exit 1; }
+   fi
+
+   test "$2" = conftestfile
+   )
+then
+   # Ok.
+   :
+else
+   { echo "configure: error: newly created file is older than distributed files!
+Check your system clock" 1>&2; exit 1; }
+fi
+rm -f conftest*
+echo "$ac_t""yes" 1>&6
+if test "$program_transform_name" = s,x,x,; then
+  program_transform_name=
+else
+  # Double any \ or $.  echo might interpret backslashes.
+  cat <<\EOF_SED > conftestsed
+s,\\,\\\\,g; s,\$,$$,g
+EOF_SED
+  program_transform_name="`echo $program_transform_name|sed -f conftestsed`"
+  rm -f conftestsed
+fi
+test "$program_prefix" != NONE &&
+  program_transform_name="s,^,${program_prefix},; $program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s,\$\$,${program_suffix},; $program_transform_name"
+
+# sed with no file args requires a program.
+test "$program_transform_name" = "" && program_transform_name="s,x,x,"
+
+echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
+echo "configure:773: checking whether ${MAKE-make} sets \${MAKE}" >&5
+set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftestmake <<\EOF
+all:
+	@echo 'ac_maketemp="${MAKE}"'
+EOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+eval `${MAKE-make} -f conftestmake 2>/dev/null | grep temp=`
+if test -n "$ac_maketemp"; then
+  eval ac_cv_prog_make_${ac_make}_set=yes
+else
+  eval ac_cv_prog_make_${ac_make}_set=no
+fi
+rm -f conftestmake
+fi
+if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  SET_MAKE=
+else
+  echo "$ac_t""no" 1>&6
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+
+PACKAGE=radiusclient
+
+VERSION=0.3.1
+
+if test "`cd $srcdir && pwd`" != "`pwd`" && test -f $srcdir/config.status; then
+  { echo "configure: error: source directory already configured; run "make distclean" there first" 1>&2; exit 1; }
+fi
+cat >> confdefs.h <<EOF
+#define PACKAGE "$PACKAGE"
+EOF
+
+cat >> confdefs.h <<EOF
+#define VERSION "$VERSION"
+EOF
+
+
+
+missing_dir=`cd $ac_aux_dir && pwd`
+echo $ac_n "checking for working aclocal""... $ac_c" 1>&6
+echo "configure:819: checking for working aclocal" >&5
+# Run test in a subshell; some versions of sh will print an error if
+# an executable is not found, even if stderr is redirected.
+# Redirect stdin to placate older versions of autoconf.  Sigh.
+if (aclocal --version) < /dev/null > /dev/null 2>&1; then
+   ACLOCAL=aclocal
+   echo "$ac_t""found" 1>&6
+else
+   ACLOCAL="$missing_dir/missing aclocal"
+   echo "$ac_t""missing" 1>&6
+fi
+
+echo $ac_n "checking for working autoconf""... $ac_c" 1>&6
+echo "configure:832: checking for working autoconf" >&5
+# Run test in a subshell; some versions of sh will print an error if
+# an executable is not found, even if stderr is redirected.
+# Redirect stdin to placate older versions of autoconf.  Sigh.
+if (autoconf --version) < /dev/null > /dev/null 2>&1; then
+   AUTOCONF=autoconf
+   echo "$ac_t""found" 1>&6
+else
+   AUTOCONF="$missing_dir/missing autoconf"
+   echo "$ac_t""missing" 1>&6
+fi
+
+echo $ac_n "checking for working automake""... $ac_c" 1>&6
+echo "configure:845: checking for working automake" >&5
+# Run test in a subshell; some versions of sh will print an error if
+# an executable is not found, even if stderr is redirected.
+# Redirect stdin to placate older versions of autoconf.  Sigh.
+if (automake --version) < /dev/null > /dev/null 2>&1; then
+   AUTOMAKE=automake
+   echo "$ac_t""found" 1>&6
+else
+   AUTOMAKE="$missing_dir/missing automake"
+   echo "$ac_t""missing" 1>&6
+fi
+
+echo $ac_n "checking for working autoheader""... $ac_c" 1>&6
+echo "configure:858: checking for working autoheader" >&5
+# Run test in a subshell; some versions of sh will print an error if
+# an executable is not found, even if stderr is redirected.
+# Redirect stdin to placate older versions of autoconf.  Sigh.
+if (autoheader --version) < /dev/null > /dev/null 2>&1; then
+   AUTOHEADER=autoheader
+   echo "$ac_t""found" 1>&6
+else
+   AUTOHEADER="$missing_dir/missing autoheader"
+   echo "$ac_t""missing" 1>&6
+fi
+
+echo $ac_n "checking for working makeinfo""... $ac_c" 1>&6
+echo "configure:871: checking for working makeinfo" >&5
+# Run test in a subshell; some versions of sh will print an error if
+# an executable is not found, even if stderr is redirected.
+# Redirect stdin to placate older versions of autoconf.  Sigh.
+if (makeinfo --version) < /dev/null > /dev/null 2>&1; then
+   MAKEINFO=makeinfo
+   echo "$ac_t""found" 1>&6
+else
+   MAKEINFO="$missing_dir/missing makeinfo"
+   echo "$ac_t""missing" 1>&6
+fi
+
+
+
+LIBVERSION=0:1:0
+
+
+pkgsysconfdir=${sysconfdir}/$PACKAGE
+
+
+# Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:894: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_prog_CC="gcc"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:923: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  ac_prog_rejected=no
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test "$ac_dir/$ac_word" = "/usr/ucb/cc"; then
+        ac_prog_rejected=yes
+	continue
+      fi
+      ac_cv_prog_CC="cc"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# -gt 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    set dummy "$ac_dir/$ac_word" "$@"
+    shift
+    ac_cv_prog_CC="$@"
+  fi
+fi
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+  test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
+fi
+
+echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
+echo "configure:971: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+cat > conftest.$ac_ext <<EOF
+#line 981 "configure"
+#include "confdefs.h"
+main(){return(0);}
+EOF
+if { (eval echo configure:985: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  ac_cv_prog_cc_works=yes
+  # If we can't run a trivial program, we are probably using a cross compiler.
+  if (./conftest; exit) 2>/dev/null; then
+    ac_cv_prog_cc_cross=no
+  else
+    ac_cv_prog_cc_cross=yes
+  fi
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  ac_cv_prog_cc_works=no
+fi
+rm -fr conftest*
+
+echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
+if test $ac_cv_prog_cc_works = no; then
+  { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
+fi
+echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
+echo "configure:1005: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
+cross_compiling=$ac_cv_prog_cc_cross
+
+echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
+echo "configure:1010: checking whether we are using GNU C" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.c <<EOF
+#ifdef __GNUC__
+  yes;
+#endif
+EOF
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1019: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+  ac_cv_prog_gcc=yes
+else
+  ac_cv_prog_gcc=no
+fi
+fi
+
+echo "$ac_t""$ac_cv_prog_gcc" 1>&6
+
+if test $ac_cv_prog_gcc = yes; then
+  GCC=yes
+  ac_test_CFLAGS="${CFLAGS+set}"
+  ac_save_CFLAGS="$CFLAGS"
+  CFLAGS=
+  echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
+echo "configure:1034: checking whether ${CC-cc} accepts -g" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  echo 'void f(){}' > conftest.c
+if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
+  ac_cv_prog_cc_g=yes
+else
+  ac_cv_prog_cc_g=no
+fi
+rm -f conftest*
+
+fi
+
+echo "$ac_t""$ac_cv_prog_cc_g" 1>&6
+  if test "$ac_test_CFLAGS" = set; then
+    CFLAGS="$ac_save_CFLAGS"
+  elif test $ac_cv_prog_cc_g = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-O2"
+  fi
+else
+  GCC=
+  test "${CFLAGS+set}" = set || CFLAGS="-g"
+fi
+
+
+# Extract the first word of "ar", so it can be a program name with args.
+set dummy ar; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1065: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_AR'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$AR" in
+  /*)
+  ac_cv_path_AR="$AR" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_path_AR="$ac_dir/$ac_word"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  ;;
+esac
+fi
+AR="$ac_cv_path_AR"
+if test -n "$AR"; then
+  echo "$ac_t""$AR" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+# Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1096: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_prog_RANLIB="ranlib"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_prog_RANLIB" && ac_cv_prog_RANLIB=":"
+fi
+fi
+RANLIB="$ac_cv_prog_RANLIB"
+if test -n "$RANLIB"; then
+  echo "$ac_t""$RANLIB" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+# Check whether --with-gnu-ld or --without-gnu-ld was given.
+if test "${with_gnu_ld+set}" = set; then
+  withval="$with_gnu_ld"
+  test "$withval" = no || with_gnu_ld=yes
+else
+  with_gnu_ld=no
+fi
+
+
+ac_prog=ld
+if test "$ac_cv_prog_gcc" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  echo $ac_n "checking for ld used by GCC""... $ac_c" 1>&6
+echo "configure:1135: checking for ld used by GCC" >&5
+  ac_prog=`($CC -print-prog-name=ld) 2>&5`
+  case "$ac_prog" in
+  # Accept absolute paths.
+  /*)
+    test -z "$LD" && LD="$ac_prog"
+    ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  echo $ac_n "checking for GNU ld""... $ac_c" 1>&6
+echo "configure:1153: checking for GNU ld" >&5
+else
+  echo $ac_n "checking for non-GNU ld""... $ac_c" 1>&6
+echo "configure:1156: checking for non-GNU ld" >&5
+fi
+if eval "test \"`echo '$''{'ac_cv_path_LD'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -z "$LD"; then
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog"; then
+      ac_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some GNU ld's only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      if "$ac_cv_path_LD" -v 2>&1 < /dev/null | egrep '(GNU|with BFD)' > /dev/null; then
+	test "$with_gnu_ld" != no && break
+      else
+        test "$with_gnu_ld" != yes && break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+else
+  ac_cv_path_LD="$LD" # Let the user override the test with a path.
+fi
+fi
+
+LD="$ac_cv_path_LD"
+if test -n "$LD"; then
+  echo "$ac_t""$LD" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+test -z "$LD" && { echo "configure: error: no acceptable ld found in \$PATH" 1>&2; exit 1; }
+
+echo $ac_n "checking if the linker ($LD) is GNU ld""... $ac_c" 1>&6
+echo "configure:1192: checking if the linker ($LD) is GNU ld" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_gnu_ld'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  # I'd rather use --version here, but apparently some GNU ld's only accept -v.
+if $LD -v 2>&1 </dev/null | egrep '(GNU|with BFD)' 1>&5; then
+  ac_cv_prog_gnu_ld=yes
+else
+  ac_cv_prog_gnu_ld=no
+fi
+fi
+
+echo "$ac_t""$ac_cv_prog_gnu_ld" 1>&6
+
+
+echo $ac_n "checking for BSD-compatible nm""... $ac_c" 1>&6
+echo "configure:1208: checking for BSD-compatible nm" >&5
+if eval "test \"`echo '$''{'ac_cv_path_NM'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$NM" in
+/*)
+  ac_cv_path_NM="$NM" # Let the user override the test with a path.
+  ;;
+*)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in /usr/ucb /usr/ccs/bin $PATH /bin; do
+    test -z "$ac_dir" && dir=.
+    if test -f $ac_dir/nm; then
+      # Check to see if the nm accepts a BSD-compat flag.
+      # Adding the `sed 1!d' prevents false positives on HP-UX, which says:
+      #   nm: unknown option "B" ignored
+      if ($ac_dir/nm -B /dev/null 2>&1 | sed '1!d'; exit 0) | egrep /dev/null >/dev/null; then
+        ac_cv_path_NM="$ac_dir/nm -B"
+      elif ($ac_dir/nm -p /dev/null 2>&1 | sed '1!d'; exit 0) | egrep /dev/null >/dev/null; then
+        ac_cv_path_NM="$ac_dir/nm -p"
+      else
+        ac_cv_path_NM="$ac_dir/nm"
+      fi
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_NM" && ac_cv_path_NM=nm
+  ;;
+esac
+fi
+
+NM="$ac_cv_path_NM"
+echo "$ac_t""$NM" 1>&6
+
+
+echo $ac_n "checking whether ln -s works""... $ac_c" 1>&6
+echo "configure:1245: checking whether ln -s works" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_LN_S'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  rm -f conftestdata
+if ln -s X conftestdata 2>/dev/null
+then
+  rm -f conftestdata
+  ac_cv_prog_LN_S="ln -s"
+else
+  ac_cv_prog_LN_S=ln
+fi
+fi
+LN_S="$ac_cv_prog_LN_S"
+if test "$ac_cv_prog_LN_S" = "ln -s"; then
+  echo "$ac_t""yes" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+
+
+
+
+
+
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+
+
+# Check whether --enable-shared or --disable-shared was given.
+if test "${enable_shared+set}" = set; then
+  enableval="$enable_shared"
+  if test "$enableval" = no; then
+  libtool_enable_shared=no
+else
+  libtool_enable_shared=yes
+fi
+fi
+
+test -n "$libtool_enable_shared" && enable_shared="$libtool_enable_shared"
+libtool_shared=
+test "$enable_shared" = no && libtool_shared=" --disable-shared"
+
+# Check whether --enable-static or --disable-static was given.
+if test "${enable_static+set}" = set; then
+  enableval="$enable_static"
+  if test "$enableval" = no; then
+  libtool_enable_static=no
+else
+  libtool_enable_static=yes
+fi
+fi
+
+test -n "$libtool_enable_static" && enable_static="$libtool_enable_static"
+libtool_static=
+test "$enable_static" = no && libtool_static=" --disable-static"
+
+libtool_flags="$libtool_shared$libtool_static"
+test "$silent" = yes && libtool_flags="$libtool_flags --silent"
+test "$ac_cv_prog_gcc" = yes && libtool_flags="$libtool_flags --with-gcc"
+test "$ac_cv_prog_gnu_ld" = yes && libtool_flags="$libtool_flags --with-gnu-ld"
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case "$host" in
+*-*-irix6*)
+  ac_save_CFLAGS="$CFLAGS"
+  flag_passed=no
+  for f in -32 -64 -n32 ABI -cckr -mips1 -mips2 -mips3 -mips4; do
+    case "$f" in
+    ABI)
+      test -n "$SGI_ABI" && flag_passed=yes
+      if test "$flag_passed" = no && test "$ac_cv_prog_gcc" = yes; then
+	# Choose the ABI flag according to GCC's specs.
+	if $CC -dumpspecs 2>&1 | sed '/^\*link:$/,/^$/!d' | egrep -e '[ 	]-32' >/dev/null; then
+	  LD="${LD-ld} -32"
+	else
+	  LD="${LD-ld} -n32"
+	fi
+      fi
+      ;;
+
+    *)
+      if echo " $CC $CFLAGS " | egrep -e "[ 	]$f[	 ]" > /dev/null; then
+	flag_passed=yes
+	LD="${LD-ld} $f"
+      fi
+      ;;
+    esac
+  done
+  CFLAGS="$ac_save_CFLAGS"
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  CFLAGS="$CFLAGS -belf"
+  ;;
+esac
+
+# Actually configure libtool.  ac_aux_dir is where install-sh is found.
+CC="$CC" CFLAGS="$CFLAGS" CPPFLAGS="$CPPFLAGS" \
+LD="$LD" NM="$NM" RANLIB="$RANLIB" LN_S="$LN_S" \
+${CONFIG_SHELL-/bin/sh} $ac_aux_dir/ltconfig \
+$libtool_flags --no-verify $ac_aux_dir/ltmain.sh $host \
+|| { echo "configure: error: libtool configure failed" 1>&2; exit 1; }
+
+
+echo $ac_n "checking whether to include shadow password support""... $ac_c" 1>&6
+echo "configure:1355: checking whether to include shadow password support" >&5
+# Check whether --enable-shadow or --disable-shadow was given.
+if test "${enable_shadow+set}" = set; then
+  enableval="$enable_shadow"
+  
+        echo "$ac_t""yes" 1>&6
+	cat >> confdefs.h <<\EOF
+#define HAVE_SHADOW_PASSWORDS 1
+EOF
+
+	shadow_passwords=yes
+
+else
+  
+        echo "$ac_t""no" 1>&6
+	shadow_passwords=no
+
+
+fi
+
+
+echo $ac_n "checking for gethostbyname in -lnsl""... $ac_c" 1>&6
+echo "configure:1377: checking for gethostbyname in -lnsl" >&5
+ac_lib_var=`echo nsl'_'gethostbyname | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lnsl  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1385 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char gethostbyname();
+
+int main() {
+gethostbyname()
+; return 0; }
+EOF
+if { (eval echo configure:1396: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo nsl | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-lnsl $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+echo $ac_n "checking for socket in -lsocket""... $ac_c" 1>&6
+echo "configure:1424: checking for socket in -lsocket" >&5
+ac_lib_var=`echo socket'_'socket | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lsocket  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1432 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char socket();
+
+int main() {
+socket()
+; return 0; }
+EOF
+if { (eval echo configure:1443: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo socket | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-lsocket $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+if test "$shadow_passwords" = "yes"
+then
+	echo $ac_n "checking for getspnam in -lc""... $ac_c" 1>&6
+echo "configure:1473: checking for getspnam in -lc" >&5
+ac_lib_var=`echo c'_'getspnam | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lc  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1481 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char getspnam();
+
+int main() {
+getspnam()
+; return 0; }
+EOF
+if { (eval echo configure:1492: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  :
+else
+  echo "$ac_t""no" 1>&6
+echo $ac_n "checking for getspnam in -lshadow""... $ac_c" 1>&6
+echo "configure:1511: checking for getspnam in -lshadow" >&5
+ac_lib_var=`echo shadow'_'getspnam | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lshadow  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1519 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char getspnam();
+
+int main() {
+getspnam()
+; return 0; }
+EOF
+if { (eval echo configure:1530: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  LIBS="$LIBS -lshadow"
+                
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+	
+fi
+
+fi
+echo $ac_n "checking for crypt in -lcrypt""... $ac_c" 1>&6
+echo "configure:1556: checking for crypt in -lcrypt" >&5
+ac_lib_var=`echo crypt'_'crypt | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lcrypt  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1564 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char crypt();
+
+int main() {
+crypt()
+; return 0; }
+EOF
+if { (eval echo configure:1575: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo crypt | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-lcrypt $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+
+ac_header_dirent=no
+for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
+echo "configure:1608: checking for $ac_hdr that defines DIR" >&5
+if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1613 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <$ac_hdr>
+int main() {
+DIR *dirp = 0;
+; return 0; }
+EOF
+if { (eval echo configure:1621: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  eval "ac_cv_header_dirent_$ac_safe=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_dirent_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_dirent_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ ac_header_dirent=$ac_hdr; break
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+# Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
+if test $ac_header_dirent = dirent.h; then
+echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
+echo "configure:1646: checking for opendir in -ldir" >&5
+ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-ldir  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1654 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char opendir();
+
+int main() {
+opendir()
+; return 0; }
+EOF
+if { (eval echo configure:1665: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  LIBS="$LIBS -ldir"
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+else
+echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
+echo "configure:1687: checking for opendir in -lx" >&5
+ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lx  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1695 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char opendir();
+
+int main() {
+opendir()
+; return 0; }
+EOF
+if { (eval echo configure:1706: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  LIBS="$LIBS -lx"
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+fi
+
+echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
+echo "configure:1729: checking how to run the C preprocessor" >&5
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+if eval "test \"`echo '$''{'ac_cv_prog_CPP'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+    # This must be in double quotes, not single quotes, because CPP may get
+  # substituted into the Makefile and "${CC-cc}" will confuse make.
+  CPP="${CC-cc} -E"
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp.
+  cat > conftest.$ac_ext <<EOF
+#line 1744 "configure"
+#include "confdefs.h"
+#include <assert.h>
+Syntax Error
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1750: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out`
+if test -z "$ac_err"; then
+  :
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  CPP="${CC-cc} -E -traditional-cpp"
+  cat > conftest.$ac_ext <<EOF
+#line 1761 "configure"
+#include "confdefs.h"
+#include <assert.h>
+Syntax Error
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1767: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out`
+if test -z "$ac_err"; then
+  :
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  CPP=/lib/cpp
+fi
+rm -f conftest*
+fi
+rm -f conftest*
+  ac_cv_prog_CPP="$CPP"
+fi
+  CPP="$ac_cv_prog_CPP"
+else
+  ac_cv_prog_CPP="$CPP"
+fi
+echo "$ac_t""$CPP" 1>&6
+
+echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
+echo "configure:1790: checking for ANSI C header files" >&5
+if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1795 "configure"
+#include "confdefs.h"
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1803: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  ac_cv_header_stdc=yes
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+cat > conftest.$ac_ext <<EOF
+#line 1820 "configure"
+#include "confdefs.h"
+#include <string.h>
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "memchr" >/dev/null 2>&1; then
+  :
+else
+  rm -rf conftest*
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+cat > conftest.$ac_ext <<EOF
+#line 1838 "configure"
+#include "confdefs.h"
+#include <stdlib.h>
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "free" >/dev/null 2>&1; then
+  :
+else
+  rm -rf conftest*
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+if test "$cross_compiling" = yes; then
+  :
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1859 "configure"
+#include "confdefs.h"
+#include <ctype.h>
+#define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+#define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int main () { int i; for (i = 0; i < 256; i++)
+if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
+exit (0); }
+
+EOF
+if { (eval echo configure:1870: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+then
+  :
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_header_stdc=no
+fi
+rm -fr conftest*
+fi
+
+fi
+fi
+
+echo "$ac_t""$ac_cv_header_stdc" 1>&6
+if test $ac_cv_header_stdc = yes; then
+  cat >> confdefs.h <<\EOF
+#define STDC_HEADERS 1
+EOF
+
+fi
+
+for ac_hdr in crypt.h signal.h sys/signal.h sys/stat.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:1897: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1902 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1907: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+for ac_hdr in fcntl.h sys/fcntl.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:1937: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1942 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1947: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+for ac_hdr in sys/utsname.h getopt.h unistd.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:1977: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1982 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1987: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+for ac_hdr in sys/file.h termios.h sys/ioctl.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:2017: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2022 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:2027: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+if test "$shadow_passwords" = "yes"
+then
+	ac_safe=`echo "shadow.h" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for shadow.h""... $ac_c" 1>&6
+echo "configure:2057: checking for shadow.h" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2062 "configure"
+#include "confdefs.h"
+#include <shadow.h>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:2067: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  :
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+fi
+
+
+echo $ac_n "checking for working const""... $ac_c" 1>&6
+echo "configure:2092: checking for working const" >&5
+if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2097 "configure"
+#include "confdefs.h"
+
+int main() {
+
+/* Ultrix mips cc rejects this.  */
+typedef int charset[2]; const charset x;
+/* SunOS 4.1.1 cc rejects this.  */
+char const *const *ccp;
+char **p;
+/* NEC SVR4.0.2 mips cc rejects this.  */
+struct point {int x, y;};
+static struct point const zero = {0,0};
+/* AIX XL C 1.02.0.0 rejects this.
+   It does not let you subtract one const X* pointer from another in an arm
+   of an if-expression whose if-part is not a constant expression */
+const char *g = "string";
+ccp = &g + (g ? g-g : 0);
+/* HPUX 7.0 cc rejects these. */
+++ccp;
+p = (char**) ccp;
+ccp = (char const *const *) p;
+{ /* SCO 3.2v4 cc rejects this.  */
+  char *t;
+  char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+  *t++ = 0;
+}
+{ /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+  int x[] = {25, 17};
+  const int *foo = &x[0];
+  ++foo;
+}
+{ /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+  typedef const int *iptr;
+  iptr p = 0;
+  ++p;
+}
+{ /* AIX XL C 1.02.0.0 rejects this saying
+     "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+  struct s { int j; const int *ap[3]; };
+  struct s *b; b->j = 5;
+}
+{ /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+  const int foo = 10;
+}
+
+; return 0; }
+EOF
+if { (eval echo configure:2146: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_c_const=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_c_const=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_c_const" 1>&6
+if test $ac_cv_c_const = no; then
+  cat >> confdefs.h <<\EOF
+#define const 
+EOF
+
+fi
+
+echo $ac_n "checking for off_t""... $ac_c" 1>&6
+echo "configure:2167: checking for off_t" >&5
+if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2172 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "off_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
+  rm -rf conftest*
+  ac_cv_type_off_t=yes
+else
+  rm -rf conftest*
+  ac_cv_type_off_t=no
+fi
+rm -f conftest*
+
+fi
+echo "$ac_t""$ac_cv_type_off_t" 1>&6
+if test $ac_cv_type_off_t = no; then
+  cat >> confdefs.h <<\EOF
+#define off_t long
+EOF
+
+fi
+
+echo $ac_n "checking for size_t""... $ac_c" 1>&6
+echo "configure:2200: checking for size_t" >&5
+if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2205 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "size_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
+  rm -rf conftest*
+  ac_cv_type_size_t=yes
+else
+  rm -rf conftest*
+  ac_cv_type_size_t=no
+fi
+rm -f conftest*
+
+fi
+echo "$ac_t""$ac_cv_type_size_t" 1>&6
+if test $ac_cv_type_size_t = no; then
+  cat >> confdefs.h <<\EOF
+#define size_t unsigned
+EOF
+
+fi
+
+echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
+echo "configure:2233: checking whether time.h and sys/time.h may both be included" >&5
+if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2238 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+int main() {
+struct tm *tp;
+; return 0; }
+EOF
+if { (eval echo configure:2247: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_header_time=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_header_time=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_header_time" 1>&6
+if test $ac_cv_header_time = yes; then
+  cat >> confdefs.h <<\EOF
+#define TIME_WITH_SYS_TIME 1
+EOF
+
+fi
+
+echo $ac_n "checking whether struct tm is in sys/time.h or time.h""... $ac_c" 1>&6
+echo "configure:2268: checking whether struct tm is in sys/time.h or time.h" >&5
+if eval "test \"`echo '$''{'ac_cv_struct_tm'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2273 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <time.h>
+int main() {
+struct tm *tp; tp->tm_sec;
+; return 0; }
+EOF
+if { (eval echo configure:2281: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_struct_tm=time.h
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_struct_tm=sys/time.h
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_struct_tm" 1>&6
+if test $ac_cv_struct_tm = sys/time.h; then
+  cat >> confdefs.h <<\EOF
+#define TM_IN_SYS_TIME 1
+EOF
+
+fi
+
+
+if test $ac_cv_prog_gcc = yes; then
+    echo $ac_n "checking whether ${CC-cc} needs -traditional""... $ac_c" 1>&6
+echo "configure:2304: checking whether ${CC-cc} needs -traditional" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_gcc_traditional'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+    ac_pattern="Autoconf.*'x'"
+  cat > conftest.$ac_ext <<EOF
+#line 2310 "configure"
+#include "confdefs.h"
+#include <sgtty.h>
+Autoconf TIOCGETP
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "$ac_pattern" >/dev/null 2>&1; then
+  rm -rf conftest*
+  ac_cv_prog_gcc_traditional=yes
+else
+  rm -rf conftest*
+  ac_cv_prog_gcc_traditional=no
+fi
+rm -f conftest*
+
+
+  if test $ac_cv_prog_gcc_traditional = no; then
+    cat > conftest.$ac_ext <<EOF
+#line 2328 "configure"
+#include "confdefs.h"
+#include <termio.h>
+Autoconf TCGETA
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "$ac_pattern" >/dev/null 2>&1; then
+  rm -rf conftest*
+  ac_cv_prog_gcc_traditional=yes
+fi
+rm -f conftest*
+
+  fi
+fi
+
+echo "$ac_t""$ac_cv_prog_gcc_traditional" 1>&6
+  if test $ac_cv_prog_gcc_traditional = yes; then
+    CC="$CC -traditional"
+  fi
+fi
+
+echo $ac_n "checking for 8-bit clean memcmp""... $ac_c" 1>&6
+echo "configure:2350: checking for 8-bit clean memcmp" >&5
+if eval "test \"`echo '$''{'ac_cv_func_memcmp_clean'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_func_memcmp_clean=no
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2358 "configure"
+#include "confdefs.h"
+
+main()
+{
+  char c0 = 0x40, c1 = 0x80, c2 = 0x81;
+  exit(memcmp(&c0, &c2, 1) < 0 && memcmp(&c1, &c2, 1) < 0 ? 0 : 1);
+}
+
+EOF
+if { (eval echo configure:2368: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+then
+  ac_cv_func_memcmp_clean=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_func_memcmp_clean=no
+fi
+rm -fr conftest*
+fi
+
+fi
+
+echo "$ac_t""$ac_cv_func_memcmp_clean" 1>&6
+test $ac_cv_func_memcmp_clean = no && LIBOBJS="$LIBOBJS memcmp.o"
+
+echo $ac_n "checking whether setvbuf arguments are reversed""... $ac_c" 1>&6
+echo "configure:2386: checking whether setvbuf arguments are reversed" >&5
+if eval "test \"`echo '$''{'ac_cv_func_setvbuf_reversed'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2394 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+/* If setvbuf has the reversed format, exit 0. */
+main () {
+  /* This call has the arguments reversed.
+     A reversed system may check and see that the address of main
+     is not _IOLBF, _IONBF, or _IOFBF, and return nonzero.  */
+  if (setvbuf(stdout, _IOLBF, (char *) main, BUFSIZ) != 0)
+    exit(1);
+  putc('\r', stdout);
+  exit(0);			/* Non-reversed systems segv here.  */
+}
+EOF
+if { (eval echo configure:2408: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+then
+  ac_cv_func_setvbuf_reversed=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_func_setvbuf_reversed=no
+fi
+rm -fr conftest*
+fi
+
+rm -f core core.* *.core
+fi
+
+echo "$ac_t""$ac_cv_func_setvbuf_reversed" 1>&6
+if test $ac_cv_func_setvbuf_reversed = yes; then
+  cat >> confdefs.h <<\EOF
+#define SETVBUF_REVERSED 1
+EOF
+
+fi
+
+echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
+echo "configure:2432: checking return type of signal handlers" >&5
+if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2437 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <signal.h>
+#ifdef signal
+#undef signal
+#endif
+#ifdef __cplusplus
+extern "C" void (*signal (int, void (*)(int)))(int);
+#else
+void (*signal ()) ();
+#endif
+
+int main() {
+int i;
+; return 0; }
+EOF
+if { (eval echo configure:2454: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_type_signal=void
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_type_signal=int
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_type_signal" 1>&6
+cat >> confdefs.h <<EOF
+#define RETSIGTYPE $ac_cv_type_signal
+EOF
+
+
+echo $ac_n "checking for strftime""... $ac_c" 1>&6
+echo "configure:2473: checking for strftime" >&5
+if eval "test \"`echo '$''{'ac_cv_func_strftime'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2478 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char strftime(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char strftime();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_strftime) || defined (__stub___strftime)
+choke me
+#else
+strftime();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:2501: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_func_strftime=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_strftime=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'strftime`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  cat >> confdefs.h <<\EOF
+#define HAVE_STRFTIME 1
+EOF
+
+else
+  echo "$ac_t""no" 1>&6
+# strftime is in -lintl on SCO UNIX.
+echo $ac_n "checking for strftime in -lintl""... $ac_c" 1>&6
+echo "configure:2523: checking for strftime in -lintl" >&5
+ac_lib_var=`echo intl'_'strftime | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lintl  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2531 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char strftime();
+
+int main() {
+strftime()
+; return 0; }
+EOF
+if { (eval echo configure:2542: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  cat >> confdefs.h <<\EOF
+#define HAVE_STRFTIME 1
+EOF
+
+LIBS="-lintl $LIBS"
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+fi
+
+for ac_func in strdup strerror strcasecmp
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:2571: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2576 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:2599: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+LIBOBJS="$LIBOBJS ${ac_func}.o"
+fi
+done
+
+
+for ac_func in flock fcntl uname gethostname sysinfo getdomainname
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:2628: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2633 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:2656: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+for ac_func in stricmp random rand snprintf vsnprintf
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:2683: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2688 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:2711: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+
+if test "$ac_cv_func_uname" = 'yes'
+then
+	echo $ac_n "checking for field domainname in struct utsname""... $ac_c" 1>&6
+echo "configure:2739: checking for field domainname in struct utsname" >&5
+	if test "$cross_compiling" = yes; then
+    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2744 "configure"
+#include "confdefs.h"
+
+	#include <sys/utsname.h>
+	
+	main(int argc, char **argv)
+	{
+		struct utsname uts;
+		uts.domainname[0] = '\0';
+	}
+	
+EOF
+if { (eval echo configure:2756: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+then
+  echo "$ac_t""yes" 1>&6
+	cat >> confdefs.h <<\EOF
+#define HAVE_STRUCT_UTSNAME_DOMAINNAME 1
+EOF
+
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  echo "$ac_t""no" 1>&6
+	
+fi
+rm -fr conftest*
+fi
+
+fi
+
+echo $ac_n "checking for /dev/urandom""... $ac_c" 1>&6
+echo "configure:2776: checking for /dev/urandom" >&5
+if test -c /dev/urandom
+then
+	echo "$ac_t""yes" 1>&6
+	cat >> confdefs.h <<\EOF
+#define HAVE_DEV_URANDOM 1
+EOF
+
+else
+	echo "$ac_t""no" 1>&6
+fi
+
+echo $ac_n "using the following PATH setting for exec'ed programs... $ac_c" 1>&6
+# Check whether --with-secure-path or --without-secure-path was given.
+if test "${with_secure_path+set}" = set; then
+  withval="$with_secure_path"
+  
+        echo "$ac_t""$withval" 1>&6
+        RC_SECURE_PATH=$withval
+
+else
+  
+        echo "$ac_t""/bin:/usr/bin:/usr/local/bin" 1>&6
+	RC_SECURE_PATH=/bin:/usr/bin:/usr/local/bin
+
+
+fi
+
+
+echo $ac_n "checking which syslog facility to use""... $ac_c" 1>&6
+echo "configure:2806: checking which syslog facility to use" >&5
+# Check whether --with-facility or --without-facility was given.
+if test "${with_facility+set}" = set; then
+  withval="$with_facility"
+  
+        echo "$ac_t""$withval" 1>&6
+        RC_LOG_FACILITY=$withval
+
+else
+  
+        echo "$ac_t""LOG_DAEMON" 1>&6
+        RC_LOG_FACILITY=LOG_DAEMON
+
+
+fi
+
+
+echo $ac_n "checking whether to include Livingston's RADIUS server 1.16 kludge""... $ac_c" 1>&6
+echo "configure:2824: checking whether to include Livingston's RADIUS server 1.16 kludge" >&5
+# Check whether --enable-radius-116 or --disable-radius-116 was given.
+if test "${enable_radius_116+set}" = set; then
+  enableval="$enable_radius_116"
+  
+        echo "$ac_t""yes" 1>&6
+	cat >> confdefs.h <<\EOF
+#define RADIUS_116 1
+EOF
+
+	echo "configure: warning: !! This is a bug in Livingston's RADIUS server v1.16. There" 1>&2
+	echo "configure: warning: !! is a patch included with radiusclient which fixes this" 1>&2
+	echo "configure: warning: !! problem. See patches/radiusd-1.16.accounting.diff. With" 1>&2
+	echo "configure: warning: !! the patched RADIUS server you no longer need to activate" 1>&2
+	echo "configure: warning: !! this hack." 1>&2
+
+else
+  
+        echo "$ac_t""no" 1>&6
+
+
+fi
+
+
+echo $ac_n "checking whether to add service type hints derived from username prefix""... $ac_c" 1>&6
+echo "configure:2849: checking whether to add service type hints derived from username prefix" >&5
+# Check whether --enable-scp or --disable-scp was given.
+if test "${enable_scp+set}" = set; then
+  enableval="$enable_scp"
+  
+        echo "$ac_t""yes" 1>&6
+	cat >> confdefs.h <<\EOF
+#define SCP 1
+EOF
+
+
+else
+  
+        echo "$ac_t""no" 1>&6
+
+
+fi
+
+
+
+
+
+
+
+
+LTLIBOBJS=`echo "$LIBOBJS" | sed 's/\.o/.lo/g'`
+
+trap '' 1 2 15
+cat > confcache <<\EOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs.  It is not useful on other systems.
+# If it contains results you don't want to keep, you may remove or edit it.
+#
+# By default, configure uses ./config.cache as the cache file,
+# creating it if it does not exist already.  You can give configure
+# the --cache-file=FILE option to use a different cache file; that is
+# what configure does when it calls configure scripts in
+# subdirectories, so they share the cache.
+# Giving --cache-file=/dev/null disables caching, for debugging configure.
+# config.status only pays attention to the cache file if you give it the
+# --recheck option to rerun configure.
+#
+EOF
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(set) 2>&1 |
+  case `(ac_space=' '; set) 2>&1` in
+  *ac_space=\ *)
+    # `set' does not quote correctly, so add quotes (double-quote substitution
+    # turns \\\\ into \\, and sed turns \\ into \).
+    sed -n \
+      -e "s/'/'\\\\''/g" \
+      -e "s/^\\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\\)=\\(.*\\)/\\1=\${\\1='\\2'}/p"
+    ;;
+  *)
+    # `set' quotes correctly as required by POSIX, so do not add quotes.
+    sed -n -e 's/^\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\)=\(.*\)/\1=${\1=\2}/p'
+    ;;
+  esac >> confcache
+if cmp -s $cache_file confcache; then
+  :
+else
+  if test -w $cache_file; then
+    echo "updating cache $cache_file"
+    cat confcache > $cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# Any assignment to VPATH causes Sun make to only execute
+# the first set of double-colon rules, so remove it if not needed.
+# If there is a colon in the path, we need to keep it.
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[ 	]*VPATH[ 	]*=[^:]*$/d'
+fi
+
+trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15
+
+DEFS=-DHAVE_CONFIG_H
+
+# Without the "./", some shells look in PATH for config.status.
+: ${CONFIG_STATUS=./config.status}
+
+echo creating $CONFIG_STATUS
+rm -f $CONFIG_STATUS
+cat > $CONFIG_STATUS <<EOF
+#! /bin/sh
+# Generated automatically by configure.
+# Run this file to recreate the current configuration.
+# This directory was configured as follows,
+# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+#
+# $0 $ac_configure_args
+#
+# Compiler output produced by configure, useful for debugging
+# configure, is in ./config.log if it exists.
+
+ac_cs_usage="Usage: $CONFIG_STATUS [--recheck] [--version] [--help]"
+for ac_option
+do
+  case "\$ac_option" in
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
+    exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
+  -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
+    echo "$CONFIG_STATUS generated by autoconf version 2.12"
+    exit 0 ;;
+  -help | --help | --hel | --he | --h)
+    echo "\$ac_cs_usage"; exit 0 ;;
+  *) echo "\$ac_cs_usage"; exit 1 ;;
+  esac
+done
+
+ac_given_srcdir=$srcdir
+ac_given_INSTALL="$INSTALL"
+
+trap 'rm -fr `echo "
+Makefile
+include/Makefile lib/Makefile src/Makefile man/Makefile etc/Makefile
+doc/Makefile patches/Makefile
+login.radius/Makefile login.radius/migs/Makefile
+ config.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
+EOF
+cat >> $CONFIG_STATUS <<EOF
+
+# Protect against being on the right side of a sed subst in config.status.
+sed 's/%@/@@/; s/@%/@@/; s/%g\$/@g/; /@g\$/s/[\\\\&%]/\\\\&/g;
+ s/@@/%@/; s/@@/@%/; s/@g\$/%g/' > conftest.subs <<\\CEOF
+$ac_vpsub
+$extrasub
+s%@CFLAGS@%$CFLAGS%g
+s%@CPPFLAGS@%$CPPFLAGS%g
+s%@CXXFLAGS@%$CXXFLAGS%g
+s%@DEFS@%$DEFS%g
+s%@LDFLAGS@%$LDFLAGS%g
+s%@LIBS@%$LIBS%g
+s%@exec_prefix@%$exec_prefix%g
+s%@prefix@%$prefix%g
+s%@program_transform_name@%$program_transform_name%g
+s%@bindir@%$bindir%g
+s%@sbindir@%$sbindir%g
+s%@libexecdir@%$libexecdir%g
+s%@datadir@%$datadir%g
+s%@sysconfdir@%$sysconfdir%g
+s%@sharedstatedir@%$sharedstatedir%g
+s%@localstatedir@%$localstatedir%g
+s%@libdir@%$libdir%g
+s%@includedir@%$includedir%g
+s%@oldincludedir@%$oldincludedir%g
+s%@infodir@%$infodir%g
+s%@mandir@%$mandir%g
+s%@host@%$host%g
+s%@host_alias@%$host_alias%g
+s%@host_cpu@%$host_cpu%g
+s%@host_vendor@%$host_vendor%g
+s%@host_os@%$host_os%g
+s%@target@%$target%g
+s%@target_alias@%$target_alias%g
+s%@target_cpu@%$target_cpu%g
+s%@target_vendor@%$target_vendor%g
+s%@target_os@%$target_os%g
+s%@build@%$build%g
+s%@build_alias@%$build_alias%g
+s%@build_cpu@%$build_cpu%g
+s%@build_vendor@%$build_vendor%g
+s%@build_os@%$build_os%g
+s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
+s%@INSTALL_DATA@%$INSTALL_DATA%g
+s%@INSTALL_SCRIPT@%$INSTALL_SCRIPT%g
+s%@PACKAGE@%$PACKAGE%g
+s%@VERSION@%$VERSION%g
+s%@ACLOCAL@%$ACLOCAL%g
+s%@AUTOCONF@%$AUTOCONF%g
+s%@AUTOMAKE@%$AUTOMAKE%g
+s%@AUTOHEADER@%$AUTOHEADER%g
+s%@MAKEINFO@%$MAKEINFO%g
+s%@SET_MAKE@%$SET_MAKE%g
+s%@LIBVERSION@%$LIBVERSION%g
+s%@pkgsysconfdir@%$pkgsysconfdir%g
+s%@CC@%$CC%g
+s%@AR@%$AR%g
+s%@RANLIB@%$RANLIB%g
+s%@LD@%$LD%g
+s%@NM@%$NM%g
+s%@LN_S@%$LN_S%g
+s%@LIBTOOL@%$LIBTOOL%g
+s%@CPP@%$CPP%g
+s%@LIBOBJS@%$LIBOBJS%g
+s%@RC_SECURE_PATH@%$RC_SECURE_PATH%g
+s%@RC_LOG_FACILITY@%$RC_LOG_FACILITY%g
+s%@LTLIBOBJS@%$LTLIBOBJS%g
+
+CEOF
+EOF
+
+cat >> $CONFIG_STATUS <<\EOF
+
+# Split the substitutions into bite-sized pieces for seds with
+# small command number limits, like on Digital OSF/1 and HP-UX.
+ac_max_sed_cmds=90 # Maximum number of lines to put in a sed script.
+ac_file=1 # Number of current file.
+ac_beg=1 # First line for current file.
+ac_end=$ac_max_sed_cmds # Line after last line for current file.
+ac_more_lines=:
+ac_sed_cmds=""
+while $ac_more_lines; do
+  if test $ac_beg -gt 1; then
+    sed "1,${ac_beg}d; ${ac_end}q" conftest.subs > conftest.s$ac_file
+  else
+    sed "${ac_end}q" conftest.subs > conftest.s$ac_file
+  fi
+  if test ! -s conftest.s$ac_file; then
+    ac_more_lines=false
+    rm -f conftest.s$ac_file
+  else
+    if test -z "$ac_sed_cmds"; then
+      ac_sed_cmds="sed -f conftest.s$ac_file"
+    else
+      ac_sed_cmds="$ac_sed_cmds | sed -f conftest.s$ac_file"
+    fi
+    ac_file=`expr $ac_file + 1`
+    ac_beg=$ac_end
+    ac_end=`expr $ac_end + $ac_max_sed_cmds`
+  fi
+done
+if test -z "$ac_sed_cmds"; then
+  ac_sed_cmds=cat
+fi
+EOF
+
+cat >> $CONFIG_STATUS <<EOF
+
+CONFIG_FILES=\${CONFIG_FILES-"Makefile
+include/Makefile lib/Makefile src/Makefile man/Makefile etc/Makefile
+doc/Makefile patches/Makefile
+login.radius/Makefile login.radius/migs/Makefile
+"}
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case "$ac_file" in
+  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+  *) ac_file_in="${ac_file}.in" ;;
+  esac
+
+  # Adjust a relative srcdir, top_srcdir, and INSTALL for subdirectories.
+
+  # Remove last slash and all that follows it.  Not all systems have dirname.
+  ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+  if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+    # The file is in a subdirectory.
+    test ! -d "$ac_dir" && mkdir "$ac_dir"
+    ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
+    # A "../" for each directory in $ac_dir_suffix.
+    ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
+  else
+    ac_dir_suffix= ac_dots=
+  fi
+
+  case "$ac_given_srcdir" in
+  .)  srcdir=.
+      if test -z "$ac_dots"; then top_srcdir=.
+      else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
+  /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
+  *) # Relative path.
+    srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
+    top_srcdir="$ac_dots$ac_given_srcdir" ;;
+  esac
+
+  case "$ac_given_INSTALL" in
+  [/$]*) INSTALL="$ac_given_INSTALL" ;;
+  *) INSTALL="$ac_dots$ac_given_INSTALL" ;;
+  esac
+
+  echo creating "$ac_file"
+  rm -f "$ac_file"
+  configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
+  case "$ac_file" in
+  *Makefile*) ac_comsub="1i\\
+# $configure_input" ;;
+  *) ac_comsub= ;;
+  esac
+
+  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+  sed -e "$ac_comsub
+s%@configure_input@%$configure_input%g
+s%@srcdir@%$srcdir%g
+s%@top_srcdir@%$top_srcdir%g
+s%@INSTALL@%$INSTALL%g
+" $ac_file_inputs | (eval "$ac_sed_cmds") > $ac_file
+fi; done
+rm -f conftest.s*
+
+# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+# NAME is the cpp macro being defined and VALUE is the value it is being given.
+#
+# ac_d sets the value in "#define NAME VALUE" lines.
+ac_dA='s%^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
+ac_dB='\([ 	][ 	]*\)[^ 	]*%\1#\2'
+ac_dC='\3'
+ac_dD='%g'
+# ac_u turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
+ac_uA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_uB='\([ 	]\)%\1#\2define\3'
+ac_uC=' '
+ac_uD='\4%g'
+# ac_e turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ac_eA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_eB='$%\1#\2define\3'
+ac_eC=' '
+ac_eD='%g'
+
+if test "${CONFIG_HEADERS+set}" != set; then
+EOF
+cat >> $CONFIG_STATUS <<EOF
+  CONFIG_HEADERS="config.h"
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+fi
+for ac_file in .. $CONFIG_HEADERS; do if test "x$ac_file" != x..; then
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case "$ac_file" in
+  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+  *) ac_file_in="${ac_file}.in" ;;
+  esac
+
+  echo creating $ac_file
+
+  rm -f conftest.frag conftest.in conftest.out
+  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+  cat $ac_file_inputs > conftest.in
+
+EOF
+
+# Transform confdefs.h into a sed script conftest.vals that substitutes
+# the proper values into config.h.in to produce config.h.  And first:
+# Protect against being on the right side of a sed subst in config.status.
+# Protect against being in an unquoted here document in config.status.
+rm -f conftest.vals
+cat > conftest.hdr <<\EOF
+s/[\\&%]/\\&/g
+s%[\\$`]%\\&%g
+s%#define \([A-Za-z_][A-Za-z0-9_]*\) *\(.*\)%${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD}%gp
+s%ac_d%ac_u%gp
+s%ac_u%ac_e%gp
+EOF
+sed -n -f conftest.hdr confdefs.h > conftest.vals
+rm -f conftest.hdr
+
+# This sed command replaces #undef with comments.  This is necessary, for
+# example, in the case of _POSIX_SOURCE, which is predefined and required
+# on some systems where configure will not decide to define it.
+cat >> conftest.vals <<\EOF
+s%^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*%/* & */%
+EOF
+
+# Break up conftest.vals because some shells have a limit on
+# the size of here documents, and old seds have small limits too.
+
+rm -f conftest.tail
+while :
+do
+  ac_lines=`grep -c . conftest.vals`
+  # grep -c gives empty output for an empty file on some AIX systems.
+  if test -z "$ac_lines" || test "$ac_lines" -eq 0; then break; fi
+  # Write a limited-size here document to conftest.frag.
+  echo '  cat > conftest.frag <<CEOF' >> $CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.vals >> $CONFIG_STATUS
+  echo 'CEOF
+  sed -f conftest.frag conftest.in > conftest.out
+  rm -f conftest.in
+  mv conftest.out conftest.in
+' >> $CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.vals > conftest.tail
+  rm -f conftest.vals
+  mv conftest.tail conftest.vals
+done
+rm -f conftest.vals
+
+cat >> $CONFIG_STATUS <<\EOF
+  rm -f conftest.frag conftest.h
+  echo "/* $ac_file.  Generated automatically by configure.  */" > conftest.h
+  cat conftest.in >> conftest.h
+  rm -f conftest.in
+  if cmp -s $ac_file conftest.h 2>/dev/null; then
+    echo "$ac_file is unchanged"
+    rm -f conftest.h
+  else
+    # Remove last slash and all that follows it.  Not all systems have dirname.
+      ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+      if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+      # The file is in a subdirectory.
+      test ! -d "$ac_dir" && mkdir "$ac_dir"
+    fi
+    rm -f $ac_file
+    mv conftest.h $ac_file
+  fi
+fi; done
+
+EOF
+cat >> $CONFIG_STATUS <<EOF
+
+
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+test -z "$CONFIG_HEADERS" || echo timestamp > stamp-h
+test -z "$CONFIG_HEADERS" || echo timestamp > stamp-h
+exit 0
+EOF
+chmod +x $CONFIG_STATUS
+rm -fr confdefs* $ac_clean_files
+test "$no_create" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1
+
diff --git a/pppd/plugins/radius/radiusclient/configure.in b/pppd/plugins/radius/radiusclient/configure.in
new file mode 100644
index 0000000..8f71cdb
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/configure.in
@@ -0,0 +1,189 @@
+# 
+#  $Id: configure.in,v 1.1 2002/01/22 16:03:00 dfs Exp $
+# 
+#  Copyright (C) 1996,1997 Lars Fenneberg
+# 
+#  See the file COPYRIGHT for the respective terms and conditions. 
+#  If the file is missing contact me at lf@elemental.net 
+#  and I'll send you a copy.
+# 
+# 
+
+AC_INIT(src/radlogin.c)
+AC_CANONICAL_SYSTEM
+
+case "$target" in
+	*)
+	;;
+esac
+
+AM_INIT_AUTOMAKE(radiusclient,0.3.1)
+
+LIBVERSION=0:1:0
+AC_SUBST(LIBVERSION)
+
+pkgsysconfdir=${sysconfdir}/$PACKAGE
+AC_SUBST(pkgsysconfdir)
+
+AC_PROG_CC
+
+dnl Needed for normal compile
+AC_PATH_PROG(AR, ar)
+AM_PROG_LIBTOOL
+
+dnl HAVE_SHADOW_PASSWORDS
+AC_MSG_CHECKING(whether to include shadow password support)
+AC_ARG_ENABLE(shadow,
+[  --enable-shadow         Enable shadow password support],
+[
+        AC_MSG_RESULT(yes)
+	AC_DEFINE(HAVE_SHADOW_PASSWORDS)
+	shadow_passwords=yes
+],
+[
+        AC_MSG_RESULT(no)
+	shadow_passwords=no
+]
+)
+
+dnl Checks for libraries.
+AC_CHECK_LIB(nsl, gethostbyname)
+AC_CHECK_LIB(socket, socket)
+if test "$shadow_passwords" = "yes"
+then
+	AC_CHECK_LIB(c, getspnam,:,
+		AC_CHECK_LIB(shadow, getspnam,
+		 	LIBS="$LIBS -lshadow"
+                )
+	)
+fi
+AC_CHECK_LIB(crypt, crypt)
+
+dnl Checks for header files.
+AC_HEADER_DIRENT
+AC_HEADER_STDC
+AC_CHECK_HEADERS(crypt.h signal.h sys/signal.h sys/stat.h)
+AC_CHECK_HEADERS(fcntl.h sys/fcntl.h)
+AC_CHECK_HEADERS(sys/utsname.h getopt.h unistd.h)
+AC_CHECK_HEADERS(sys/file.h termios.h sys/ioctl.h)
+if test "$shadow_passwords" = "yes"
+then
+	AC_CHECK_HEADER(shadow.h)
+fi
+
+
+dnl Checks for typedefs, structures, and compiler characteristics.
+AC_C_CONST
+AC_TYPE_OFF_T
+AC_TYPE_SIZE_T
+AC_HEADER_TIME
+AC_STRUCT_TM
+
+dnl Checks for library functions.
+AC_PROG_GCC_TRADITIONAL
+AC_FUNC_MEMCMP
+AC_FUNC_SETVBUF_REVERSED
+AC_TYPE_SIGNAL
+AC_FUNC_STRFTIME
+AC_REPLACE_FUNCS(strdup strerror strcasecmp)
+AC_CHECK_FUNCS(flock fcntl uname gethostname sysinfo getdomainname)
+AC_CHECK_FUNCS(stricmp random rand snprintf vsnprintf)
+
+if test "$ac_cv_func_uname" = 'yes'
+then
+	AC_MSG_CHECKING([for field domainname in struct utsname])
+	AC_TRY_RUN([
+	#include <sys/utsname.h>
+	
+	main(int argc, char **argv)
+	{
+		struct utsname uts;
+		uts.domainname[0] = '\0';
+	}
+	],
+	AC_MSG_RESULT(yes)
+	AC_DEFINE(HAVE_STRUCT_UTSNAME_DOMAINNAME),
+	AC_MSG_RESULT(no)
+	)
+fi
+
+AC_MSG_CHECKING([for /dev/urandom])
+if test -c /dev/urandom
+then
+	AC_MSG_RESULT(yes)
+	AC_DEFINE(HAVE_DEV_URANDOM)
+else
+	AC_MSG_RESULT(no)
+fi
+
+dnl Determine PATH setting
+echo $ac_n "using the following PATH setting for exec'ed programs... $ac_c" 1>&6
+AC_ARG_WITH(secure-path,
+[  --with-secure-path      PATH setting for exec'ed programs],
+[
+        AC_MSG_RESULT($withval)
+        RC_SECURE_PATH=$withval
+],
+[
+        AC_MSG_RESULT(/bin:/usr/bin:/usr/local/bin)
+	RC_SECURE_PATH=/bin:/usr/bin:/usr/local/bin
+]
+)
+
+dnl Checking which syslog facility to use
+AC_MSG_CHECKING(which syslog facility to use)
+AC_ARG_WITH(facility,
+[  --with-facility         Syslog facility to use],
+[
+        AC_MSG_RESULT($withval)
+        RC_LOG_FACILITY=$withval
+],
+[
+        AC_MSG_RESULT(LOG_DAEMON)
+        RC_LOG_FACILITY=LOG_DAEMON
+]
+)
+
+dnl RADIUS_116
+AC_MSG_CHECKING(whether to include Livingston's RADIUS server 1.16 kludge)
+AC_ARG_ENABLE(radius-116,
+[  --enable-radius-116     Include support for Livingston's RADIUS server 1.16],
+[
+        AC_MSG_RESULT(yes)
+	AC_DEFINE(RADIUS_116)
+	AC_MSG_WARN([!! This is a bug in Livingston's RADIUS server v1.16. There])
+	AC_MSG_WARN([!! is a patch included with radiusclient which fixes this])
+	AC_MSG_WARN([!! problem. See patches/radiusd-1.16.accounting.diff. With])
+	AC_MSG_WARN([!! the patched RADIUS server you no longer need to activate])
+	AC_MSG_WARN([!! this hack.])
+],
+[
+        AC_MSG_RESULT(no)
+]
+)
+
+dnl SCP
+AC_MSG_CHECKING(whether to add service type hints derived from username prefix)
+AC_ARG_ENABLE(scp,
+[  --enable-scp            Add service type hints derived from username prefix],
+[
+        AC_MSG_RESULT(yes)
+	AC_DEFINE(SCP)
+],
+[
+        AC_MSG_RESULT(no)
+]
+)
+
+AC_SUBST(RC_SECURE_PATH)
+AC_SUBST(RC_LOG_FACILITY)
+
+AM_CONFIG_HEADER(config.h)
+LTLIBOBJS=`echo "$LIBOBJS" | sed 's/\.o/.lo/g'`
+AC_SUBST(LTLIBOBJS)
+AC_OUTPUT([
+Makefile
+include/Makefile lib/Makefile src/Makefile man/Makefile etc/Makefile
+doc/Makefile patches/Makefile
+login.radius/Makefile login.radius/migs/Makefile
+], [test -z "$CONFIG_HEADERS" || echo timestamp > stamp-h])
diff --git a/pppd/plugins/radius/radiusclient/doc/Makefile.am b/pppd/plugins/radius/radiusclient/doc/Makefile.am
new file mode 100644
index 0000000..2c4ae99
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/doc/Makefile.am
@@ -0,0 +1,15 @@
+#
+# $Id: Makefile.am,v 1.1 2002/01/22 16:03:01 dfs Exp $
+#
+# Copyright (C) 1997 Lars Fenneberg
+#
+# See the file COPYRIGHT for the respective terms and conditions. 
+# If the file is missing contact me at lf@elemental.net 
+# and I'll send you a copy.
+#
+
+AUTOMAKE_OPTIONS = foreign
+
+CLEANFILES = *~
+
+EXTRA_DIST = instop.html
diff --git a/pppd/plugins/radius/radiusclient/doc/Makefile.in b/pppd/plugins/radius/radiusclient/doc/Makefile.in
new file mode 100644
index 0000000..4537121
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/doc/Makefile.in
@@ -0,0 +1,187 @@
+# Makefile.in generated automatically by automake 1.3 from Makefile.am
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+#
+# $Id: Makefile.in,v 1.1 2002/01/22 16:03:01 dfs Exp $
+#
+# Copyright (C) 1997 Lars Fenneberg
+#
+# See the file COPYRIGHT for the respective terms and conditions. 
+# If the file is missing contact me at lf@elemental.net 
+# and I'll send you a copy.
+#
+
+
+SHELL = /bin/sh
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+sbindir = @sbindir@
+libexecdir = @libexecdir@
+datadir = @datadir@
+sysconfdir = @sysconfdir@
+sharedstatedir = @sharedstatedir@
+localstatedir = @localstatedir@
+libdir = @libdir@
+infodir = @infodir@
+mandir = @mandir@
+includedir = @includedir@
+oldincludedir = /usr/include
+
+DISTDIR =
+
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+
+top_builddir = ..
+
+ACLOCAL = @ACLOCAL@
+AUTOCONF = @AUTOCONF@
+AUTOMAKE = @AUTOMAKE@
+AUTOHEADER = @AUTOHEADER@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+transform = @program_transform_name@
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_alias = @build_alias@
+build_triplet = @build@
+host_alias = @host_alias@
+host_triplet = @host@
+target_alias = @target_alias@
+target_triplet = @target@
+AR = @AR@
+CC = @CC@
+LD = @LD@
+LIBTOOL = @LIBTOOL@
+LIBVERSION = @LIBVERSION@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+NM = @NM@
+PACKAGE = @PACKAGE@
+RANLIB = @RANLIB@
+RC_LOG_FACILITY = @RC_LOG_FACILITY@
+RC_SECURE_PATH = @RC_SECURE_PATH@
+VERSION = @VERSION@
+pkgsysconfdir = @pkgsysconfdir@
+
+AUTOMAKE_OPTIONS = foreign
+
+CLEANFILES = *~
+
+EXTRA_DIST = instop.html
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = ../config.h
+CONFIG_CLEAN_FILES = 
+DIST_COMMON =  Makefile.am Makefile.in
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = tar
+GZIP = --best
+all: Makefile
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && $(AUTOMAKE) --foreign --include-deps doc/Makefile
+
+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+tags: TAGS
+TAGS:
+
+
+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
+
+subdir = doc
+
+distdir: $(DISTFILES)
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  test -f $(distdir)/$$file \
+	  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	  || cp -p $$d/$$file $(distdir)/$$file; \
+	done
+info:
+dvi:
+check: all
+	$(MAKE)
+installcheck:
+install-exec: 
+	@$(NORMAL_INSTALL)
+
+install-data: 
+	@$(NORMAL_INSTALL)
+
+install: install-exec install-data all
+	@:
+
+uninstall: 
+
+install-strip:
+	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install
+installdirs:
+
+
+mostlyclean-generic:
+	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-rm -f Makefile $(DISTCLEANFILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+mostlyclean:  mostlyclean-generic
+
+clean:  clean-generic mostlyclean
+
+distclean:  distclean-generic clean
+	-rm -f config.status
+	-rm -f libtool
+
+maintainer-clean:  maintainer-clean-generic distclean
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+.PHONY: tags distdir info dvi installcheck install-exec install-data \
+install uninstall all installdirs mostlyclean-generic distclean-generic \
+clean-generic maintainer-clean-generic clean mostlyclean distclean \
+maintainer-clean
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/pppd/plugins/radius/radiusclient/doc/instop.html b/pppd/plugins/radius/radiusclient/doc/instop.html
new file mode 100644
index 0000000..0869e57
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/doc/instop.html
@@ -0,0 +1,451 @@
+<html>
+<head>
+<title>
+Radiusclient - Installation and Operation Guide
+</title>
+</head>
+<body>
+
+<h1>
+<center>
+<i>
+Radiusclient - Installation and Operation Guide
+</i>
+</center>
+</h1>
+
+<hr size=8>
+
+<!--------------------------------------------------------------------------->
+<h2>
+Table of contents
+</h2>
+
+<ul>
+<li><a href="#introduction">Introduction</a>
+<li><a href="#principles">Principles of operation</a>
+<li><a href="#installation">Installation</a>
+<li><a href="#availability">Availabiliy</a>
+<li><a href="#credits">Credits</a>
+<li><a href="#copyright">Copyright</a>
+<li><a href="#contacting">Contacting the author</a>
+<li><a href="#appendixa">Appendix A: Command line flags</a>
+</ul>
+
+
+<!--------------------------------------------------------------------------->
+<h2>
+<a name="introduction">
+Introduction
+</a>
+</h2>
+	
+	Radiusclient is a /bin/login replacement which gets called by a
+	getty to log in a user and to setup the user's login environment.
+	<br>
+	Normal login programs just check the login name and password which the
+	user entered against the local password file (/etc/passwd, /etc/shadow).
+	In contrast to that Radiusclient also uses the RADIUS protocol to
+	authenticate the user.
+
+	<p>
+
+	RADIUS stands for <i>R</i>emote <i>A</i>uthentication <i>D</i>ial
+	<i>In</i> <i>U</i>ser <i>S</i>ervice and is a protocol for carrying
+	authentication, authorization, and configuration information between
+	a Network Access Server (NAS) which desires to authenticate its
+	links and a shared Authentication Server.<br> The protocol
+	originally was designed by the well known terminal server
+	manufacturer Livingston for use with their Portmaster series of
+	terminal servers.  Since then it has been implemented by a lot of
+	other vendors and it is also on it's way to become a Internet
+	Standard.
+
+<!--------------------------------------------------------------------------->
+<h2>
+<a name="principles">
+Principles of operation
+</a>
+</h2>
+
+	If the main program of Radiusclient which is called <i>radlogin</i> gets
+	invoked by your systems's getty, it behaves like the normal login
+	program to the user.
+	
+	<p>
+
+	First it asks the user for his loginname (if not supplied by getty)
+	and his password.
+	
+	<p>
+	
+	Then it tries to find the login name either through a RADIUS server
+	query or in the local passwd file or through both methods.
+	
+	<p>
+	
+	If the user is authenticated locally <i>radlogin</i> calls the local login
+	program to spawn a login enviroment.
+	
+	<p>
+	
+	If the user is authenticated via RADIUS <i>radlogin</i> calls a special other
+	login program which gets the information that was passed from the RADIUS 
+	server in enviroment variables.
+	
+	<p>
+	
+	In this special login program you can now either start a telnet/rlogin
+	session or start up SLIP/CSLIP or even PPP based on the information from
+	the RADIUS server. Furthermore you can send accounting information to a
+	RADIUS accouting server via a program called radacct which is also
+	part of Radiusclient.
+
+<!--------------------------------------------------------------------------->
+<h2>
+<a name="installation">
+Installation
+</a>
+</h2>
+	
+	Get the Radiusclient package from the places mentioned 
+	<a href="#availability">below</a>.
+
+	<p>
+
+	Then unpack it in a directory which you normally use for keeping your
+	source code. For example do:
+
+	<p>
+
+	<pre>
+	cd /usr/src
+	gzip -dc radiusclient-x.x.tar.gz | tar xvvf -
+	</pre>
+
+	<p>
+
+	You now should have a directory called radiusclient-x.x in which all the
+	source code of Radiusclient is stored.
+
+	<p>
+
+	First run configure --help to see if you need to enable any options.
+	Then configure the sources by calling configure with the
+	appropriate options.
+
+	<p>
+
+	Have a look at include/messages.h if you'd like to change some
+	of the messages there. But normally you shouldn't.  
+
+	<p>
+
+	Executing "make" builds the executables.
+
+	<p>
+
+	Executing "make install" will install the executables and example
+	versions of all the needed config and data files. Be careful
+	the installation process will <b>overwrite</b> existing files
+	without asking you.
+	Try "make -n install" to see which file gets were if you're
+	unsure.
+
+	<p>
+
+	The installation procedure will only install a dummy login.radius
+	script which just outputs all RADIUS_* environment variables and
+	then exits.
+
+	<p>
+
+	You need to write your own login.radius if you want that the script
+	does something useful. See the login.radius directory for example
+	scripts. 
+
+	<p>
+
+	You <b>will</b> have to look into radiusclient.conf and edit it.
+
+	<p>
+
+	Add the following two line to /etc/services if you don't
+	already have them:
+
+	<p>
+
+	<pre>
+	radius          1645/udp	# RADIUS access requests
+	radacct         1646/udp	# RADIUS accounting requests
+	</pre>
+	<p>
+
+	Get your getty to execute <i>radlogin</i> instead of the normal login
+	process. The method of how to do this varies from getty to getty.
+
+	<p>
+
+	<ul>	
+		<li>If you're using getty_ps you can set the LOGIN directive in the 
+			respective config file.
+
+		<p>	 
+
+		<li>agetty has a command line option (-l) which allows
+			you to specify an alternate login program, i.e. <i>radlogin</i>.
+		
+		<p>
+		
+		<li>With mgetty you add the following line to your login.cfg file:
+		
+		<p>
+
+		<pre>
+	*       -       -       <path>/radlogin @
+		</pre>
+
+	</ul>
+
+	I suggest you use mgetty or getty_ps, mgetty even has a nice
+	automatic PPP detection feature, which can be useful.
+
+<!--------------------------------------------------------------------------->
+<h2>
+<a name="availability">
+Availability
+</a>
+</h2>
+	
+	This program is avaiable from <a href="ftp://ftp.cityline.net/pub/radiusclient/">
+	ftp.cityline.net</a> in the directory
+	<a href="ftp://ftp.cityline.net/pub/radiusclient/">/pub/radiusclient</a>.
+	<br>
+	Download the version with the largest version number, older version are
+	only kept for reference.
+
+
+<!--------------------------------------------------------------------------->
+<h2>
+<a name="credits">
+Credits
+</a>
+</h2>
+
+	My thanks go to all the people who have helped me in one or another
+	way with the development of radiusclient but especially to:
+
+	<p>
+
+	<center>
+	<table cellpadding=0 cellspacing=0 width="90%" border=0>
+	<tr>
+		<td>
+		<a href="mailto:map@iphil.net">
+		Miguel A.L. Paraz &lt;map@iphil.net&gt;
+		</a>
+		</td>
+	</tr>
+	<tr>
+		<td>
+		<a href="mailto:gody@master.slon.net">
+		Matjaz Godec &lt;gody@master.slon.net&gt;
+		</a>
+		</td>
+	</tr>
+	<tr>
+		<td>
+		<a href="mailto:mla@gams.co.at">
+		Michael Lausch &lt;mla@gams.co.at&gt;
+		</a>
+		</td>
+	</tr>
+	</table>
+	</center>
+
+<!--------------------------------------------------------------------------->
+<h2>
+<a name="copyright">
+Copyright
+</a>
+</h2>
+
+	Read the file COPYRIGHT in the top directory of Radiusclient for the
+	respective copyrights.
+
+	<p>
+
+	If you like the Radiusclient software very much and/or are using
+	it on a production machine please send my a postcard. My postal
+	address is:
+
+	<p>
+
+	<center>
+	<table cellpadding=0 cellspacing=0 width="90%" border=0>
+	<tr>
+	<td>
+		Lars Fenneberg<br>
+		Boettgerstrasse 29<br>
+		22851 Norderstedt<br>
+		Germany<br>
+	</td>
+	</tr>
+	</table>
+	</center>
+
+<!--------------------------------------------------------------------------->
+<h2>
+<a name="contacting">
+Contacting the author
+</a>
+</h2>
+
+	Send your comments, suggestions, bug reports and patches to
+	<a href="mailto:lf@elemental.net">
+	Lars Fenneberg <nobr>&lt;lf@elemental.net&gt;</nobr></a>.
+
+<!--------------------------------------------------------------------------->
+<h2>
+<a name="appendixa">
+Appendix A: Command line flags
+</a>
+</h2>
+
+<center>
+<table cellpadding=0 cellspacing=10 width="95%" border=0>
+
+
+<tr>
+<td>
+
+<table border=2 width=100%>
+<tr>
+	<th colspan=2>
+	radlogin
+	</th>
+</tr>
+<tr>
+	<td>
+		-f
+	</td>
+	<td>
+		Path to an alternative configuration file
+	</td>
+</tr>
+<tr>
+	<td>
+		-i
+	</td>
+	<td>
+		File name of the terminal used to determine what to send in
+		the NAS-Port attribute. Normally the tty of stdin is used.
+	</td>
+</tr>
+<tr>
+	<td>
+		-n
+	</td>
+	<td>
+		Disable display if the radlogin issue file. This option is set
+		by default if radlogin is called with an argument.
+	</td>
+</tr>
+<tr>
+	<td>
+		-V
+	</td>
+	<td>
+		Display version information
+	</td>
+</tr>
+<tr>
+	<td>
+		-h
+	</td>
+	<td>
+		Display usage information
+	</td>
+</tr>
+</table>
+</td>
+</tr>
+
+<tr>
+<td>
+
+<table border=2 width=100%>
+<tr>
+	<th colspan=2>
+	radacct
+	</th>
+</tr>
+<tr>
+	<td>
+		-i
+	</td>
+	<td>
+		File name of the terminal used to determine what to send in
+		the NAS-Port attribute. Normally the tty of stdout is used.
+	</td>
+</tr>
+<tr>
+	<td>
+		-V
+	</td>
+	<td>
+		Display version information
+	</td>
+</tr>
+<tr>
+	<td>
+		-h
+	</td>
+	<td>
+		Display usage information
+	</td>
+</tr>
+</table>
+</td>
+</tr>
+
+<tr>
+<td>
+
+<table border=2 width=100%>
+<tr>
+	<th colspan=2>
+	radstatus
+	</th>
+</tr>
+<tr>
+	<td>
+		-V
+	</td>
+	<td>
+		Display version information
+	</td>
+</tr>
+<tr>
+	<td>
+		-h
+	</td>
+	<td>
+		Display usage information
+	</td>
+</tr>
+</table>
+</td>
+</tr>
+
+</table>
+</center>
+
+<p>
+
+<hr size=16>
+<br>
+Last changed: 7/19/98<br>
+Copyright &copy; 1996,1997,1998, Lars Fenneberg, lf@elemental.net<br>
+</body>
+</html>
diff --git a/pppd/plugins/radius/radiusclient/etc/Makefile.am b/pppd/plugins/radius/radiusclient/etc/Makefile.am
new file mode 100644
index 0000000..30c1602
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/etc/Makefile.am
@@ -0,0 +1,34 @@
+#
+# $Id: Makefile.am,v 1.1 2002/01/22 16:03:01 dfs Exp $
+#
+# Copyright (C) 1997,1998 Lars Fenneberg
+#
+# See the file COPYRIGHT for the respective terms and conditions. 
+# If the file is missing contact me at lf@elemental.net 
+# and I'll send you a copy.
+#
+
+AUTOMAKE_OPTIONS = foreign
+
+CLEANFILES = *~ radiusclient.conf
+
+sbindir = @sbindir@
+pkgsysconfdir = @pkgsysconfdir@
+pkgsysconf_DATA = issue port-id-map radiusclient.conf \
+	dictionary dictionary.ascend dictionary.compat dictionary.merit
+
+EXTRA_DIST = issue port-id-map dictionary dictionary.ascend \
+	dictionary.compat dictionary.merit servers radiusclient.conf.in
+
+radiusclient.conf: radiusclient.conf.in
+	sed -e 's|@sbin''dir@|$(sbindir)|g' \
+	    -e 's|@pkgsysconf''dir@|$(pkgsysconfdir)|g' \
+	    <$(srcdir)/radiusclient.conf.in >radiusclient.conf
+
+install-data-local: servers
+	$(mkinstalldirs) $(pkgsysconfdir); \
+        echo " $(INSTALL) -m600 $(srcdir)/servers $(pkgsysconfdir)/servers"; \
+        $(INSTALL) -m600 $(srcdir)/servers $(pkgsysconfdir)/servers
+
+uninstall-local:
+	rm -f $(pkgsysconfdir)/servers
diff --git a/pppd/plugins/radius/radiusclient/etc/Makefile.in b/pppd/plugins/radius/radiusclient/etc/Makefile.in
new file mode 100644
index 0000000..088921b
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/etc/Makefile.in
@@ -0,0 +1,226 @@
+# Makefile.in generated automatically by automake 1.3 from Makefile.am
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+#
+# $Id: Makefile.in,v 1.1 2002/01/22 16:03:01 dfs Exp $
+#
+# Copyright (C) 1997,1998 Lars Fenneberg
+#
+# See the file COPYRIGHT for the respective terms and conditions. 
+# If the file is missing contact me at lf@elemental.net 
+# and I'll send you a copy.
+#
+
+
+SHELL = /bin/sh
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+libexecdir = @libexecdir@
+datadir = @datadir@
+sysconfdir = @sysconfdir@
+sharedstatedir = @sharedstatedir@
+localstatedir = @localstatedir@
+libdir = @libdir@
+infodir = @infodir@
+mandir = @mandir@
+includedir = @includedir@
+oldincludedir = /usr/include
+
+DISTDIR =
+
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+
+top_builddir = ..
+
+ACLOCAL = @ACLOCAL@
+AUTOCONF = @AUTOCONF@
+AUTOMAKE = @AUTOMAKE@
+AUTOHEADER = @AUTOHEADER@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+transform = @program_transform_name@
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_alias = @build_alias@
+build_triplet = @build@
+host_alias = @host_alias@
+host_triplet = @host@
+target_alias = @target_alias@
+target_triplet = @target@
+AR = @AR@
+CC = @CC@
+LD = @LD@
+LIBTOOL = @LIBTOOL@
+LIBVERSION = @LIBVERSION@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+NM = @NM@
+PACKAGE = @PACKAGE@
+RANLIB = @RANLIB@
+RC_LOG_FACILITY = @RC_LOG_FACILITY@
+RC_SECURE_PATH = @RC_SECURE_PATH@
+VERSION = @VERSION@
+
+AUTOMAKE_OPTIONS = foreign
+
+CLEANFILES = *~ radiusclient.conf
+
+sbindir = @sbindir@
+pkgsysconfdir = @pkgsysconfdir@
+pkgsysconf_DATA = issue port-id-map radiusclient.conf \
+	dictionary dictionary.ascend dictionary.compat dictionary.merit
+
+EXTRA_DIST = issue port-id-map dictionary dictionary.ascend \
+	dictionary.compat dictionary.merit servers radiusclient.conf.in
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = ../config.h
+CONFIG_CLEAN_FILES = 
+DATA =  $(pkgsysconf_DATA)
+
+DIST_COMMON =  Makefile.am Makefile.in
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = tar
+GZIP = --best
+all: Makefile $(DATA)
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && $(AUTOMAKE) --foreign --include-deps etc/Makefile
+
+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+
+install-pkgsysconfDATA: $(pkgsysconf_DATA)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(pkgsysconfdir)
+	@list='$(pkgsysconf_DATA)'; for p in $$list; do \
+	  if test -f $(srcdir)/$$p; then \
+	    echo " $(INSTALL_DATA) $(srcdir)/$$p $(DESTDIR)$(pkgsysconfdir)/$$p"; \
+	    $(INSTALL_DATA) $(srcdir)/$$p $(DESTDIR)$(pkgsysconfdir)/$$p; \
+	  else if test -f $$p; then \
+	    echo " $(INSTALL_DATA) $$p $(DESTDIR)$(pkgsysconfdir)/$$p"; \
+	    $(INSTALL_DATA) $$p $(DESTDIR)$(pkgsysconfdir)/$$p; \
+	  fi; fi; \
+	done
+
+uninstall-pkgsysconfDATA:
+	@$(NORMAL_UNINSTALL)
+	list='$(pkgsysconf_DATA)'; for p in $$list; do \
+	  rm -f $(DESTDIR)$(pkgsysconfdir)/$$p; \
+	done
+tags: TAGS
+TAGS:
+
+
+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
+
+subdir = etc
+
+distdir: $(DISTFILES)
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  test -f $(distdir)/$$file \
+	  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	  || cp -p $$d/$$file $(distdir)/$$file; \
+	done
+info:
+dvi:
+check: all
+	$(MAKE)
+installcheck:
+install-exec: 
+	@$(NORMAL_INSTALL)
+
+install-data: install-pkgsysconfDATA install-data-local
+	@$(NORMAL_INSTALL)
+
+install: install-exec install-data all
+	@:
+
+uninstall: uninstall-pkgsysconfDATA uninstall-local
+
+install-strip:
+	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install
+installdirs:
+	$(mkinstalldirs)  $(DATADIR)$(pkgsysconfdir)
+
+
+mostlyclean-generic:
+	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-rm -f Makefile $(DISTCLEANFILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+mostlyclean:  mostlyclean-generic
+
+clean:  clean-generic mostlyclean
+
+distclean:  distclean-generic clean
+	-rm -f config.status
+	-rm -f libtool
+
+maintainer-clean:  maintainer-clean-generic distclean
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+.PHONY: uninstall-pkgsysconfDATA install-pkgsysconfDATA tags distdir \
+info dvi installcheck install-exec install-data install uninstall all \
+installdirs mostlyclean-generic distclean-generic clean-generic \
+maintainer-clean-generic clean mostlyclean distclean maintainer-clean
+
+
+radiusclient.conf: radiusclient.conf.in
+	sed -e 's|@sbin''dir@|$(sbindir)|g' \
+	    -e 's|@pkgsysconf''dir@|$(pkgsysconfdir)|g' \
+	    <$(srcdir)/radiusclient.conf.in >radiusclient.conf
+
+install-data-local: servers
+	$(mkinstalldirs) $(pkgsysconfdir); \
+        echo " $(INSTALL) -m600 $(srcdir)/servers $(pkgsysconfdir)/servers"; \
+        $(INSTALL) -m600 $(srcdir)/servers $(pkgsysconfdir)/servers
+
+uninstall-local:
+	rm -f $(pkgsysconfdir)/servers
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/pppd/plugins/radius/radiusclient/etc/dictionary b/pppd/plugins/radius/radiusclient/etc/dictionary
new file mode 100644
index 0000000..b384607
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/etc/dictionary
@@ -0,0 +1,229 @@
+#
+# Updated 97/06/13 to livingston-radius-2.01 miquels@cistron.nl
+#
+#	This file contains dictionary translations for parsing
+#	requests and generating responses.  All transactions are
+#	composed of Attribute/Value Pairs.  The value of each attribute
+#	is specified as one of 4 data types.  Valid data types are:
+#
+#	string - 0-253 octets
+#	ipaddr - 4 octets in network byte order
+#	integer - 32 bit value in big endian order (high byte first)
+#	date - 32 bit value in big endian order - seconds since
+#					00:00:00 GMT,  Jan.  1,  1970
+#
+#	Enumerated values are stored in the user file with dictionary
+#	VALUE translations for easy administration.
+#
+#	Example:
+#
+#	ATTRIBUTE	  VALUE
+#	---------------   -----
+#	Framed-Protocol = PPP
+#	7		= 1	(integer encoding)
+#
+
+# The dictionary format now supports vendor-specific attributes.
+# Vendors are introduced like this:
+#
+#	VENDOR vendor_name vendor_number
+#
+# For example:
+#
+#	VENDOR RoaringPenguin 10055
+#
+# Vendor-specific attributes have a fifth field with the name of the
+# vendor.  For example:
+#
+#       ATTRIBUTE RP-Upstream-Speed-Limit 1 integer RoaringPenguin
+#
+# introduces a Roaring Penguin vendor-specific attribbute with name
+# RP-Upstream-Speed-Limit, number 1, type integer and vendor RoaringPenguin.
+
+#
+#	Following are the proper new names. Use these.
+#
+ATTRIBUTE	User-Name		1	string
+ATTRIBUTE	Password		2	string
+ATTRIBUTE	CHAP-Password		3	string
+ATTRIBUTE	NAS-IP-Address		4	ipaddr
+ATTRIBUTE	NAS-Port-Id		5	integer
+ATTRIBUTE	Service-Type		6	integer
+ATTRIBUTE	Framed-Protocol		7	integer
+ATTRIBUTE	Framed-IP-Address	8	ipaddr
+ATTRIBUTE	Framed-IP-Netmask	9	ipaddr
+ATTRIBUTE	Framed-Routing		10	integer
+ATTRIBUTE	Filter-Id		11	string
+ATTRIBUTE	Framed-MTU		12	integer
+ATTRIBUTE	Framed-Compression	13	integer
+ATTRIBUTE	Login-IP-Host		14	ipaddr
+ATTRIBUTE	Login-Service		15	integer
+ATTRIBUTE	Login-TCP-Port		16	integer
+ATTRIBUTE	Reply-Message		18	string
+ATTRIBUTE	Callback-Number		19	string
+ATTRIBUTE	Callback-Id		20	string
+ATTRIBUTE	Framed-Route		22	string
+ATTRIBUTE	Framed-IPX-Network	23	ipaddr
+ATTRIBUTE	State			24	string
+ATTRIBUTE	Session-Timeout		27	integer
+ATTRIBUTE	Idle-Timeout		28	integer
+ATTRIBUTE	Termination-Action	29	integer
+ATTRIBUTE	Called-Station-Id	30	string
+ATTRIBUTE	Calling-Station-Id	31	string
+ATTRIBUTE	Acct-Status-Type	40	integer
+ATTRIBUTE	Acct-Delay-Time		41	integer
+ATTRIBUTE	Acct-Input-Octets	42	integer
+ATTRIBUTE	Acct-Output-Octets	43	integer
+ATTRIBUTE	Acct-Session-Id		44	string
+ATTRIBUTE	Acct-Authentic		45	integer
+ATTRIBUTE	Acct-Session-Time	46	integer
+ATTRIBUTE	Acct-Terminate-Cause	49	integer
+ATTRIBUTE	NAS-Port-Type		61	integer
+ATTRIBUTE	Port-Limit		62	integer
+ATTRIBUTE	Connect-Info		77	string
+
+#
+#	Experimental Non Protocol Attributes used by Cistron-Radiusd
+#
+ATTRIBUTE	Huntgroup-Name		221	string
+ATTRIBUTE	User-Category		1029	string
+ATTRIBUTE	Group-Name		1030	string
+ATTRIBUTE	Simultaneous-Use	1034	integer
+ATTRIBUTE	Strip-User-Name		1035	integer
+ATTRIBUTE	Fall-Through		1036	integer
+ATTRIBUTE	Add-Port-To-IP-Address	1037	integer
+ATTRIBUTE	Exec-Program		1038	string
+ATTRIBUTE	Exec-Program-Wait	1039	string
+ATTRIBUTE	Hint			1040	string
+
+#
+#	Non-Protocol Attributes
+#	These attributes are used internally by the server
+#
+ATTRIBUTE	Expiration		  21	date
+ATTRIBUTE	Auth-Type		1000	integer
+ATTRIBUTE	Menu			1001	string
+ATTRIBUTE	Termination-Menu	1002	string
+ATTRIBUTE	Prefix			1003	string
+ATTRIBUTE	Suffix			1004	string
+ATTRIBUTE	Group			1005	string
+ATTRIBUTE	Crypt-Password		1006	string
+ATTRIBUTE	Connect-Rate		1007	integer
+
+#
+#	Integer Translations
+#
+
+#	User Types
+
+VALUE		Service-Type		Login-User		1
+VALUE		Service-Type		Framed-User		2
+VALUE		Service-Type		Callback-Login-User	3
+VALUE		Service-Type		Callback-Framed-User	4
+VALUE		Service-Type		Outbound-User		5
+VALUE		Service-Type		Administrative-User	6
+VALUE		Service-Type		NAS-Prompt-User		7
+
+#	Framed Protocols
+
+VALUE		Framed-Protocol		PPP			1
+VALUE		Framed-Protocol		SLIP			2
+
+#	Framed Routing Values
+
+VALUE		Framed-Routing		None			0
+VALUE		Framed-Routing		Broadcast		1
+VALUE		Framed-Routing		Listen			2
+VALUE		Framed-Routing		Broadcast-Listen	3
+
+#	Framed Compression Types
+
+VALUE		Framed-Compression	None			0
+VALUE		Framed-Compression	Van-Jacobson-TCP-IP	1
+
+#	Login Services
+
+VALUE		Login-Service		Telnet			0
+VALUE		Login-Service		Rlogin			1
+VALUE		Login-Service		TCP-Clear		2
+VALUE		Login-Service		PortMaster		3
+
+#	Status Types
+
+VALUE		Acct-Status-Type	Start			1
+VALUE		Acct-Status-Type	Stop			2
+VALUE		Acct-Status-Type	Accounting-On		7
+VALUE		Acct-Status-Type	Accounting-Off		8
+
+#	Authentication Types
+
+VALUE		Acct-Authentic		RADIUS			1
+VALUE		Acct-Authentic		Local			2
+VALUE		Acct-Authentic		PowerLink128		100
+
+#	Termination Options
+
+VALUE		Termination-Action	Default			0
+VALUE		Termination-Action	RADIUS-Request		1
+
+#	NAS Port Types, available in 3.3.1 and later
+
+VALUE		NAS-Port-Type		Async			0
+VALUE		NAS-Port-Type		Sync			1
+VALUE		NAS-Port-Type		ISDN			2
+VALUE		NAS-Port-Type		ISDN-V120		3
+VALUE		NAS-Port-Type		ISDN-V110		4
+
+#	Acct Terminate Causes, available in 3.3.2 and later
+
+VALUE           Acct-Terminate-Cause    User-Request            1
+VALUE           Acct-Terminate-Cause    Lost-Carrier            2
+VALUE           Acct-Terminate-Cause    Lost-Service            3
+VALUE           Acct-Terminate-Cause    Idle-Timeout            4
+VALUE           Acct-Terminate-Cause    Session-Timeout         5
+VALUE           Acct-Terminate-Cause    Admin-Reset             6
+VALUE           Acct-Terminate-Cause    Admin-Reboot            7
+VALUE           Acct-Terminate-Cause    Port-Error              8
+VALUE           Acct-Terminate-Cause    NAS-Error               9
+VALUE           Acct-Terminate-Cause    NAS-Request             10
+VALUE           Acct-Terminate-Cause    NAS-Reboot              11
+VALUE           Acct-Terminate-Cause    Port-Unneeded           12
+VALUE           Acct-Terminate-Cause    Port-Preempted          13
+VALUE           Acct-Terminate-Cause    Port-Suspended          14
+VALUE           Acct-Terminate-Cause    Service-Unavailable     15
+VALUE           Acct-Terminate-Cause    Callback                16
+VALUE           Acct-Terminate-Cause    User-Error              17
+VALUE           Acct-Terminate-Cause    Host-Request            18
+
+#
+#	Non-Protocol Integer Translations
+#
+
+VALUE		Auth-Type		Local			0
+VALUE		Auth-Type		System			1
+VALUE		Auth-Type		SecurID			2
+VALUE		Auth-Type		Crypt-Local		3
+VALUE		Auth-Type		Reject			4
+
+#
+#	Cistron extensions
+#
+VALUE		Auth-Type		Pam			253
+VALUE		Auth-Type		None			254
+
+#
+#	Experimental Non-Protocol Integer Translations for Cistron-Radiusd
+#
+VALUE		Fall-Through		No			0
+VALUE		Fall-Through		Yes			1
+VALUE		Add-Port-To-IP-Address	No			0
+VALUE		Add-Port-To-IP-Address	Yes			1
+
+#
+#	Configuration Values
+#	uncomment these two lines to turn account expiration on
+#
+
+#VALUE		Server-Config		Password-Expiration	30
+#VALUE		Server-Config		Password-Warning	5
+
diff --git a/pppd/plugins/radius/radiusclient/etc/dictionary.ascend b/pppd/plugins/radius/radiusclient/etc/dictionary.ascend
new file mode 100644
index 0000000..f9f9bdc
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/etc/dictionary.ascend
@@ -0,0 +1,295 @@
+#
+# Ascend dictionary.
+#
+#
+# Version:	1.00  21-Jul-1997  Jens Glaser <jens@regio.net>
+#
+
+
+#
+#	Ascend specific extensions
+#	Used by ASCEND MAX/Pipeline products
+#
+ATTRIBUTE	Ascend-FCP-Parameter		119	string
+ATTRIBUTE	Ascend-Modem-PortNo		120	integer
+ATTRIBUTE	Ascend-Modem-SlotNo		121	integer
+ATTRIBUTE	Ascend-Modem-ShelfNo		122	integer
+ATTRIBUTE	Ascend-Call-Attempt-Limit	123	integer
+ATTRIBUTE	Ascend-Call-Block-Duration	124	integer
+ATTRIBUTE	Ascend-Maximum-Call-Duration	125	integer
+ATTRIBUTE	Ascend-Temporary-Rtes		126	integer
+ATTRIBUTE       Tunneling-Protocol              127     integer
+ATTRIBUTE       Ascend-Shared-Profile-Enable    128     integer
+ATTRIBUTE	Ascend-Primary-Home-Agent	129	string
+ATTRIBUTE	Ascend-Secondary-Home-Agent	130	string
+ATTRIBUTE	Ascend-Dialout-Allowed		131	integer
+ATTRIBUTE	Ascend-Client-Gateway		132	ipaddr
+ATTRIBUTE	Ascend-BACP-Enable		133	integer
+ATTRIBUTE	Ascend-DHCP-Maximum-Leases	134	integer
+ATTRIBUTE	Ascend-Client-Primary-DNS	135	ipaddr
+ATTRIBUTE	Ascend-Client-Secondary-DNS	136	ipaddr
+ATTRIBUTE	Ascend-Client-Assign-DNS	137	integer
+ATTRIBUTE	Ascend-User-Acct-Type		138	integer
+ATTRIBUTE	Ascend-User-Acct-Host		139	ipaddr
+ATTRIBUTE	Ascend-User-Acct-Port		140	integer
+ATTRIBUTE	Ascend-User-Acct-Key		141	string
+ATTRIBUTE	Ascend-User-Acct-Base		142	integer
+ATTRIBUTE	Ascend-User-Acct-Time		143	integer
+ATTRIBUTE	Ascend-Assign-IP-Client		144	ipaddr
+ATTRIBUTE	Ascend-Assign-IP-Server		145	ipaddr
+ATTRIBUTE	Ascend-Assign-IP-Global-Pool	146	string
+ATTRIBUTE	Ascend-DHCP-Reply		147	integer
+ATTRIBUTE	Ascend-DHCP-Pool-Number		148	integer
+ATTRIBUTE	Ascend-Expect-Callback		149	integer
+ATTRIBUTE	Ascend-Event-Type		150	integer
+ATTRIBUTE	Ascend-Session-Svr-Key		151	string
+ATTRIBUTE	Ascend-Multicast-Rate-Limit	152	integer
+ATTRIBUTE	Ascend-IF-Netmask		153	ipaddr
+ATTRIBUTE	Ascend-Remote-Addr		154	ipaddr
+ATTRIBUTE	Ascend-Multicast-Client		155	integer
+ATTRIBUTE	Ascend-FR-Circuit-Name		156	string
+ATTRIBUTE	Ascend-FR-LinkUp		157	integer
+ATTRIBUTE	Ascend-FR-Nailed-Grp		158	integer
+ATTRIBUTE	Ascend-FR-Type			159	integer
+ATTRIBUTE	Ascend-FR-Link-Mgt		160	integer
+ATTRIBUTE	Ascend-FR-N391			161	integer
+ATTRIBUTE	Ascend-FR-DCE-N392		162	integer
+ATTRIBUTE	Ascend-FR-DTE-N392		163	integer
+ATTRIBUTE	Ascend-FR-DCE-N393		164	integer
+ATTRIBUTE	Ascend-FR-DTE-N393		165	integer
+ATTRIBUTE	Ascend-FR-T391			166	integer
+ATTRIBUTE	Ascend-FR-T392			167	integer
+ATTRIBUTE	Ascend-Bridge-Address  	 	168	string
+ATTRIBUTE       Ascend-TS-Idle-Limit            169     integer
+ATTRIBUTE       Ascend-TS-Idle-Mode             170     integer
+ATTRIBUTE	Ascend-DBA-Monitor	 	171	integer
+ATTRIBUTE	Ascend-Base-Channel-Count 	172	integer
+ATTRIBUTE	Ascend-Minimum-Channels		173	integer
+ATTRIBUTE	Ascend-IPX-Route		174	string
+ATTRIBUTE	Ascend-FT1-Caller		175	integer
+ATTRIBUTE	Ascend-Backup			176	string
+ATTRIBUTE	Ascend-Call-Type		177	integer
+ATTRIBUTE	Ascend-Group			178	string
+ATTRIBUTE	Ascend-FR-DLCI			179	integer
+ATTRIBUTE	Ascend-FR-Profile-Name		180	string
+ATTRIBUTE	Ascend-Ara-PW			181	string
+ATTRIBUTE	Ascend-IPX-Node-Addr		182	string
+ATTRIBUTE	Ascend-Home-Agent-IP-Addr	183	ipaddr
+ATTRIBUTE	Ascend-Home-Agent-Password	184	string
+ATTRIBUTE	Ascend-Home-Network-Name	185	string
+ATTRIBUTE	Ascend-Home-Agent-UDP-Port	186	integer
+ATTRIBUTE	Ascend-Multilink-ID		187	integer
+ATTRIBUTE	Ascend-Num-In-Multilink		188	integer
+ATTRIBUTE	Ascend-First-Dest		189	ipaddr
+ATTRIBUTE	Ascend-Pre-Input-Octets		190	integer
+ATTRIBUTE	Ascend-Pre-Output-Octets	191	integer
+ATTRIBUTE	Ascend-Pre-Input-Packets	192	integer
+ATTRIBUTE	Ascend-Pre-Output-Packets	193	integer
+ATTRIBUTE	Ascend-Maximum-Time		194	integer
+ATTRIBUTE	Ascend-Disconnect-Cause		195	integer
+ATTRIBUTE	Ascend-Connect-Progress		196	integer
+ATTRIBUTE	Ascend-Data-Rate		197	integer
+ATTRIBUTE	Ascend-PreSession-Time		198	integer
+ATTRIBUTE	Ascend-Token-Idle		199	integer
+ATTRIBUTE	Ascend-Token-Immediate		200	integer
+ATTRIBUTE	Ascend-Require-Auth		201	integer
+ATTRIBUTE	Ascend-Number-Sessions		202	string
+ATTRIBUTE	Ascend-Authen-Alias		203	string
+ATTRIBUTE	Ascend-Token-Expiry		204	integer
+ATTRIBUTE	Ascend-Menu-Selector		205	string
+ATTRIBUTE	Ascend-Menu-Item		206	string
+ATTRIBUTE	Ascend-PW-Warntime		207	integer
+ATTRIBUTE	Ascend-PW-Lifetime		208	integer
+ATTRIBUTE	Ascend-IP-Direct		209	ipaddr
+ATTRIBUTE	Ascend-PPP-VJ-Slot-Comp		210	integer
+ATTRIBUTE	Ascend-PPP-VJ-1172		211	integer
+ATTRIBUTE	Ascend-PPP-Async-Map		212	integer
+ATTRIBUTE	Ascend-Third-Prompt		213	string
+ATTRIBUTE	Ascend-Send-Secret		214	string
+ATTRIBUTE	Ascend-Receive-Secret		215	string
+ATTRIBUTE	Ascend-IPX-Peer-Mode		216	integer
+ATTRIBUTE	Ascend-IP-Pool-Definition	217	string
+ATTRIBUTE	Ascend-Assign-IP-Pool		218	integer
+ATTRIBUTE	Ascend-FR-Direct		219	integer
+ATTRIBUTE	Ascend-FR-Direct-Profile	220	string
+ATTRIBUTE	Ascend-FR-Direct-DLCI		221	integer
+ATTRIBUTE	Ascend-Handle-IPX		222	integer
+ATTRIBUTE	Ascend-Netware-timeout		223	integer
+ATTRIBUTE	Ascend-IPX-Alias		224	integer
+ATTRIBUTE	Ascend-Metric			225	integer
+ATTRIBUTE	Ascend-PRI-Number-Type		226	integer
+ATTRIBUTE	Ascend-Dial-Number		227	string
+ATTRIBUTE	Ascend-Route-IP			228	integer
+ATTRIBUTE	Ascend-Route-IPX		229	integer
+ATTRIBUTE	Ascend-Bridge			230	integer
+ATTRIBUTE	Ascend-Send-Auth		231	integer
+ATTRIBUTE	Ascend-Send-Passwd		232	string
+ATTRIBUTE	Ascend-Link-Compression		233	integer
+ATTRIBUTE	Ascend-Target-Util		234	integer
+ATTRIBUTE	Ascend-Maximum-Channels		235	integer
+ATTRIBUTE	Ascend-Inc-Channel-Count	236	integer
+ATTRIBUTE	Ascend-Dec-Channel-Count	237	integer
+ATTRIBUTE	Ascend-Seconds-Of-History	238	integer
+ATTRIBUTE	Ascend-History-Weigh-Type	239	integer
+ATTRIBUTE	Ascend-Add-Seconds		240	integer
+ATTRIBUTE	Ascend-Remove-Seconds		241	integer
+ATTRIBUTE	Ascend-Idle-Limit		244	integer
+ATTRIBUTE	Ascend-Preempt-Limit		245	integer
+ATTRIBUTE	Ascend-Callback			246	integer
+ATTRIBUTE	Ascend-Data-Svc			247	integer
+ATTRIBUTE	Ascend-Force-56			248	integer
+ATTRIBUTE	Ascend-Billing-Number		249	string
+ATTRIBUTE	Ascend-Call-By-Call		250	integer
+ATTRIBUTE	Ascend-Transit-Number		251	string
+ATTRIBUTE	Ascend-Host-Info		252	string
+ATTRIBUTE	Ascend-PPP-Address		253	ipaddr
+ATTRIBUTE	Ascend-MPP-Idle-Percent		254	integer
+ATTRIBUTE	Ascend-Xmit-Rate		255	integer
+
+
+
+# Ascend protocols
+VALUE		Service-Type		Dialout-Framed-User	5
+VALUE		Framed-Protocol		ARA			255
+VALUE		Framed-Protocol		MPP			256
+VALUE		Framed-Protocol		EURAW			257
+VALUE		Framed-Protocol		EUUI			258
+VALUE		Framed-Protocol		X25			259
+VALUE		Framed-Protocol		COMB			260
+VALUE		Framed-Protocol		FR			261
+VALUE		Framed-Protocol		MP			262
+VALUE		Framed-Protocol		FR-CIR			263
+
+
+#
+#	Ascend specific extensions
+#	Used by ASCEND MAX/Pipeline products (see above)
+#
+
+VALUE		Ascend-FR-Direct	FR-Direct-No		0
+VALUE		Ascend-FR-Direct	FR-Direct-Yes		1
+VALUE		Ascend-Handle-IPX	Handle-IPX-None		0
+VALUE		Ascend-Handle-IPX	Handle-IPX-Client	1
+VALUE		Ascend-Handle-IPX	Handle-IPX-Server	2
+VALUE		Ascend-IPX-Peer-Mode	IPX-Peer-Router		0
+VALUE		Ascend-IPX-Peer-Mode	IPX-Peer-Dialin		1
+VALUE		Ascend-Call-Type	Nailed			1
+VALUE		Ascend-Call-Type	Nailed/Mpp		2
+VALUE		Ascend-Call-Type	Perm/Switched		3
+VALUE		Ascend-FT1-Caller	FT1-No			0
+VALUE		Ascend-FT1-Caller	FT1-Yes			1
+VALUE		Ascend-PRI-Number-Type	Unknown-Number		0
+VALUE		Ascend-PRI-Number-Type	Intl-Number		1
+VALUE		Ascend-PRI-Number-Type	National-Number		2
+VALUE		Ascend-PRI-Number-Type	Local-Number		4
+VALUE		Ascend-PRI-Number-Type	Abbrev-Number		5
+VALUE		Ascend-Route-IPX	Route-IPX-No		0
+VALUE		Ascend-Route-IPX	Route-IPX-Yes		1
+VALUE		Ascend-Bridge		Bridge-No		0
+VALUE		Ascend-Bridge		Bridge-Yes		1
+VALUE  		Ascend-TS-Idle-Mode     TS-Idle-None		0
+VALUE	  	Ascend-TS-Idle-Mode     TS-Idle-Input		1
+VALUE  		Ascend-TS-Idle-Mode     TS-Idle-Input-Output	2
+VALUE		Ascend-Send-Auth	Send-Auth-None		0
+VALUE		Ascend-Send-Auth	Send-Auth-PAP		1
+VALUE		Ascend-Send-Auth	Send-Auth-CHAP		2
+VALUE		Ascend-Send-Auth	Send-Auth-MS-CHAP	3
+VALUE		Ascend-Link-Compression	Link-Comp-None		0
+VALUE		Ascend-Link-Compression	Link-Comp-Stac		1
+VALUE		Ascend-Link-Compression	Link-Comp-Stac-Draft-9	2
+VALUE		Ascend-Link-Compression	Link-Comp-MS-Stac	3
+VALUE		Ascend-History-Weigh-Type	History-Constant	0
+VALUE		Ascend-History-Weigh-Type	History-Linear		1
+VALUE		Ascend-History-Weigh-Type	History-Quadratic	2
+VALUE		Ascend-Callback		Callback-No		0
+VALUE		Ascend-Callback		Callback-Yes		1
+VALUE		Ascend-Expect-Callback	Expect-Callback-No	0
+VALUE		Ascend-Expect-Callback	Expect-Callback-Yes	1
+VALUE		Ascend-Data-Svc		Switched-Voice-Bearer	0
+VALUE		Ascend-Data-Svc		Switched-56KR		1
+VALUE		Ascend-Data-Svc		Switched-64K		2
+VALUE		Ascend-Data-Svc		Switched-64KR		3
+VALUE		Ascend-Data-Svc		Switched-56K		4
+VALUE		Ascend-Data-Svc		Switched-384KR		5
+VALUE		Ascend-Data-Svc		Switched-384K		6
+VALUE		Ascend-Data-Svc		Switched-1536K		7
+VALUE		Ascend-Data-Svc		Switched-1536KR		8
+VALUE		Ascend-Data-Svc		Switched-128K		9
+VALUE		Ascend-Data-Svc		Switched-192K		10
+VALUE		Ascend-Data-Svc		Switched-256K		11
+VALUE		Ascend-Data-Svc		Switched-320K		12
+VALUE		Ascend-Data-Svc		Switched-384K-MR	13
+VALUE		Ascend-Data-Svc		Switched-448K		14
+VALUE		Ascend-Data-Svc		Switched-512K		15
+VALUE		Ascend-Data-Svc		Switched-576K		16
+VALUE		Ascend-Data-Svc		Switched-640K		17
+VALUE		Ascend-Data-Svc		Switched-704K		18
+VALUE		Ascend-Data-Svc		Switched-768K		19
+VALUE		Ascend-Data-Svc		Switched-832K		20
+VALUE		Ascend-Data-Svc		Switched-896K		21
+VALUE		Ascend-Data-Svc		Switched-960K		22
+VALUE		Ascend-Data-Svc		Switched-1024K		23
+VALUE		Ascend-Data-Svc		Switched-1088K		24
+VALUE		Ascend-Data-Svc		Switched-1152K		25
+VALUE		Ascend-Data-Svc		Switched-1216K		26
+VALUE		Ascend-Data-Svc		Switched-1280K		27
+VALUE		Ascend-Data-Svc		Switched-1344K		28
+VALUE		Ascend-Data-Svc		Switched-1408K		29
+VALUE		Ascend-Data-Svc		Switched-1472K		30
+VALUE		Ascend-Data-Svc		Switched-1600K		31
+VALUE		Ascend-Data-Svc		Switched-1664K		32
+VALUE		Ascend-Data-Svc		Switched-1728K		33
+VALUE		Ascend-Data-Svc		Switched-1792K		34
+VALUE		Ascend-Data-Svc		Switched-1856K		35
+VALUE		Ascend-Data-Svc		Switched-1920K		36
+VALUE		Ascend-Data-Svc		Switched-inherited		37
+VALUE		Ascend-Data-Svc		Switched-restricted-bearer-x30  38
+VALUE		Ascend-Data-Svc		Switched-clear-bearer-v110	39
+VALUE		Ascend-Data-Svc		Switched-restricted-64-x30	40
+VALUE		Ascend-Data-Svc		Switched-clear-56-v110		41
+VALUE		Ascend-Data-Svc		Switched-modem			42
+VALUE		Ascend-Data-Svc		Switched-atmodem		43
+VALUE		Ascend-Data-Svc		Nailed-56KR		1
+VALUE		Ascend-Data-Svc		Nailed-64K		2
+VALUE		Ascend-Force-56		Force-56-No		0
+VALUE		Ascend-Force-56		Force-56-Yes		1
+VALUE		Ascend-PW-Lifetime	Lifetime-In-Days	0
+VALUE		Ascend-PW-Warntime	Days-Of-Warning		0
+VALUE		Ascend-PPP-VJ-1172	PPP-VJ-1172		1
+VALUE		Ascend-PPP-VJ-Slot-Comp	VJ-Slot-Comp-No		1
+VALUE		Ascend-Require-Auth	Not-Require-Auth	0
+VALUE		Ascend-Require-Auth	Require-Auth		1
+VALUE		Ascend-Token-Immediate	Tok-Imm-No		0
+VALUE		Ascend-Token-Immediate	Tok-Imm-Yes		1
+VALUE		Ascend-DBA-Monitor		DBA-Transmit		0
+VALUE 		Ascend-DBA-Monitor	DBA-Transmit-Recv	1
+VALUE		Ascend-DBA-Monitor	DBA-None		2
+VALUE		Ascend-FR-Type		Ascend-FR-DTE		0
+VALUE		Ascend-FR-Type		Ascend-FR-DCE		1
+VALUE		Ascend-FR-Type		Ascend-FR-NNI		2
+VALUE		Ascend-FR-Link-Mgt	Ascend-FR-No-Link-Mgt	0
+VALUE		Ascend-FR-Link-Mgt	Ascend-FR-T1-617D	1
+VALUE		Ascend-FR-Link-Mgt	Ascend-FR-Q-933A	2
+VALUE		Ascend-FR-LinkUp	Ascend-LinkUp-Default	0
+VALUE		Ascend-FR-LinkUp	Ascend-LinkUp-AlwaysUp	1
+VALUE		Ascend-Multicast-Client	Multicast-No		0
+VALUE		Ascend-Multicast-Client	Multicast-Yes		1
+VALUE		Ascend-User-Acct-Type	Ascend-User-Acct-None	0
+VALUE		Ascend-User-Acct-Type	Ascend-User-Acct-User	1
+VALUE		Ascend-User-Acct-Type	Ascend-User-Acct-User-Default	2
+VALUE		Ascend-User-Acct-Base	Base-10			0
+VALUE		Ascend-User-Acct-Base	Base-16			1
+VALUE		Ascend-DHCP-Reply	DHCP-Reply-No		0
+VALUE		Ascend-DHCP-Reply	DHCP-Reply-Yes		1
+VALUE		Ascend-Client-Assign-DNS	DNS-Assign-No		0
+VALUE		Ascend-Client-Assign-DNS	DNS-Assign-Yes		1
+VALUE		Ascend-Event-Type	Ascend-ColdStart	1
+VALUE		Ascend-Event-Type	Ascend-Session-Event	2
+VALUE		Ascend-BACP-Enable	BACP-No			0
+VALUE		Ascend-BACP-Enable	BACP-Yes		1
+VALUE		Ascend-Dialout-Allowed	Dialout-Not-Allowed	0
+VALUE		Ascend-Dialout-Allowed	Dialout-Allowed		1
+VALUE		Ascend-Shared-Profile-Enable    Shared-Profile-No       0
+VALUE		Ascend-Shared-Profile-Enable    Shared-Profile-Yes      1
+VALUE		Ascend-Temporary-Rtes	Temp-Rtes-No		0
+VALUE		Ascend-Temporary-Rtes	Temp-Rtes-Yes		1
diff --git a/pppd/plugins/radius/radiusclient/etc/dictionary.compat b/pppd/plugins/radius/radiusclient/etc/dictionary.compat
new file mode 100644
index 0000000..fe3f087
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/etc/dictionary.compat
@@ -0,0 +1,45 @@
+#
+#	Obsolete names for backwards compatibility with older users files.
+#
+ATTRIBUTE	Client-Id		4	ipaddr
+ATTRIBUTE	Client-Port-Id		5	integer
+ATTRIBUTE	User-Service-Type	6	integer
+ATTRIBUTE	Framed-Address		8	ipaddr
+ATTRIBUTE	Framed-Netmask		9	ipaddr
+ATTRIBUTE	Framed-Filter-Id	11	string
+ATTRIBUTE	Login-Host		14	ipaddr
+ATTRIBUTE	Login-Port		16	integer
+ATTRIBUTE	Old-Password		17	string
+ATTRIBUTE	Port-Message		18	string
+ATTRIBUTE	Dialback-No		19	string
+ATTRIBUTE	Dialback-Name		20	string
+ATTRIBUTE	Challenge-State		24	string
+VALUE		Framed-Compression	Van-Jacobsen-TCP-IP	1
+VALUE		Framed-Compression	VJ-TCP-IP		1
+VALUE		Service-Type		Shell-User		6
+VALUE		Auth-Type		Unix			1
+VALUE		Service-Type		Dialback-Login-User	3
+VALUE		Service-Type		Dialback-Framed-User	4
+
+#
+#	For compatibility with MERIT users files.
+#
+ATTRIBUTE	NAS-Port		5	integer
+ATTRIBUTE	Login-Host		14	ipaddr
+ATTRIBUTE	Login-Callback-Number	19	string
+ATTRIBUTE	Framed-Callback-Id	20	string
+ATTRIBUTE	Client-Port-DNIS	30	string
+ATTRIBUTE	Caller-ID		31	string
+VALUE		Service-Type		Login			1
+VALUE		Service-Type		Framed			2
+VALUE		Service-Type		Callback-Login		3
+VALUE		Service-Type		Callback-Framed		4
+VALUE		Service-Type		Exec-User		7
+
+#
+#	For compatibility with ESVA RADIUS, Old Cistron RADIUS
+#
+ATTRIBUTE	Session			1034	integer
+ATTRIBUTE	User-Name-Is-Star	1035	integer
+VALUE		User-Name-Is-Star	No			0
+VALUE		User-Name-Is-Star	Yes			1
diff --git a/pppd/plugins/radius/radiusclient/etc/dictionary.merit b/pppd/plugins/radius/radiusclient/etc/dictionary.merit
new file mode 100644
index 0000000..7d675e5
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/etc/dictionary.merit
@@ -0,0 +1,17 @@
+#
+#	Experimental extensions, configuration only (for check-items)
+#	Names/numbers as per the MERIT extensions (if possible).
+#
+ATTRIBUTE	NAS-Identifier		32	string
+ATTRIBUTE	Proxy-State		33	string
+ATTRIBUTE	Login-LAT-Service	34	string
+ATTRIBUTE	Login-LAT-Node		35	string
+ATTRIBUTE	Login-LAT-Group		36	string
+ATTRIBUTE	Framed-AppleTalk-Link	37	integer
+ATTRIBUTE	Framed-AppleTalk-Network 38	integer
+ATTRIBUTE	Framed-AppleTalk-Zone	39	string
+ATTRIBUTE       Acct-Input-Packets	47	integer
+ATTRIBUTE       Acct-Output-Packets	48	integer
+# 8 is a MERIT extension.
+VALUE		Service-Type		Authenticate-Only	8
+
diff --git a/pppd/plugins/radius/radiusclient/etc/issue b/pppd/plugins/radius/radiusclient/etc/issue
new file mode 100644
index 0000000..6254487
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/etc/issue
@@ -0,0 +1,5 @@
+(\I)
+-----------------------------------------------------
+\S \R (\N) (port \L)
+-----------------------------------------------------
+
diff --git a/pppd/plugins/radius/radiusclient/etc/port-id-map b/pppd/plugins/radius/radiusclient/etc/port-id-map
new file mode 100644
index 0000000..9088a0b
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/etc/port-id-map
@@ -0,0 +1,24 @@
+#
+# port-id-map
+#
+# This file describes the ttyname to port id mapping. The port id
+# is reported as part of a RADIUS authentication or accouting request.
+#
+#ttyname (as returned by ttyname(3))	port-id
+/dev/tty1	1
+/dev/tty2	2
+/dev/tty3	3
+/dev/tty4	4
+/dev/tty5	5
+/dev/tty6	6
+/dev/tty7	7
+/dev/tty8	8
+/dev/ttyS0	9
+/dev/ttyS1	10
+/dev/ttyS2	11
+/dev/ttyS3	12
+/dev/ttyS4	13
+/dev/ttyS5	14
+/dev/ttyS6	15
+/dev/ttyS7	16
+ 
\ No newline at end of file
diff --git a/pppd/plugins/radius/radiusclient/etc/radiusclient.conf.in b/pppd/plugins/radius/radiusclient/etc/radiusclient.conf.in
new file mode 100644
index 0000000..916289a
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/etc/radiusclient.conf.in
@@ -0,0 +1,78 @@
+# General settings
+
+# specify which authentication comes first respectively which
+# authentication is used. possible values are: "radius" and "local".
+# if you specify "radius,local" then the RADIUS server is asked
+# first then the local one. if only one keyword is specified only
+# this server is asked.
+auth_order	radius
+
+# maximum login tries a user has
+login_tries	4
+
+# timeout for all login tries
+# if this time is exceeded the user is kicked out
+login_timeout	60
+
+# name of the nologin file which when it exists disables logins.
+# it may be extended by the ttyname which will result in
+# a terminal specific lock (e.g. /etc/nologin.ttyS2 will disable
+# logins on /dev/ttyS2)
+nologin /etc/nologin
+
+# name of the issue file. it's only display when no username is passed
+# on the radlogin command line
+issue	@pkgsysconfdir@/issue
+
+# RADIUS settings
+
+# RADIUS server to use for authentication requests. this config
+# item can appear more then one time. if multiple servers are
+# defined they are tried in a round robin fashion if one
+# server is not answering.
+# optionally you can specify a the port number on which is remote
+# RADIUS listens separated by a colon from the hostname. if
+# no port is specified /etc/services is consulted of the radius
+# service. if this fails also a compiled in default is used.
+authserver 	localhost:1812
+
+# RADIUS server to use for accouting requests. All that I
+# said for authserver applies, too. 
+#
+acctserver 	localhost:1813
+
+# file holding shared secrets used for the communication
+# between the RADIUS client and server
+servers		@pkgsysconfdir@/servers
+
+# dictionary of allowed attributes and values
+# just like in the normal RADIUS distributions
+dictionary 	@pkgsysconfdir@/dictionary
+
+# program to call for a RADIUS authenticated login
+login_radius	@sbindir@/login.radius
+
+# file which holds sequence number for communication with the
+# RADIUS server
+seqfile		/var/run/radius.seq
+
+# file which specifies mapping between ttyname and NAS-Port attribute
+mapfile		@pkgsysconfdir@/port-id-map
+
+# default authentication realm to append to all usernames if no
+# realm was explicitly specified by the user
+# the radiusd directly form Livingston doesnt use any realms, so leave
+# it blank then
+default_realm
+
+# time to wait for a reply from the RADIUS server
+radius_timeout	10
+
+# resend request this many times before trying the next server
+radius_retries	3
+
+# LOCAL settings
+
+# program to execute for local login
+# it must support the -f flag for preauthenticated login
+login_local	/bin/login
diff --git a/pppd/plugins/radius/radiusclient/etc/servers b/pppd/plugins/radius/radiusclient/etc/servers
new file mode 100644
index 0000000..b061bf9
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/etc/servers
@@ -0,0 +1,4 @@
+#Server Name or Client/Server pair		Key
+#----------------				---------------
+#portmaster.elemental.net			hardlyasecret
+#portmaster2.elemental.net	    		donttellanyone
diff --git a/pppd/plugins/radius/radiusclient/include/Makefile.am b/pppd/plugins/radius/radiusclient/include/Makefile.am
new file mode 100644
index 0000000..dc9cac3
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/include/Makefile.am
@@ -0,0 +1,15 @@
+# 
+#  $Id: Makefile.am,v 1.1 2002/01/22 16:03:01 dfs Exp $
+# 
+#  Copyright (C) 1997 Lars Fenneberg
+# 
+#  See the file COPYRIGHT for the respective terms and conditions. 
+#  If the file is missing contact me at lf@elemental.net 
+#  and I'll send you a copy.
+# 
+#
+
+AUTOMAKE_OPTIONS = foreign
+
+noinst_HEADERS = pathnames.h messages.h includes.h
+include_HEADERS = radiusclient.h
diff --git a/pppd/plugins/radius/radiusclient/include/Makefile.in b/pppd/plugins/radius/radiusclient/include/Makefile.in
new file mode 100644
index 0000000..d8d8d12
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/include/Makefile.in
@@ -0,0 +1,230 @@
+# Makefile.in generated automatically by automake 1.3 from Makefile.am
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+# 
+#  $Id: Makefile.in,v 1.1 2002/01/22 16:03:01 dfs Exp $
+# 
+#  Copyright (C) 1997 Lars Fenneberg
+# 
+#  See the file COPYRIGHT for the respective terms and conditions. 
+#  If the file is missing contact me at lf@elemental.net 
+#  and I'll send you a copy.
+# 
+#
+
+
+SHELL = /bin/sh
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+sbindir = @sbindir@
+libexecdir = @libexecdir@
+datadir = @datadir@
+sysconfdir = @sysconfdir@
+sharedstatedir = @sharedstatedir@
+localstatedir = @localstatedir@
+libdir = @libdir@
+infodir = @infodir@
+mandir = @mandir@
+includedir = @includedir@
+oldincludedir = /usr/include
+
+DISTDIR =
+
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+
+top_builddir = ..
+
+ACLOCAL = @ACLOCAL@
+AUTOCONF = @AUTOCONF@
+AUTOMAKE = @AUTOMAKE@
+AUTOHEADER = @AUTOHEADER@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+transform = @program_transform_name@
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_alias = @build_alias@
+build_triplet = @build@
+host_alias = @host_alias@
+host_triplet = @host@
+target_alias = @target_alias@
+target_triplet = @target@
+AR = @AR@
+CC = @CC@
+LD = @LD@
+LIBTOOL = @LIBTOOL@
+LIBVERSION = @LIBVERSION@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+NM = @NM@
+PACKAGE = @PACKAGE@
+RANLIB = @RANLIB@
+RC_LOG_FACILITY = @RC_LOG_FACILITY@
+RC_SECURE_PATH = @RC_SECURE_PATH@
+VERSION = @VERSION@
+pkgsysconfdir = @pkgsysconfdir@
+
+AUTOMAKE_OPTIONS = foreign
+
+noinst_HEADERS = pathnames.h messages.h includes.h
+include_HEADERS = radiusclient.h
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = ../config.h
+CONFIG_CLEAN_FILES = 
+HEADERS =  $(include_HEADERS) $(noinst_HEADERS)
+
+DIST_COMMON =  Makefile.am Makefile.in
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = tar
+GZIP = --best
+all: Makefile $(HEADERS)
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && $(AUTOMAKE) --foreign --include-deps include/Makefile
+
+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+
+install-includeHEADERS: $(include_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(includedir)
+	@list='$(include_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d= ; else d="$(srcdir)/"; fi; \
+	  echo " $(INSTALL_DATA) $$d$$p $(DESTDIR)$(includedir)/$$p"; \
+	  $(INSTALL_DATA) $$d$$p $(DESTDIR)$(includedir)/$$p; \
+	done
+
+uninstall-includeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	list='$(include_HEADERS)'; for p in $$list; do \
+	  rm -f $(DESTDIR)$(includedir)/$$p; \
+	done
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP)
+	here=`pwd` && cd $(srcdir) \
+	  && mkid -f$$here/ID $(SOURCES) $(HEADERS) $(LISP)
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$unique$(LISP)$$tags" \
+	  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $$unique $(LISP) -o $$here/TAGS)
+
+mostlyclean-tags:
+
+clean-tags:
+
+distclean-tags:
+	-rm -f TAGS ID
+
+maintainer-clean-tags:
+
+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
+
+subdir = include
+
+distdir: $(DISTFILES)
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  test -f $(distdir)/$$file \
+	  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	  || cp -p $$d/$$file $(distdir)/$$file; \
+	done
+info:
+dvi:
+check: all
+	$(MAKE)
+installcheck:
+install-exec: 
+	@$(NORMAL_INSTALL)
+
+install-data: install-includeHEADERS
+	@$(NORMAL_INSTALL)
+
+install: install-exec install-data all
+	@:
+
+uninstall: uninstall-includeHEADERS
+
+install-strip:
+	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install
+installdirs:
+	$(mkinstalldirs)  $(DATADIR)$(includedir)
+
+
+mostlyclean-generic:
+	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-rm -f Makefile $(DISTCLEANFILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+mostlyclean:  mostlyclean-tags mostlyclean-generic
+
+clean:  clean-tags clean-generic mostlyclean
+
+distclean:  distclean-tags distclean-generic clean
+	-rm -f config.status
+	-rm -f libtool
+
+maintainer-clean:  maintainer-clean-tags maintainer-clean-generic \
+		distclean
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+.PHONY: uninstall-includeHEADERS install-includeHEADERS tags \
+mostlyclean-tags distclean-tags clean-tags maintainer-clean-tags \
+distdir info dvi installcheck install-exec install-data install \
+uninstall all installdirs mostlyclean-generic distclean-generic \
+clean-generic maintainer-clean-generic clean mostlyclean distclean \
+maintainer-clean
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/pppd/plugins/radius/radiusclient/include/includes.h b/pppd/plugins/radius/radiusclient/include/includes.h
new file mode 100644
index 0000000..4017919
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/include/includes.h
@@ -0,0 +1,150 @@
+/*
+ * $Id: includes.h,v 1.1 2002/01/22 16:03:01 dfs Exp $
+ *
+ * Copyright (C) 1997 Lars Fenneberg
+ *
+ * Copyright 1992 Livingston Enterprises, Inc.
+ *
+ * Copyright 1992,1993, 1994,1995 The Regents of the University of Michigan 
+ * and Merit Network, Inc. All Rights Reserved
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#include <ctype.h>
+#include <stdio.h>
+#include <errno.h>
+#include <netdb.h>
+#include <syslog.h>
+
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <string.h>
+# include <stdarg.h>
+#else
+# include <stdarg.h>
+# ifndef HAVE_STRCHR
+#  define strchr index
+#  define strrchr rindex
+# endif
+#endif
+
+/* I realize that this is ugly and unsafe.. :( */
+#ifndef HAVE_SNPRINTF
+# define snprintf(buf, len, format, args...) sprintf(buf, format, ## args)
+#endif
+#ifndef HAVE_VSNPRINTF
+# define vsnprintf(buf, len, format, ap) vsprintf(buf, format, ap)
+#endif
+
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+
+#ifdef HAVE_FCNTL_H
+# include <fcntl.h>
+#endif
+
+#ifdef HAVE_SYS_FCNTL_H
+# include <sys/fcntl.h>
+#endif
+
+#ifdef HAVE_SYS_FILE_H
+# include <sys/file.h>
+#endif
+
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+
+#ifdef HAVE_SYS_UTSNAME_H
+# include <sys/utsname.h>
+#endif
+
+#ifdef HAVE_SYS_IOCTL_H
+# include <sys/ioctl.h>
+#endif
+
+#ifdef HAVE_CRYPT_H
+# include <crypt.h>
+#endif
+
+#ifdef HAVE_LIMITS_H
+# include <limits.h>
+#endif
+
+#ifdef HAVE_TERMIOS_H
+# include <termios.h>
+#endif
+
+#ifndef PATH_MAX
+#define PATH_MAX        1024
+#endif
+
+#ifndef UCHAR_MAX
+# ifdef  __STDC__
+#  define UCHAR_MAX       255U
+# else
+#  define UCHAR_MAX       255
+# endif
+#endif
+
+#include <pwd.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#if defined(HAVE_SIGNAL_H)
+# include <signal.h>
+#endif
+#if defined(HAVE_SYS_SIGNAL_H)
+# include <sys/signal.h>
+#endif
+
+#ifdef NEED_SIG_PROTOTYPES
+int sigemptyset(sigset_t *);
+int sigaddset(sigset_t *, int);
+int sigprocmask (int, sigset_t *, sigset_t *);
+#endif
+
+#if HAVE_GETOPT_H
+# include <getopt.h>
+#endif
+
+#if defined(HAVE_SHADOW_H) && defined(HAVE_SHADOW_PASSWORDS)
+# include <shadow.h>
+#endif
+
+#if TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# if HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+
+/*
+ * prefer srandom/random over srand/rand as there generator has a
+ * better distribution of the numbers on certain systems.
+ * on Linux both generators are identical.
+ */ 
+#ifndef HAVE_RANDOM
+# ifdef HAVE_RAND
+# define srandom        srand
+# define random         rand
+# endif
+#endif
+
+/* rlib/lock.c */
+int do_lock_exclusive(int);
+int do_unlock(int);
diff --git a/pppd/plugins/radius/radiusclient/include/messages.h b/pppd/plugins/radius/radiusclient/include/messages.h
new file mode 100644
index 0000000..23c4f67
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/include/messages.h
@@ -0,0 +1,53 @@
+/*
+ * $Id: messages.h,v 1.1 2002/01/22 16:03:01 dfs Exp $
+ *
+ * Copyright (C) 1995,1996 Lars Fenneberg
+ *
+ * Copyright 1992 Livingston Enterprises, Inc.
+ *
+ * Copyright 1992,1993, 1994,1995 The Regents of the University of Michigan 
+ * and Merit Network, Inc. All Rights Reserved
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+/*
+ * Only messages that the user gets under normal use are in here.
+ * Error messages and such are still in the source code.
+ */
+
+#ifndef MESSAGES_H
+#define MESSAGES_H
+
+/* radlogin.c */
+
+#define SC_LOGIN	 "login: "
+#define SC_PASSWORD	 "Password: "
+
+#define SC_TIMEOUT	 "\r\nlogin timed out after %d seconds. Bye.\r\n"
+#define SC_EXCEEDED	 "Maximum login tries exceeded. Go away!\r\n"
+
+#define SC_RADIUS_OK	 "RADIUS: Authentication OK\r\n"
+#define SC_RADIUS_FAILED "RADIUS: Authentication failure\r\n"
+
+#define SC_LOCAL_OK	 "local: Authentication OK\r\n"
+#define SC_LOCAL_FAILED	 "local: Authentication failure\r\n"
+#define SC_NOLOGIN	 "\r\nSystem closed for maintenance. Try again later...\r\n"
+
+#define SC_SERVER_REPLY	 "RADIUS: %s"
+
+#define SC_DEFAULT_ISSUE "(\\I)\r\n\r\n\\S \\R (\\N) (port \\L)\r\n\r\n"
+
+/* radacct.c */
+
+#define SC_ACCT_OK	 "RADIUS accounting OK\r\n"
+#define SC_ACCT_FAILED	 "RADIUS accounting failed (RC=%i)\r\n"
+
+/* radstatus.c */
+
+#define SC_STATUS_FAILED	"RADIUS: Status failure\r\n"
+
+#endif /* MESSAGES_H */
\ No newline at end of file
diff --git a/pppd/plugins/radius/radiusclient/include/pathnames.h b/pppd/plugins/radius/radiusclient/include/pathnames.h
new file mode 100644
index 0000000..2e6d219
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/include/pathnames.h
@@ -0,0 +1,28 @@
+/*
+ * $Id: pathnames.h,v 1.1 2002/01/22 16:03:01 dfs Exp $
+ *
+ * Copyright (C) 1995,1996 Lars Fenneberg
+ *
+ * Copyright 1992 Livingston Enterprises, Inc.
+ *
+ * Copyright 1992,1993, 1994,1995 The Regents of the University of Michigan 
+ * and Merit Network, Inc. All Rights Reserved
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+#ifndef PATHNAMES_H
+#define PATHNAMES_H
+
+#define _PATH_DEV_URANDOM	"/dev/urandom"		/* Linux only */
+#define _PATH_ETC_ISSUE		"/etc/issue"
+
+/* normally defined in the Makefile */
+#ifndef _PATH_ETC_RADIUSCLIENT_CONF
+#define _PATH_ETC_RADIUSCLIENT_CONF       "/etc/radiusclient.conf"
+#endif
+
+#endif /* PATHNAMES_H */
\ No newline at end of file
diff --git a/pppd/plugins/radius/radiusclient/include/radiusclient.h b/pppd/plugins/radius/radiusclient/include/radiusclient.h
new file mode 100644
index 0000000..f5183fc
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/include/radiusclient.h
@@ -0,0 +1,451 @@
+/*
+ * $Id: radiusclient.h,v 1.1 2002/01/22 16:03:01 dfs Exp $
+ *
+ * Copyright (C) 1995,1996,1997,1998 Lars Fenneberg
+ *
+ * Copyright 1992 Livingston Enterprises, Inc.
+ *
+ * Copyright 1992,1993, 1994,1995 The Regents of the University of Michigan 
+ * and Merit Network, Inc. All Rights Reserved
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+#ifndef RADIUSCLIENT_H
+#define RADIUSCLIENT_H
+
+#include	<sys/types.h>
+#include	<stdio.h>
+#include	<time.h>
+
+#undef __BEGIN_DECLS
+#undef __END_DECLS
+#ifdef __cplusplus
+# define __BEGIN_DECLS extern "C" {
+# define __END_DECLS }
+#else
+# define __BEGIN_DECLS /* empty */
+# define __END_DECLS /* empty */
+#endif
+
+#undef __P
+#if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(WIN32) || defined(__cplusplus)
+# define __P(protos) protos
+#else
+# define __P(protos) ()
+#endif
+
+typedef unsigned long UINT4;
+typedef long 	      INT4;
+
+#define AUTH_VECTOR_LEN		16
+#define AUTH_PASS_LEN		(3 * 16) /* multiple of 16 */
+#define AUTH_ID_LEN		64
+#define AUTH_STRING_LEN		128	 /* maximum of 253 */
+
+#define	BUFFER_LEN		8192
+
+#define NAME_LENGTH		32
+#define	GETSTR_LENGTH		128	/* must be bigger than AUTH_PASS_LEN */
+
+/* codes for radius_buildreq, radius_getport, etc. */
+#define AUTH			0
+#define ACCT			1
+
+/* defines for config.c */
+
+#define SERVER_MAX 8
+
+#define AUTH_LOCAL_FST	(1<<0)
+#define AUTH_RADIUS_FST (1<<1)
+#define AUTH_LOCAL_SND  (1<<2)
+#define AUTH_RADIUS_SND (1<<3)
+
+typedef struct server {
+	int max;
+	char *name[SERVER_MAX];
+	unsigned short port[SERVER_MAX];	
+} SERVER;
+
+typedef struct pw_auth_hdr
+{
+	u_char          code;
+	u_char          id;
+	u_short         length;
+	u_char          vector[AUTH_VECTOR_LEN];
+	u_char          data[2];
+} AUTH_HDR;
+
+#define AUTH_HDR_LEN			20
+#define MAX_SECRET_LENGTH		(3 * 16) /* MUST be multiple of 16 */
+#define CHAP_VALUE_LENGTH		16
+
+#define PW_AUTH_UDP_PORT		1645
+#define PW_ACCT_UDP_PORT		1646
+
+#define PW_TYPE_STRING			0
+#define PW_TYPE_INTEGER			1
+#define PW_TYPE_IPADDR			2
+#define PW_TYPE_DATE			3
+
+/* standard RADIUS codes */
+
+#define	PW_ACCESS_REQUEST		1
+#define	PW_ACCESS_ACCEPT		2
+#define	PW_ACCESS_REJECT		3
+#define	PW_ACCOUNTING_REQUEST		4
+#define	PW_ACCOUNTING_RESPONSE		5
+#define	PW_ACCOUNTING_STATUS		6
+#define	PW_PASSWORD_REQUEST		7
+#define	PW_PASSWORD_ACK			8
+#define	PW_PASSWORD_REJECT		9
+#define	PW_ACCOUNTING_MESSAGE		10
+#define	PW_ACCESS_CHALLENGE		11
+#define	PW_STATUS_SERVER		12
+#define	PW_STATUS_CLIENT		13
+
+
+/* standard RADIUS attribute-value pairs */
+
+#define	PW_USER_NAME			1	/* string */
+#define	PW_USER_PASSWORD		2	/* string */
+#define	PW_CHAP_PASSWORD		3	/* string */
+#define	PW_NAS_IP_ADDRESS		4	/* ipaddr */
+#define	PW_NAS_PORT			5	/* integer */
+#define	PW_SERVICE_TYPE			6	/* integer */
+#define	PW_FRAMED_PROTOCOL		7	/* integer */
+#define	PW_FRAMED_IP_ADDRESS		8	/* ipaddr */
+#define	PW_FRAMED_IP_NETMASK		9	/* ipaddr */
+#define	PW_FRAMED_ROUTING		10	/* integer */
+#define	PW_FILTER_ID		        11	/* string */
+#define	PW_FRAMED_MTU			12	/* integer */
+#define	PW_FRAMED_COMPRESSION		13	/* integer */
+#define	PW_LOGIN_IP_HOST		14	/* ipaddr */
+#define	PW_LOGIN_SERVICE		15	/* integer */
+#define	PW_LOGIN_PORT			16	/* integer */
+#define	PW_OLD_PASSWORD			17	/* string */ /* deprecated */
+#define	PW_REPLY_MESSAGE		18	/* string */
+#define	PW_LOGIN_CALLBACK_NUMBER	19	/* string */
+#define	PW_FRAMED_CALLBACK_ID		20	/* string */
+#define	PW_EXPIRATION			21	/* date */ /* deprecated */
+#define	PW_FRAMED_ROUTE			22	/* string */
+#define	PW_FRAMED_IPX_NETWORK		23	/* integer */
+#define	PW_STATE			24	/* string */
+#define	PW_CLASS			25	/* string */
+#define	PW_VENDOR_SPECIFIC		26	/* string */
+#define	PW_SESSION_TIMEOUT		27	/* integer */
+#define	PW_IDLE_TIMEOUT			28	/* integer */
+#define	PW_TERMINATION_ACTION		29	/* integer */
+#define	PW_CALLED_STATION_ID            30      /* string */
+#define	PW_CALLING_STATION_ID           31      /* string */
+#define	PW_NAS_IDENTIFIER		32	/* string */
+#define	PW_PROXY_STATE			33	/* string */
+#define	PW_LOGIN_LAT_SERVICE		34	/* string */
+#define	PW_LOGIN_LAT_NODE		35	/* string */
+#define	PW_LOGIN_LAT_GROUP		36	/* string */
+#define	PW_FRAMED_APPLETALK_LINK	37	/* integer */
+#define	PW_FRAMED_APPLETALK_NETWORK	38	/* integer */
+#define	PW_FRAMED_APPLETALK_ZONE	39	/* string */
+#define	PW_CHAP_CHALLENGE               60      /* string */
+#define	PW_NAS_PORT_TYPE                61      /* integer */
+#define	PW_PORT_LIMIT                   62      /* integer */
+#define PW_LOGIN_LAT_PORT               63      /* string */
+
+/*	Accounting */
+
+#define	PW_ACCT_STATUS_TYPE		40	/* integer */
+#define	PW_ACCT_DELAY_TIME		41	/* integer */
+#define	PW_ACCT_INPUT_OCTETS		42	/* integer */
+#define	PW_ACCT_OUTPUT_OCTETS		43	/* integer */
+#define	PW_ACCT_SESSION_ID		44	/* string */
+#define	PW_ACCT_AUTHENTIC		45	/* integer */
+#define	PW_ACCT_SESSION_TIME		46	/* integer */
+#define	PW_ACCT_INPUT_PACKETS		47	/* integer */
+#define	PW_ACCT_OUTPUT_PACKETS		48	/* integer */
+#define PW_ACCT_TERMINATE_CAUSE		49	/* integer */
+#define PW_ACCT_MULTI_SESSION_ID	50	/* string */
+#define PW_ACCT_LINK_COUNT		51	/* integer */
+
+/*	Merit Experimental Extensions */
+
+#define PW_USER_ID                      222     /* string */
+#define PW_USER_REALM                   223     /* string */
+
+/*	Integer Translations */
+
+/*	SERVICE TYPES	*/
+
+#define	PW_LOGIN			1
+#define	PW_FRAMED			2
+#define	PW_CALLBACK_LOGIN		3
+#define	PW_CALLBACK_FRAMED		4
+#define	PW_OUTBOUND			5
+#define	PW_ADMINISTRATIVE		6
+#define PW_NAS_PROMPT                   7
+#define PW_AUTHENTICATE_ONLY		8
+#define PW_CALLBACK_NAS_PROMPT          9
+
+/*	FRAMED PROTOCOLS	*/
+
+#define	PW_PPP				1
+#define	PW_SLIP				2
+#define PW_ARA                          3
+#define PW_GANDALF                      4
+#define PW_XYLOGICS                     5
+
+/*	FRAMED ROUTING VALUES	*/
+
+#define	PW_NONE				0
+#define	PW_BROADCAST			1
+#define	PW_LISTEN			2
+#define	PW_BROADCAST_LISTEN		3
+
+/*	FRAMED COMPRESSION TYPES	*/
+
+#define	PW_VAN_JACOBSON_TCP_IP		1
+#define	PW_IPX_HEADER_COMPRESSION	2
+
+/*	LOGIN SERVICES	*/
+
+#define PW_TELNET                       0
+#define PW_RLOGIN                       1
+#define PW_TCP_CLEAR                    2
+#define PW_PORTMASTER                   3
+#define PW_LAT                          4
+#define PW_X25_PAD                      5
+#define PW_X25_T3POS                    6
+
+/*	TERMINATION ACTIONS	*/
+
+#define	PW_DEFAULT			0
+#define	PW_RADIUS_REQUEST		1
+
+/*	PROHIBIT PROTOCOL  */
+
+#define PW_DUMB		0	/* 1 and 2 are defined in FRAMED PROTOCOLS */
+#define PW_AUTH_ONLY	3
+#define PW_ALL		255
+
+/*	ACCOUNTING STATUS TYPES    */
+
+#define PW_STATUS_START		1
+#define PW_STATUS_STOP		2
+#define PW_STATUS_ALIVE		3
+#define PW_STATUS_MODEM_START	4
+#define PW_STATUS_MODEM_STOP	5
+#define PW_STATUS_CANCEL	6
+#define PW_ACCOUNTING_ON	7
+#define PW_ACCOUNTING_OFF	8
+
+/*      ACCOUNTING TERMINATION CAUSES   */
+
+#define PW_USER_REQUEST         1
+#define PW_LOST_CARRIER         2
+#define PW_LOST_SERVICE         3
+#define PW_ACCT_IDLE_TIMEOUT    4
+#define PW_ACCT_SESSION_TIMEOUT 5
+#define PW_ADMIN_RESET          6
+#define PW_ADMIN_REBOOT         7
+#define PW_PORT_ERROR           8
+#define PW_NAS_ERROR            9
+#define PW_NAS_REQUEST          10
+#define PW_NAS_REBOOT           11
+#define PW_PORT_UNNEEDED        12
+#define PW_PORT_PREEMPTED       13
+#define PW_PORT_SUSPENDED       14
+#define PW_SERVICE_UNAVAILABLE  15
+#define PW_CALLBACK             16
+#define PW_USER_ERROR           17
+#define PW_HOST_REQUEST         18
+ 
+/*     NAS PORT TYPES    */
+
+#define PW_ASYNC		0
+#define PW_SYNC			1
+#define PW_ISDN_SYNC		2
+#define PW_ISDN_SYNC_V120	3
+#define PW_ISDN_SYNC_V110	4
+#define PW_VIRTUAL		5
+
+/*	   AUTHENTIC TYPES */
+#define PW_RADIUS	1
+#define PW_LOCAL	2
+#define PW_REMOTE	3
+
+/* Vendor codes */
+#define VENDOR_NONE     (-1)
+
+/* Server data structures */
+
+typedef struct dict_attr
+{
+	char              name[NAME_LENGTH + 1];	/* attribute name */
+	int               value;			/* attribute index */
+	int               type;				/* string, int, etc. */
+        int               vendorcode;                   /* vendor code */
+	struct dict_attr *next;
+} DICT_ATTR;
+
+typedef struct dict_value
+{
+	char               attrname[NAME_LENGTH +1];
+	char               name[NAME_LENGTH + 1];
+	int                value;
+	struct dict_value *next;
+} DICT_VALUE;
+
+typedef struct vendor_dict
+{
+    char vendorname[NAME_LENGTH + 1];
+    int vendorcode;
+    DICT_ATTR *attributes;
+    struct vendor_dict *next;
+} VENDOR_DICT;
+
+typedef struct value_pair
+{
+	char               name[NAME_LENGTH + 1];
+	int                attribute;
+        int                vendorcode;
+	int                type;
+	UINT4              lvalue;
+	char               strvalue[AUTH_STRING_LEN + 1];
+	struct value_pair *next;
+} VALUE_PAIR;
+
+/* don't change this, as it has to be the same as in the Merit radiusd code */
+#define MGMT_POLL_SECRET	"Hardlyasecret"
+
+/* 	Define return codes from "SendServer" utility */
+
+#define BADRESP_RC	-2
+#define ERROR_RC	-1
+#define OK_RC		0
+#define TIMEOUT_RC	1
+
+typedef struct send_data /* Used to pass information to sendserver() function */
+{
+	u_char          code;		/* RADIUS packet code */
+	u_char          seq_nbr;	/* Packet sequence number */
+	char           *server;		/* Name/addrress of RADIUS server */
+	int             svc_port;	/* RADIUS protocol destination port */
+	int             timeout;	/* Session timeout in seconds */
+	int		retries;
+	VALUE_PAIR     *send_pairs;     /* More a/v pairs to send */
+	VALUE_PAIR     *receive_pairs;  /* Where to place received a/v pairs */
+} SEND_DATA;
+
+#ifndef MIN
+#define MIN(a, b)     ((a) < (b) ? (a) : (b))
+#endif
+#ifndef MAX
+#define MAX(a, b)     ((a) > (b) ? (a) : (b))
+#endif
+
+#ifndef PATH_MAX
+#define PATH_MAX	1024
+#endif
+
+typedef struct env
+{
+	int maxsize, size;
+	char **env;
+} ENV;
+
+#define ENV_SIZE	128
+
+__BEGIN_DECLS
+
+/*	Function prototypes	*/
+
+/*	avpair.c		*/
+
+VALUE_PAIR *rc_avpair_add __P((VALUE_PAIR **, int, void *, int, int));
+int rc_avpair_assign __P((VALUE_PAIR *, void *, int));
+VALUE_PAIR *rc_avpair_new __P((int, void *, int, int));
+VALUE_PAIR *rc_avpair_gen __P((AUTH_HDR *));
+VALUE_PAIR *rc_avpair_get __P((VALUE_PAIR *, UINT4));
+void rc_avpair_insert __P((VALUE_PAIR **, VALUE_PAIR *, VALUE_PAIR *));
+void rc_avpair_free __P((VALUE_PAIR *));
+int rc_avpair_parse __P((char *, VALUE_PAIR **));
+int rc_avpair_tostr __P((VALUE_PAIR *, char *, int, char *, int));
+VALUE_PAIR *rc_avpair_readin __P((FILE *));
+
+/*	buildreq.c		*/
+
+void rc_buildreq __P((SEND_DATA *, int, char *, unsigned short, int, int));
+unsigned char rc_get_seqnbr __P((void));
+int rc_auth __P((UINT4, VALUE_PAIR *, VALUE_PAIR **, char *));
+int rc_auth_proxy __P((VALUE_PAIR *, VALUE_PAIR **, char *));
+int rc_acct __P((UINT4, VALUE_PAIR *));
+int rc_acct_proxy __P((VALUE_PAIR *));
+int rc_check __P((char *, unsigned short, char *));
+
+/*	clientid.c		*/
+
+int rc_read_mapfile __P((char *));
+UINT4 rc_map2id __P((char *));
+
+/*	config.c		*/
+
+int rc_read_config __P((char *));
+char *rc_conf_str __P((char *));
+int rc_conf_int __P((char *));
+SERVER *rc_conf_srv __P((char *));
+int rc_find_server __P((char *, UINT4 *, char *));
+
+/*	dict.c			*/
+
+int rc_read_dictionary __P((char *));
+DICT_ATTR *rc_dict_getattr __P((int, int));
+DICT_ATTR *rc_dict_findattr __P((char *));
+DICT_VALUE *rc_dict_findval __P((char *));
+DICT_VALUE * rc_dict_getval __P((UINT4, char *));
+VENDOR_DICT * rc_dict_findvendor __P((char *));
+VENDOR_DICT * rc_dict_getvendor __P((int));
+
+/*	ip_util.c		*/
+
+UINT4 rc_get_ipaddr __P((char *));
+int rc_good_ipaddr __P((char *));
+const char *rc_ip_hostname __P((UINT4));
+unsigned short rc_getport __P((int));
+int rc_own_hostname __P((char *, int));
+UINT4 rc_own_ipaddress __P((void));
+
+
+/*	log.c			*/
+
+void rc_openlog __P((char *));
+void rc_log __P((int, const char *, ...));
+
+/*	sendserver.c		*/
+
+int rc_send_server __P((SEND_DATA *, char *));
+
+/*	util.c			*/
+
+void rc_str2tm __P((char *, struct tm *));
+char *rc_mksid __P((void));
+char *rc_getifname __P((char *));
+char *rc_getstr __P((char *, int));
+void rc_mdelay __P((int));
+char *rc_mksid __P((void));
+
+/*	env.c			*/
+
+struct env *rc_new_env __P((int));
+void rc_free_env __P((struct env *));
+int rc_add_env __P((struct env *, char *, char *));
+int rc_import_env __P((struct env *, char **));
+
+/* md5.c			*/
+
+void rc_md5_calc __P((unsigned char *, unsigned char *, unsigned int));
+
+__END_DECLS
+
+#endif /* RADIUSCLIENT_H */
diff --git a/pppd/plugins/radius/radiusclient/install-sh b/pppd/plugins/radius/radiusclient/install-sh
new file mode 100755
index 0000000..ebc6691
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/install-sh
@@ -0,0 +1,250 @@
+#! /bin/sh
+#
+# install - install a program, script, or datafile
+# This comes from X11R5 (mit/util/scripts/install.sh).
+#
+# Copyright 1991 by the Massachusetts Institute of Technology
+#
+# Permission to use, copy, modify, distribute, and sell this software and its
+# documentation for any purpose is hereby granted without fee, provided that
+# the above copyright notice appear in all copies and that both that
+# copyright notice and this permission notice appear in supporting
+# documentation, and that the name of M.I.T. not be used in advertising or
+# publicity pertaining to distribution of the software without specific,
+# written prior permission.  M.I.T. makes no representations about the
+# suitability of this software for any purpose.  It is provided "as is"
+# without express or implied warranty.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# `make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.  It can only install one file at a time, a restriction
+# shared with many OS's install programs.
+
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit="${DOITPROG-}"
+
+
+# put in absolute paths if you don't have them in your path; or use env. vars.
+
+mvprog="${MVPROG-mv}"
+cpprog="${CPPROG-cp}"
+chmodprog="${CHMODPROG-chmod}"
+chownprog="${CHOWNPROG-chown}"
+chgrpprog="${CHGRPPROG-chgrp}"
+stripprog="${STRIPPROG-strip}"
+rmprog="${RMPROG-rm}"
+mkdirprog="${MKDIRPROG-mkdir}"
+
+transformbasename=""
+transform_arg=""
+instcmd="$mvprog"
+chmodcmd="$chmodprog 0755"
+chowncmd=""
+chgrpcmd=""
+stripcmd=""
+rmcmd="$rmprog -f"
+mvcmd="$mvprog"
+src=""
+dst=""
+dir_arg=""
+
+while [ x"$1" != x ]; do
+    case $1 in
+	-c) instcmd="$cpprog"
+	    shift
+	    continue;;
+
+	-d) dir_arg=true
+	    shift
+	    continue;;
+
+	-m) chmodcmd="$chmodprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-o) chowncmd="$chownprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-g) chgrpcmd="$chgrpprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-s) stripcmd="$stripprog"
+	    shift
+	    continue;;
+
+	-t=*) transformarg=`echo $1 | sed 's/-t=//'`
+	    shift
+	    continue;;
+
+	-b=*) transformbasename=`echo $1 | sed 's/-b=//'`
+	    shift
+	    continue;;
+
+	*)  if [ x"$src" = x ]
+	    then
+		src=$1
+	    else
+		# this colon is to work around a 386BSD /bin/sh bug
+		:
+		dst=$1
+	    fi
+	    shift
+	    continue;;
+    esac
+done
+
+if [ x"$src" = x ]
+then
+	echo "install:	no input file specified"
+	exit 1
+else
+	true
+fi
+
+if [ x"$dir_arg" != x ]; then
+	dst=$src
+	src=""
+	
+	if [ -d $dst ]; then
+		instcmd=:
+	else
+		instcmd=mkdir
+	fi
+else
+
+# Waiting for this to be detected by the "$instcmd $src $dsttmp" command
+# might cause directories to be created, which would be especially bad 
+# if $src (and thus $dsttmp) contains '*'.
+
+	if [ -f $src -o -d $src ]
+	then
+		true
+	else
+		echo "install:  $src does not exist"
+		exit 1
+	fi
+	
+	if [ x"$dst" = x ]
+	then
+		echo "install:	no destination specified"
+		exit 1
+	else
+		true
+	fi
+
+# If destination is a directory, append the input filename; if your system
+# does not like double slashes in filenames, you may need to add some logic
+
+	if [ -d $dst ]
+	then
+		dst="$dst"/`basename $src`
+	else
+		true
+	fi
+fi
+
+## this sed command emulates the dirname command
+dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`
+
+# Make sure that the destination directory exists.
+#  this part is taken from Noah Friedman's mkinstalldirs script
+
+# Skip lots of stat calls in the usual case.
+if [ ! -d "$dstdir" ]; then
+defaultIFS='	
+'
+IFS="${IFS-${defaultIFS}}"
+
+oIFS="${IFS}"
+# Some sh's can't handle IFS=/ for some reason.
+IFS='%'
+set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`
+IFS="${oIFS}"
+
+pathcomp=''
+
+while [ $# -ne 0 ] ; do
+	pathcomp="${pathcomp}${1}"
+	shift
+
+	if [ ! -d "${pathcomp}" ] ;
+        then
+		$mkdirprog "${pathcomp}"
+	else
+		true
+	fi
+
+	pathcomp="${pathcomp}/"
+done
+fi
+
+if [ x"$dir_arg" != x ]
+then
+	$doit $instcmd $dst &&
+
+	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; else true ; fi &&
+	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&
+	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; else true ; fi &&
+	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; else true ; fi
+else
+
+# If we're going to rename the final executable, determine the name now.
+
+	if [ x"$transformarg" = x ] 
+	then
+		dstfile=`basename $dst`
+	else
+		dstfile=`basename $dst $transformbasename | 
+			sed $transformarg`$transformbasename
+	fi
+
+# don't allow the sed command to completely eliminate the filename
+
+	if [ x"$dstfile" = x ] 
+	then
+		dstfile=`basename $dst`
+	else
+		true
+	fi
+
+# Make a temp file name in the proper directory.
+
+	dsttmp=$dstdir/#inst.$$#
+
+# Move or copy the file name to the temp name
+
+	$doit $instcmd $src $dsttmp &&
+
+	trap "rm -f ${dsttmp}" 0 &&
+
+# and set any options; do chmod last to preserve setuid bits
+
+# If any of these fail, we abort the whole thing.  If we want to
+# ignore errors from any of these, just make sure not to ignore
+# errors from the above "$doit $instcmd $src $dsttmp" command.
+
+	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&
+	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&
+	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&
+	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&
+
+# Now rename the file to the real destination.
+
+	$doit $rmcmd -f $dstdir/$dstfile &&
+	$doit $mvcmd $dsttmp $dstdir/$dstfile 
+
+fi &&
+
+
+exit 0
diff --git a/pppd/plugins/radius/radiusclient/lib/Makefile.am b/pppd/plugins/radius/radiusclient/lib/Makefile.am
new file mode 100644
index 0000000..c76201d
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/Makefile.am
@@ -0,0 +1,34 @@
+#
+# $Id: Makefile.am,v 1.1 2002/01/22 16:03:02 dfs Exp $
+#
+# Copyright (C) 1995,1997,1998 Lars Fenneberg
+#
+# See the file COPYRIGHT for the respective terms and conditions. 
+# If the file is missing contact me at lf@elemental.net 
+# and I'll send you a copy.
+#
+
+AUTOMAKE_OPTIONS = foreign
+
+RC_LOG_FACILITY = @RC_LOG_FACILITY@
+LIBVERSION = @LIBVERSION@
+
+INCLUDES = -I$(srcdir) -I$(top_srcdir)/include -I$(top_builddir)
+DEFS = @DEFS@ -DRC_LOG_FACILITY=$(RC_LOG_FACILITY)
+
+CLEANFILES = *~
+
+noinst_HEADERS = options.h
+
+#radiusclient_SOURCES = buildreq.c clientid.c env.c sendserver.c avpair.c \
+#	config.c dict.c ip_util.c log.c md5.c util.c lock.c
+
+#radiusclient_LIBADD = @LIBOBJS@
+
+#lib_LIBRARIES = radiusclient
+
+lib_LTLIBRARIES = libradiusclient.la
+libradiusclient_la_SOURCES = buildreq.c clientid.c env.c sendserver.c \
+	avpair.c config.c dict.c ip_util.c log.c md5.c util.c lock.c
+libradiusclient_la_LDFLAGS = -version-info $(LIBVERSION)
+libradiusclient_la_LIBADD = @LTLIBOBJS@
diff --git a/pppd/plugins/radius/radiusclient/lib/Makefile.in b/pppd/plugins/radius/radiusclient/lib/Makefile.in
new file mode 100644
index 0000000..1ac420c
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/Makefile.in
@@ -0,0 +1,356 @@
+# Makefile.in generated automatically by automake 1.3 from Makefile.am
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+#
+# $Id: Makefile.in,v 1.1 2002/01/22 16:03:02 dfs Exp $
+#
+# Copyright (C) 1995,1997,1998 Lars Fenneberg
+#
+# See the file COPYRIGHT for the respective terms and conditions. 
+# If the file is missing contact me at lf@elemental.net 
+# and I'll send you a copy.
+#
+
+
+SHELL = /bin/sh
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+sbindir = @sbindir@
+libexecdir = @libexecdir@
+datadir = @datadir@
+sysconfdir = @sysconfdir@
+sharedstatedir = @sharedstatedir@
+localstatedir = @localstatedir@
+libdir = @libdir@
+infodir = @infodir@
+mandir = @mandir@
+includedir = @includedir@
+oldincludedir = /usr/include
+
+DISTDIR =
+
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+
+top_builddir = ..
+
+ACLOCAL = @ACLOCAL@
+AUTOCONF = @AUTOCONF@
+AUTOMAKE = @AUTOMAKE@
+AUTOHEADER = @AUTOHEADER@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+transform = @program_transform_name@
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_alias = @build_alias@
+build_triplet = @build@
+host_alias = @host_alias@
+host_triplet = @host@
+target_alias = @target_alias@
+target_triplet = @target@
+AR = @AR@
+CC = @CC@
+LD = @LD@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+NM = @NM@
+PACKAGE = @PACKAGE@
+RANLIB = @RANLIB@
+RC_SECURE_PATH = @RC_SECURE_PATH@
+VERSION = @VERSION@
+pkgsysconfdir = @pkgsysconfdir@
+
+AUTOMAKE_OPTIONS = foreign
+
+RC_LOG_FACILITY = @RC_LOG_FACILITY@
+LIBVERSION = @LIBVERSION@
+
+INCLUDES = -I$(srcdir) -I$(top_srcdir)/include -I$(top_builddir)
+DEFS = @DEFS@ -DRC_LOG_FACILITY=$(RC_LOG_FACILITY)
+
+CLEANFILES = *~
+
+noinst_HEADERS = options.h
+
+#radiusclient_SOURCES = buildreq.c clientid.c env.c sendserver.c avpair.c \
+#	config.c dict.c ip_util.c log.c md5.c util.c lock.c
+
+#radiusclient_LIBADD = @LIBOBJS@
+
+#lib_LIBRARIES = radiusclient
+
+lib_LTLIBRARIES = libradiusclient.la
+libradiusclient_la_SOURCES = buildreq.c clientid.c env.c sendserver.c \
+	avpair.c config.c dict.c ip_util.c log.c md5.c util.c lock.c
+libradiusclient_la_LDFLAGS = -version-info $(LIBVERSION)
+libradiusclient_la_LIBADD = @LTLIBOBJS@
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = ../config.h
+CONFIG_CLEAN_FILES = 
+LTLIBRARIES =  $(lib_LTLIBRARIES)
+
+CPPFLAGS = @CPPFLAGS@
+LDFLAGS = @LDFLAGS@
+LIBS = @LIBS@
+libradiusclient_la_DEPENDENCIES =  @LTLIBOBJS@
+libradiusclient_la_OBJECTS =  buildreq.lo clientid.lo env.lo \
+sendserver.lo avpair.lo config.lo dict.lo ip_util.lo log.lo md5.lo \
+util.lo lock.lo
+CFLAGS = @CFLAGS@
+COMPILE = $(CC) $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)
+LINK = $(LIBTOOL) --mode=link $(CC) $(CFLAGS) $(LDFLAGS) -o $@
+HEADERS =  $(noinst_HEADERS)
+
+DIST_COMMON =  Makefile.am Makefile.in memcmp.c strcasecmp.c strdup.c \
+strerror.c
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = tar
+GZIP = --best
+SOURCES = $(libradiusclient_la_SOURCES)
+OBJECTS = $(libradiusclient_la_OBJECTS)
+
+all: Makefile $(LTLIBRARIES) $(HEADERS)
+
+.SUFFIXES:
+.SUFFIXES: .S .c .lo .o .s
+$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && $(AUTOMAKE) --foreign --include-deps lib/Makefile
+
+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+
+mostlyclean-libLTLIBRARIES:
+
+clean-libLTLIBRARIES:
+	-test -z "$(lib_LTLIBRARIES)" || rm -f $(lib_LTLIBRARIES)
+
+distclean-libLTLIBRARIES:
+
+maintainer-clean-libLTLIBRARIES:
+
+install-libLTLIBRARIES: $(lib_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libdir)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    echo "$(LIBTOOL)  --mode=install $(INSTALL_DATA) $$p $(DESTDIR)$(libdir)/$$p"; \
+	    $(LIBTOOL)  --mode=install $(INSTALL_DATA) $$p $(DESTDIR)$(libdir)/$$p; \
+	  else :; fi; \
+	done
+
+uninstall-libLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  $(LIBTOOL)  --mode=uninstall rm -f $(DESTDIR)$(libdir)/$$p; \
+	done
+
+.c.o:
+	$(COMPILE) -c $<
+
+.s.o:
+	$(COMPILE) -c $<
+
+.S.o:
+	$(COMPILE) -c $<
+
+mostlyclean-compile:
+	-rm -f *.o core *.core
+
+clean-compile:
+
+distclean-compile:
+	-rm -f *.tab.c
+
+maintainer-clean-compile:
+
+.c.lo:
+	$(LIBTOOL) --mode=compile $(COMPILE) -c $<
+
+.s.lo:
+	$(LIBTOOL) --mode=compile $(COMPILE) -c $<
+
+.S.lo:
+	$(LIBTOOL) --mode=compile $(COMPILE) -c $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+
+maintainer-clean-libtool:
+
+libradiusclient.la: $(libradiusclient_la_OBJECTS) $(libradiusclient_la_DEPENDENCIES)
+	$(LINK) -rpath $(libdir) $(libradiusclient_la_LDFLAGS) $(libradiusclient_la_OBJECTS) $(libradiusclient_la_LIBADD) $(LIBS)
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP)
+	here=`pwd` && cd $(srcdir) \
+	  && mkid -f$$here/ID $(SOURCES) $(HEADERS) $(LISP)
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$unique$(LISP)$$tags" \
+	  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $$unique $(LISP) -o $$here/TAGS)
+
+mostlyclean-tags:
+
+clean-tags:
+
+distclean-tags:
+	-rm -f TAGS ID
+
+maintainer-clean-tags:
+
+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
+
+subdir = lib
+
+distdir: $(DISTFILES)
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  test -f $(distdir)/$$file \
+	  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	  || cp -p $$d/$$file $(distdir)/$$file; \
+	done
+avpair.lo avpair.o: avpair.c ../config.h ../include/includes.h \
+	../include/radiusclient.h
+buildreq.lo buildreq.o: buildreq.c ../config.h ../include/includes.h \
+	../include/radiusclient.h
+clientid.lo clientid.o: clientid.c ../config.h ../include/includes.h \
+	../include/radiusclient.h
+config.lo config.o: config.c ../config.h ../include/includes.h \
+	../include/radiusclient.h options.h
+dict.lo dict.o: dict.c ../config.h ../include/includes.h \
+	../include/radiusclient.h
+env.lo env.o: env.c ../config.h ../include/includes.h \
+	../include/radiusclient.h
+ip_util.lo ip_util.o: ip_util.c ../config.h ../include/includes.h \
+	../include/radiusclient.h
+lock.lo lock.o: lock.c ../config.h ../include/includes.h
+log.lo log.o: log.c ../config.h ../include/includes.h \
+	../include/radiusclient.h
+md5.lo md5.o: md5.c ../config.h ../include/includes.h \
+	../include/radiusclient.h
+memcmp.o memcmp.lo: memcmp.c ../config.h ../include/includes.h
+sendserver.lo sendserver.o: sendserver.c ../config.h \
+	../include/includes.h ../include/radiusclient.h \
+	../include/pathnames.h
+strcasecmp.o strcasecmp.lo: strcasecmp.c ../config.h \
+	../include/includes.h
+strdup.o strdup.lo: strdup.c ../config.h ../include/includes.h
+strerror.o strerror.lo: strerror.c ../config.h ../include/includes.h
+util.lo util.o: util.c ../config.h ../include/includes.h \
+	../include/radiusclient.h
+
+info:
+dvi:
+check: all
+	$(MAKE)
+installcheck:
+install-exec: install-libLTLIBRARIES
+	@$(NORMAL_INSTALL)
+
+install-data: 
+	@$(NORMAL_INSTALL)
+
+install: install-exec install-data all
+	@:
+
+uninstall: uninstall-libLTLIBRARIES
+
+install-strip:
+	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install
+installdirs:
+	$(mkinstalldirs)  $(DATADIR)$(libdir)
+
+
+mostlyclean-generic:
+	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-rm -f Makefile $(DISTCLEANFILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+mostlyclean:  mostlyclean-libLTLIBRARIES mostlyclean-compile \
+		mostlyclean-libtool mostlyclean-tags \
+		mostlyclean-generic
+
+clean:  clean-libLTLIBRARIES clean-compile clean-libtool clean-tags \
+		clean-generic mostlyclean
+
+distclean:  distclean-libLTLIBRARIES distclean-compile distclean-libtool \
+		distclean-tags distclean-generic clean
+	-rm -f config.status
+	-rm -f libtool
+
+maintainer-clean:  maintainer-clean-libLTLIBRARIES \
+		maintainer-clean-compile maintainer-clean-libtool \
+		maintainer-clean-tags maintainer-clean-generic \
+		distclean
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+.PHONY: mostlyclean-libLTLIBRARIES distclean-libLTLIBRARIES \
+clean-libLTLIBRARIES maintainer-clean-libLTLIBRARIES \
+uninstall-libLTLIBRARIES install-libLTLIBRARIES mostlyclean-compile \
+distclean-compile clean-compile maintainer-clean-compile \
+mostlyclean-libtool distclean-libtool clean-libtool \
+maintainer-clean-libtool tags mostlyclean-tags distclean-tags \
+clean-tags maintainer-clean-tags distdir info dvi installcheck \
+install-exec install-data install uninstall all installdirs \
+mostlyclean-generic distclean-generic clean-generic \
+maintainer-clean-generic clean mostlyclean distclean maintainer-clean
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/pppd/plugins/radius/radiusclient/lib/avpair.c b/pppd/plugins/radius/radiusclient/lib/avpair.c
new file mode 100644
index 0000000..a20e24c
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/avpair.c
@@ -0,0 +1,766 @@
+/*
+ * $Id: avpair.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 1995 Lars Fenneberg
+ *
+ * Copyright 1992 Livingston Enterprises, Inc.
+ *
+ * Copyright 1992,1993, 1994,1995 The Regents of the University of Michigan
+ * and Merit Network, Inc. All Rights Reserved
+ *
+ * See the file COPYRIGHT for the respective terms and conditions.
+ * If the file is missing contact me at lf@elemental.net
+ * and I'll send you a copy.
+ *
+ */
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+
+static void rc_extract_vendor_specific_attributes(int attrlen,
+						  unsigned char *ptr,
+						  VALUE_PAIR **vp);
+/*
+ * Function: rc_avpair_add
+ *
+ * Purpose: add an attribute-value pair to the given list.
+ *
+ * Returns: pointer to added a/v pair upon success, NULL pointer upon failure.
+ *
+ * Remarks: Always appends the new pair to the end of the list.
+ *
+ */
+
+VALUE_PAIR *rc_avpair_add (VALUE_PAIR **list, int attrid, void *pval, int len,
+			   int vendorcode)
+{
+	VALUE_PAIR     *vp;
+
+	vp = rc_avpair_new (attrid, pval, len, vendorcode);
+
+	if (vp != (VALUE_PAIR *) NULL)
+	{
+		rc_avpair_insert (list, (VALUE_PAIR *) NULL, vp);
+	}
+
+	return vp;
+
+}
+
+/*
+ * Function: rc_avpair_assign
+ *
+ * Purpose: assign the given value to an attribute-value pair.
+ *
+ * Returns:  0 on success,
+ *	    -1 on failure.
+ *
+ */
+
+int rc_avpair_assign (VALUE_PAIR *vp, void *pval, int len)
+{
+	int	result = -1;
+
+	switch (vp->type)
+	{
+		case PW_TYPE_STRING:
+
+			if (((len == 0) && (strlen ((char *) pval)) > AUTH_STRING_LEN)
+			    || (len > AUTH_STRING_LEN)) {
+				rc_log(LOG_ERR, "rc_avpair_assign: bad attribute length");
+				return result;
+		    }
+
+			if (len > 0) {
+				memcpy(vp->strvalue, (char *)pval, len);
+				vp->strvalue[len] = '\0';
+				vp->lvalue = len;
+			} else {
+			strncpy (vp->strvalue, (char *) pval, AUTH_STRING_LEN);
+			vp->lvalue = strlen((char *) pval);
+			}
+
+			result = 0;
+			break;
+
+		case PW_TYPE_DATE:
+		case PW_TYPE_INTEGER:
+		case PW_TYPE_IPADDR:
+
+			vp->lvalue = * (UINT4 *) pval;
+
+			result = 0;
+			break;
+
+		default:
+			rc_log(LOG_ERR, "rc_avpair_assign: unknown attribute %d", vp->type);
+	}
+	return result;
+}
+
+/*
+ * Function: rc_avpair_new
+ *
+ * Purpose: make a new attribute-value pair with given parameters.
+ *
+ * Returns: pointer to generated a/v pair when successful, NULL when failure.
+ *
+ */
+
+VALUE_PAIR *rc_avpair_new (int attrid, void *pval, int len, int vendorcode)
+{
+	VALUE_PAIR     *vp = (VALUE_PAIR *) NULL;
+	DICT_ATTR      *pda;
+
+	if ((pda = rc_dict_getattr (attrid, vendorcode)) == (DICT_ATTR *) NULL)
+	{
+		rc_log(LOG_ERR,"rc_avpair_new: unknown attribute %d", attrid);
+	}
+	else
+	{
+		if ((vp = (VALUE_PAIR *) malloc (sizeof (VALUE_PAIR)))
+							!= (VALUE_PAIR *) NULL)
+		{
+			strncpy (vp->name, pda->name, sizeof (vp->name));
+			vp->attribute = attrid;
+			vp->vendorcode = vendorcode;
+			vp->next = (VALUE_PAIR *) NULL;
+			vp->type = pda->type;
+			if (rc_avpair_assign (vp, pval, len) == 0)
+			{
+				return vp;
+			}
+			free (vp);
+			vp = (VALUE_PAIR *) NULL;
+		}
+		else
+		{
+			rc_log(LOG_CRIT,"rc_avpair_new: out of memory");
+		}
+	}
+	return vp;
+}
+
+/*
+ *
+ * Function: rc_avpair_gen
+ *
+ * Purpose: takes attribute/value pairs from buffer and builds a
+ *	    value_pair list using allocated memory.
+ *
+ * Returns: value_pair list or NULL on failure
+ */
+
+VALUE_PAIR *rc_avpair_gen (AUTH_HDR *auth)
+{
+	int             length;
+	int             x_len;
+	int             attribute;
+	int             attrlen;
+	UINT4           lvalue;
+	unsigned char         *x_ptr;
+	unsigned char         *ptr;
+	DICT_ATTR      *attr;
+	VALUE_PAIR     *vp;
+	VALUE_PAIR     *pair;
+	unsigned char          hex[3];		/* For hex string conversion. */
+	char            buffer[256];
+
+	/*
+	 * Extract attribute-value pairs
+	 */
+	ptr = auth->data;
+	length = ntohs ((unsigned short) auth->length) - AUTH_HDR_LEN;
+	vp = (VALUE_PAIR *) NULL;
+
+	while (length > 0)
+	{
+		attribute = *ptr++;
+		attrlen = *ptr++;
+		attrlen -= 2;
+		if (attrlen < 0)
+		{
+			rc_log(LOG_ERR, "rc_avpair_gen: received attribute with invalid length");
+			break;
+		}
+
+		/* Handle vendor-specific specially */
+		if (attribute == PW_VENDOR_SPECIFIC) {
+		    rc_extract_vendor_specific_attributes(attrlen, ptr, &vp);
+		    ptr += attrlen;
+		    length -= (attrlen + 2);
+		    continue;
+		}
+		if ((attr = rc_dict_getattr (attribute, VENDOR_NONE)) == (DICT_ATTR *) NULL)
+		{
+			*buffer= '\0';	/* Initial length. */
+			for (x_ptr = ptr, x_len = attrlen ;
+				x_len > 0 ;
+				x_len--, x_ptr++)
+			{
+				sprintf (hex, "%2.2X", *x_ptr);
+				strcat (buffer, hex);
+			}
+			rc_log(LOG_WARNING, "rc_avpair_gen: received unknown attribute %d of length %d: 0x%s",
+				attribute, attrlen, buffer);
+		}
+		else
+		{
+			if ((pair =
+				(VALUE_PAIR *) malloc (sizeof (VALUE_PAIR))) ==
+					(VALUE_PAIR *) NULL)
+			{
+				rc_log(LOG_CRIT, "rc_avpair_gen: out of memory");
+				rc_avpair_free(vp);
+				return NULL;
+			}
+			strcpy (pair->name, attr->name);
+			pair->attribute = attr->value;
+			pair->vendorcode = VENDOR_NONE;
+			pair->type = attr->type;
+			pair->next = (VALUE_PAIR *) NULL;
+
+			switch (attr->type)
+			{
+
+			    case PW_TYPE_STRING:
+				memcpy (pair->strvalue, (char *) ptr, (size_t) attrlen);
+				pair->strvalue[attrlen] = '\0';
+				pair->lvalue = attrlen;
+				rc_avpair_insert (&vp, (VALUE_PAIR *) NULL, pair);
+				break;
+
+			    case PW_TYPE_INTEGER:
+			    case PW_TYPE_IPADDR:
+				memcpy ((char *) &lvalue, (char *) ptr,
+					sizeof (UINT4));
+				pair->lvalue = ntohl (lvalue);
+				rc_avpair_insert (&vp, (VALUE_PAIR *) NULL, pair);
+				break;
+
+			    default:
+				rc_log(LOG_WARNING, "rc_avpair_gen: %s has unknown type", attr->name);
+				free (pair);
+				break;
+			}
+
+		}
+		ptr += attrlen;
+		length -= attrlen + 2;
+	}
+	return (vp);
+}
+
+/*
+ * Function: rc_extract_vendor_specific_attributes
+ *
+ * Purpose: Extracts vendor-specific attributes, assuming they are in
+ *          the "SHOULD" format recommended by RCF 2138.
+ *
+ * Returns: found value_pair
+ *
+ */
+static void rc_extract_vendor_specific_attributes(int attrlen,
+						  unsigned char *ptr,
+						  VALUE_PAIR **vp)
+{
+    int vendor_id;
+    int vtype;
+    int vlen;
+    UINT4 lvalue;
+    DICT_ATTR *attr;
+    VALUE_PAIR *pair;
+
+    /* ptr is sitting at vendor-ID */
+    if (attrlen < 8) {
+	/* Nothing to see here... */
+	return;
+    }
+
+    /* High-order octet of Vendor-Id must be zero (RFC2138) */
+    if (*ptr) {
+	return;
+    }
+
+    /* Extract vendor_id */
+    vendor_id = (int) (
+	((unsigned int) ptr[1]) * 256 * 256 +
+	((unsigned int) ptr[2]) * 256 +
+	((unsigned int) ptr[3]));
+    /* Bump ptr up to contents */
+    ptr += 4;
+
+    /* Set attrlen to length of data */
+    attrlen -= 4;
+    for (; attrlen; attrlen -= vlen+2, ptr += vlen) {
+	vtype = *ptr++;
+	vlen = *ptr++;
+	vlen -= 2;
+	if (vlen < 0 || vlen > attrlen - 2) {
+	    /* Do not log an error.  We are supposed to be able to cope with
+	       arbitrary vendor-specific gunk */
+	    return;
+	}
+	/* Looks plausible... */
+	if ((attr = rc_dict_getattr(vtype, vendor_id)) == NULL) {
+	    continue;
+	}
+
+	/* TODO: Check that length matches data size!!!!! */
+	pair = (VALUE_PAIR *) malloc(sizeof(VALUE_PAIR));
+	if (!pair) {
+	    rc_log(LOG_CRIT, "rc_avpair_gen: out of memory");
+	    return;
+	}
+	strcpy(pair->name, attr->name);
+	pair->attribute = attr->value;
+	pair->vendorcode = vendor_id;
+	pair->type = attr->type;
+	pair->next = NULL;
+	switch (attr->type) {
+	case PW_TYPE_STRING:
+	    memcpy (pair->strvalue, (char *) ptr, (size_t) vlen);
+	    pair->strvalue[vlen] = '\0';
+	    pair->lvalue = vlen;
+	    rc_avpair_insert (vp, (VALUE_PAIR *) NULL, pair);
+	    break;
+
+	case PW_TYPE_INTEGER:
+	case PW_TYPE_IPADDR:
+	    memcpy ((char *) &lvalue, (char *) ptr,
+		    sizeof (UINT4));
+	    pair->lvalue = ntohl (lvalue);
+	    rc_avpair_insert (vp, (VALUE_PAIR *) NULL, pair);
+	    break;
+
+	default:
+	    rc_log(LOG_WARNING, "rc_avpair_gen: %s has unknown type", attr->name);
+	    free (pair);
+	    break;
+	}
+    }
+}
+
+/*
+ * Function: rc_avpair_get
+ *
+ * Purpose: Find the first attribute value-pair (which matches the given
+ *          attribute) from the specified value-pair list.
+ *
+ * Returns: found value_pair
+ *
+ */
+
+VALUE_PAIR *rc_avpair_get (VALUE_PAIR *vp, UINT4 attr)
+{
+	for (; vp != (VALUE_PAIR *) NULL && vp->attribute != attr; vp = vp->next)
+	{
+		continue;
+	}
+	return (vp);
+}
+
+/*
+ * Function: rc_avpair_insert
+ *
+ * Purpose: Given the address of an existing list "a" and a pointer
+ *	    to an entry "p" in that list, add the value pair "b" to
+ *	    the "a" list after the "p" entry.  If "p" is NULL, add
+ *	    the value pair "b" to the end of "a".
+ *
+ */
+
+void rc_avpair_insert (VALUE_PAIR **a, VALUE_PAIR *p, VALUE_PAIR *b)
+{
+	VALUE_PAIR     *this_node = NULL;
+	VALUE_PAIR     *vp;
+
+	if (b->next != (VALUE_PAIR *) NULL)
+	{
+		rc_log(LOG_CRIT, "rc_avpair_insert: value pair (0x%p) next ptr. (0x%p) not NULL", b, b->next);
+		abort ();
+	}
+
+	if (*a == (VALUE_PAIR *) NULL)
+	{
+		*a = b;
+		return;
+	}
+
+	vp = *a;
+
+	if ( p == (VALUE_PAIR *) NULL) /* run to end of "a" list */
+	{
+		while (vp != (VALUE_PAIR *) NULL)
+		{
+			this_node = vp;
+			vp = vp->next;
+		}
+	}
+	else /* look for the "p" entry in the "a" list */
+	{
+		this_node = *a;
+		while (this_node != (VALUE_PAIR *) NULL)
+		{
+			if (this_node == p)
+			{
+				break;
+			}
+			this_node = this_node->next;
+		}
+	}
+
+	b->next = this_node->next;
+	this_node->next = b;
+
+	return;
+}
+
+/*
+ * Function: rc_avpair_free
+ *
+ * Purpose: frees all value_pairs in the list
+ *
+ */
+
+void rc_avpair_free (VALUE_PAIR *pair)
+{
+	VALUE_PAIR     *next;
+
+	while (pair != (VALUE_PAIR *) NULL)
+	{
+		next = pair->next;
+		free (pair);
+		pair = next;
+	}
+}
+
+/*
+ * Function: rc_fieldcpy
+ *
+ * Purpose: Copy a data field from the buffer.  Advance the buffer
+ *          past the data field.
+ *
+ */
+
+static void rc_fieldcpy (char *string, char **uptr)
+{
+	char           *ptr;
+
+	ptr = *uptr;
+	if (*ptr == '"')
+	{
+		ptr++;
+		while (*ptr != '"' && *ptr != '\0' && *ptr != '\n')
+		{
+			*string++ = *ptr++;
+		}
+		*string = '\0';
+		if (*ptr == '"')
+		{
+			ptr++;
+		}
+		*uptr = ptr;
+		return;
+	}
+
+	while (*ptr != ' ' && *ptr != '\t' && *ptr != '\0' && *ptr != '\n' &&
+			*ptr != '=' && *ptr != ',')
+	{
+		*string++ = *ptr++;
+	}
+	*string = '\0';
+	*uptr = ptr;
+	return;
+}
+
+
+/*
+ * Function: rc_avpair_parse
+ *
+ * Purpose: parses the buffer to extract the attribute-value pairs.
+ *
+ * Returns: 0 = successful parse of attribute-value pair,
+ *	   -1 = syntax (or other) error detected.
+ *
+ */
+
+#define PARSE_MODE_NAME		0
+#define PARSE_MODE_EQUAL	1
+#define PARSE_MODE_VALUE	2
+#define PARSE_MODE_INVALID	3
+
+int rc_avpair_parse (char *buffer, VALUE_PAIR **first_pair)
+{
+	int             mode;
+	char            attrstr[AUTH_ID_LEN];
+	char            valstr[AUTH_ID_LEN];
+	DICT_ATTR      *attr = NULL;
+	DICT_VALUE     *dval;
+	VALUE_PAIR     *pair;
+	VALUE_PAIR     *link;
+	struct tm      *tm;
+	time_t          timeval;
+
+	mode = PARSE_MODE_NAME;
+	while (*buffer != '\n' && *buffer != '\0')
+	{
+		if (*buffer == ' ' || *buffer == '\t')
+		{
+			buffer++;
+			continue;
+		}
+
+		switch (mode)
+		{
+		    case PARSE_MODE_NAME:		/* Attribute Name */
+			rc_fieldcpy (attrstr, &buffer);
+			if ((attr =
+				rc_dict_findattr (attrstr)) == (DICT_ATTR *) NULL)
+			{
+				rc_log(LOG_ERR, "rc_avpair_parse: unknown attribute");
+				if (*first_pair) {
+					rc_avpair_free(*first_pair);
+					*first_pair = (VALUE_PAIR *) NULL;
+				}
+				return (-1);
+			}
+			mode = PARSE_MODE_EQUAL;
+			break;
+
+		    case PARSE_MODE_EQUAL:		/* Equal sign */
+			if (*buffer == '=')
+			{
+				mode = PARSE_MODE_VALUE;
+				buffer++;
+			}
+			else
+			{
+				rc_log(LOG_ERR, "rc_avpair_parse: missing or misplaced equal sign");
+				if (*first_pair) {
+					rc_avpair_free(*first_pair);
+					*first_pair = (VALUE_PAIR *) NULL;
+				}
+				return (-1);
+			}
+			break;
+
+		    case PARSE_MODE_VALUE:		/* Value */
+			rc_fieldcpy (valstr, &buffer);
+
+			if ((pair =
+				(VALUE_PAIR *) malloc (sizeof (VALUE_PAIR)))
+							== (VALUE_PAIR *) NULL)
+			{
+				rc_log(LOG_CRIT, "rc_avpair_parse: out of memory");
+				if (*first_pair) {
+					rc_avpair_free(*first_pair);
+					*first_pair = (VALUE_PAIR *) NULL;
+				}
+				return (-1);
+			}
+			strcpy (pair->name, attr->name);
+			pair->attribute = attr->value;
+			pair->type = attr->type;
+
+			switch (pair->type)
+			{
+
+			    case PW_TYPE_STRING:
+				strcpy (pair->strvalue, valstr);
+				pair->lvalue = strlen(valstr);
+				break;
+
+			    case PW_TYPE_INTEGER:
+				if (isdigit (*valstr))
+				{
+					pair->lvalue = atoi (valstr);
+				}
+				else
+				{
+					if ((dval = rc_dict_findval (valstr))
+							== (DICT_VALUE *) NULL)
+					{
+						rc_log(LOG_ERR, "rc_avpair_parse: unknown attribute value: %s", valstr);
+						if (*first_pair) {
+							rc_avpair_free(*first_pair);
+							*first_pair = (VALUE_PAIR *) NULL;
+						}
+						free (pair);
+						return (-1);
+					}
+					else
+					{
+						pair->lvalue = dval->value;
+					}
+				}
+				break;
+
+			    case PW_TYPE_IPADDR:
+				pair->lvalue = rc_get_ipaddr(valstr);
+				break;
+
+			    case PW_TYPE_DATE:
+				timeval = time (0);
+				tm = localtime (&timeval);
+				tm->tm_hour = 0;
+				tm->tm_min = 0;
+				tm->tm_sec = 0;
+				rc_str2tm (valstr, tm);
+#ifdef TIMELOCAL
+				pair->lvalue = (UINT4) timelocal (tm);
+#else	/* TIMELOCAL */
+				pair->lvalue = (UINT4) mktime (tm);
+#endif	/* TIMELOCAL */
+				break;
+
+			    default:
+				rc_log(LOG_ERR, "rc_avpair_parse: unknown attribute type %d", pair->type);
+				if (*first_pair) {
+					rc_avpair_free(*first_pair);
+					*first_pair = (VALUE_PAIR *) NULL;
+				}
+				free (pair);
+				return (-1);
+			}
+			pair->next = (VALUE_PAIR *) NULL;
+
+			if (*first_pair == (VALUE_PAIR *) NULL)
+			{
+				*first_pair = pair;
+			}
+			else
+			{
+				link = *first_pair;
+				while (link->next != (VALUE_PAIR *) NULL)
+				{
+					link = link->next;
+				}
+				link->next = pair;
+			}
+
+			mode = PARSE_MODE_NAME;
+			break;
+
+		    default:
+			mode = PARSE_MODE_NAME;
+			break;
+		}
+	}
+	return (0);
+}
+
+/*
+ * Function: rc_avpair_tostr
+ *
+ * Purpose: Translate an av_pair into two strings
+ *
+ * Returns: 0 on success, -1 on failure
+ *
+ */
+
+int rc_avpair_tostr (VALUE_PAIR *pair, char *name, int ln, char *value, int lv)
+{
+	DICT_VALUE     *dval;
+	char            buffer[32];
+	struct in_addr  inad;
+	unsigned char         *ptr;
+
+	*name = *value = '\0';
+
+	if (!pair || pair->name[0] == '\0') {
+		rc_log(LOG_ERR, "rc_avpair_tostr: pair is NULL or empty");
+		return (-1);
+	}
+
+	strncpy(name, pair->name, (size_t) ln);
+
+	switch (pair->type)
+	{
+	    case PW_TYPE_STRING:
+		lv--;
+		ptr = (unsigned char *) pair->strvalue;
+		while (*ptr != '\0')
+		{
+			if (!(isprint (*ptr)))
+			{
+				sprintf (buffer, "\\%03o", *ptr);
+				strncat(value, buffer, (size_t) lv);
+				lv -= 4;
+				if (lv < 0) break;
+			}
+			else
+			{
+				strncat(value, ptr, 1);
+				lv--;
+				if (lv < 0) break;
+			}
+			ptr++;
+		}
+		break;
+
+	    case PW_TYPE_INTEGER:
+		dval = rc_dict_getval (pair->lvalue, pair->name);
+		if (dval != (DICT_VALUE *) NULL)
+		{
+			strncpy(value, dval->name, (size_t) lv-1);
+		}
+		else
+		{
+			sprintf (buffer, "%ld", pair->lvalue);
+			strncpy(value, buffer, (size_t) lv);
+		}
+		break;
+
+	    case PW_TYPE_IPADDR:
+		inad.s_addr = htonl(pair->lvalue);
+		strncpy (value, inet_ntoa (inad), (size_t) lv-1);
+		break;
+
+	    case PW_TYPE_DATE:
+		strftime (buffer, sizeof (buffer), "%m/%d/%y %H:%M:%S",
+			  gmtime ((time_t *) & pair->lvalue));
+		strncpy(value, buffer, lv-1);
+		break;
+
+	    default:
+		rc_log(LOG_ERR, "rc_avpair_tostr: unknown attribute type %d", pair->type);
+		return (-1);
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * Function: rc_avpair_readin
+ *
+ * Purpose: get a sequence of attribute value pairs from the file input
+ *	    and make them into a list of value_pairs
+ *
+ */
+
+VALUE_PAIR *rc_avpair_readin(FILE *input)
+{
+	VALUE_PAIR *vp = NULL;
+	char buffer[1024], *q;
+
+	while (fgets(buffer, sizeof(buffer), input) != NULL)
+	{
+		q = buffer;
+
+		while(*q && isspace(*q)) q++;
+
+		if ((*q == '\n') || (*q == '#') || (*q == '\0'))
+			continue;
+
+		if (rc_avpair_parse(q, &vp) < 0) {
+			rc_log(LOG_ERR, "rc_avpair_readin: malformed attribute: %s", buffer);
+			rc_avpair_free(vp);
+			return NULL;
+		}
+	}
+
+	return vp;
+}
diff --git a/pppd/plugins/radius/radiusclient/lib/buildreq.c b/pppd/plugins/radius/radiusclient/lib/buildreq.c
new file mode 100644
index 0000000..507a25c
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/buildreq.c
@@ -0,0 +1,370 @@
+/*
+ * $Id: buildreq.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 1995,1997 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions.
+ * If the file is missing contact me at lf@elemental.net
+ * and I'll send you a copy.
+ *
+ */
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+
+unsigned char rc_get_seqnbr(void);
+
+/*
+ * Function: rc_buildreq
+ *
+ * Purpose: builds a skeleton RADIUS request using information from the
+ *	    config file.
+ *
+ */
+
+void rc_buildreq(SEND_DATA *data, int code, char *server, unsigned short port,
+		 int timeout, int retries)
+{
+	data->server = server;
+	data->svc_port = port;
+	data->seq_nbr = rc_get_seqnbr();
+	data->timeout = timeout;
+	data->retries = retries;
+	data->code = code;
+}
+
+/*
+ * Function: rc_guess_seqnbr
+ *
+ * Purpose: return a random sequence number
+ *
+ */
+
+static unsigned char rc_guess_seqnbr(void)
+{
+	srandom((unsigned int)(time(NULL)+getpid()));
+	return (unsigned char)(random() & UCHAR_MAX);
+}
+
+/*
+ * Function: rc_get_seqnbr
+ *
+ * Purpose: generate a sequence number
+ *
+ */
+
+unsigned char rc_get_seqnbr(void)
+{
+	FILE *sf;
+	int tries = 1;
+	int seq_nbr;
+	char *seqfile = rc_conf_str("seqfile");
+
+	if ((sf = fopen(seqfile, "a+")) == NULL)
+	{
+		rc_log(LOG_ERR,"rc_get_seqnbr: couldn't open sequence file %s: %s", seqfile, strerror(errno));
+		/* well, so guess a sequence number */
+		return rc_guess_seqnbr();
+	}
+
+	while (do_lock_exclusive(fileno(sf))!= 0)
+	{
+		if (errno != EWOULDBLOCK) {
+			rc_log(LOG_ERR, "rc_get_seqnbr: flock failure: %s: %s", seqfile, strerror(errno));
+			fclose(sf);
+			return rc_guess_seqnbr();
+		}
+		tries++;
+		if (tries <= 10)
+			rc_mdelay(500);
+		else
+			break;
+	}
+
+	if (tries > 10) {
+		rc_log(LOG_ERR,"rc_get_seqnbr: couldn't get lock after %d tries: %s", tries-1, seqfile);
+		fclose(sf);
+		return rc_guess_seqnbr();
+	}
+
+	rewind(sf);
+	if (fscanf(sf, "%d", &seq_nbr) != 1) {
+		rc_log(LOG_ERR,"rc_get_seqnbr: fscanf failure: %s", seqfile);
+		seq_nbr = rc_guess_seqnbr();
+	}
+
+	rewind(sf);
+	ftruncate(fileno(sf),0);
+	fprintf(sf,"%d\n", (seq_nbr+1) & UCHAR_MAX);
+
+	fflush(sf); /* fflush because a process may read it between the do_unlock and fclose */
+
+	if (do_unlock(fileno(sf)) != 0)
+		rc_log(LOG_ERR, "rc_get_seqnbr: couldn't release lock on %s: %s", seqfile, strerror(errno));
+
+	fclose(sf);
+
+	return (unsigned char)seq_nbr;
+}
+
+/*
+ * Function: rc_auth
+ *
+ * Purpose: Builds an authentication request for port id client_port
+ *	    with the value_pairs send and submits it to a server
+ *
+ * Returns: received value_pairs in received, messages from the server in msg
+ *	    and 0 on success, negative on failure as return value
+ *
+ */
+
+int rc_auth(UINT4 client_port, VALUE_PAIR *send, VALUE_PAIR **received,
+	    char *msg)
+{
+	SEND_DATA       data;
+	UINT4		client_id;
+	int		result;
+	int		i;
+	SERVER		*authserver = rc_conf_srv("authserver");
+	int		timeout = rc_conf_int("radius_timeout");
+	int		retries = rc_conf_int("radius_retries");
+
+	data.send_pairs = send;
+	data.receive_pairs = NULL;
+
+	/*
+	 * Fill in NAS-IP-Address
+	 */
+
+	if ((client_id = rc_own_ipaddress()) == 0)
+		return (ERROR_RC);
+
+	if (rc_avpair_add(&(data.send_pairs), PW_NAS_IP_ADDRESS, &client_id, 0, VENDOR_NONE) == NULL)
+		return (ERROR_RC);
+
+	/*
+	 * Fill in NAS-Port
+	 */
+
+	if (rc_avpair_add(&(data.send_pairs), PW_NAS_PORT, &client_port, 0, VENDOR_NONE) == NULL)
+		return (ERROR_RC);
+
+	result = ERROR_RC;
+	for(i=0; (i<authserver->max) && (result != OK_RC) && (result != BADRESP_RC)
+		; i++)
+	{
+		if (data.receive_pairs != NULL) {
+			rc_avpair_free(data.receive_pairs);
+			data.receive_pairs = NULL;
+		}
+		rc_buildreq(&data, PW_ACCESS_REQUEST, authserver->name[i],
+			    authserver->port[i], timeout, retries);
+
+		result = rc_send_server (&data, msg);
+	}
+
+	*received = data.receive_pairs;
+
+	return result;
+}
+
+/*
+ * Function: rc_auth_proxy
+ *
+ * Purpose: Builds an authentication request
+ *	    with the value_pairs send and submits it to a server.
+ *	    Works for a proxy; does not add IP address, and does
+ *	    does not rely on config file.
+ *
+ * Returns: received value_pairs in received, messages from the server in msg
+ *	    and 0 on success, negative on failure as return value
+ *
+ */
+
+int rc_auth_proxy(VALUE_PAIR *send, VALUE_PAIR **received, char *msg)
+{
+	SEND_DATA       data;
+	int		result;
+	int		i;
+	SERVER		*authserver = rc_conf_srv("authserver");
+	int		timeout = rc_conf_int("radius_timeout");
+	int		retries = rc_conf_int("radius_retries");
+
+	data.send_pairs = send;
+	data.receive_pairs = NULL;
+
+	result = ERROR_RC;
+	for(i=0; (i<authserver->max) && (result != OK_RC) && (result != BADRESP_RC)
+		; i++)
+	{
+		if (data.receive_pairs != NULL) {
+			rc_avpair_free(data.receive_pairs);
+			data.receive_pairs = NULL;
+		}
+		rc_buildreq(&data, PW_ACCESS_REQUEST, authserver->name[i],
+			    authserver->port[i], timeout, retries);
+
+		result = rc_send_server (&data, msg);
+	}
+
+	*received = data.receive_pairs;
+
+	return result;
+}
+
+
+/*
+ * Function: rc_acct
+ *
+ * Purpose: Builds an accounting request for port id client_port
+ *	    with the value_pairs send
+ *
+ * Remarks: NAS-IP-Address, NAS-Port and Acct-Delay-Time get filled
+ *	    in by this function, the rest has to be supplied.
+ */
+
+int rc_acct(UINT4 client_port, VALUE_PAIR *send)
+{
+	SEND_DATA       data;
+	VALUE_PAIR	*adt_vp;
+	UINT4		client_id;
+	int		result;
+	time_t		start_time, dtime;
+	char		msg[4096];
+	int		i;
+	SERVER		*acctserver = rc_conf_srv("acctserver");
+	int		timeout = rc_conf_int("radius_timeout");
+	int		retries = rc_conf_int("radius_retries");
+
+	data.send_pairs = send;
+	data.receive_pairs = NULL;
+
+	/*
+	 * Fill in NAS-IP-Address
+	 */
+
+	if ((client_id = rc_own_ipaddress()) == 0)
+		return (ERROR_RC);
+
+	if (rc_avpair_add(&(data.send_pairs), PW_NAS_IP_ADDRESS, &client_id, 0, VENDOR_NONE) == NULL)
+		return (ERROR_RC);
+
+	/*
+	 * Fill in NAS-Port
+	 */
+
+	if (rc_avpair_add(&(data.send_pairs), PW_NAS_PORT, &client_port, 0, VENDOR_NONE) == NULL)
+		return (ERROR_RC);
+
+	/*
+	 * Fill in Acct-Delay-Time
+	 */
+
+	dtime = 0;
+	if ((adt_vp = rc_avpair_add(&(data.send_pairs), PW_ACCT_DELAY_TIME, &dtime, 0, VENDOR_NONE)) == NULL)
+		return (ERROR_RC);
+
+	start_time = time(NULL);
+	result = ERROR_RC;
+	for(i=0; (i<acctserver->max) && (result != OK_RC) && (result != BADRESP_RC)
+		; i++)
+	{
+		if (data.receive_pairs != NULL) {
+			rc_avpair_free(data.receive_pairs);
+			data.receive_pairs = NULL;
+		}
+		rc_buildreq(&data, PW_ACCOUNTING_REQUEST, acctserver->name[i],
+			    acctserver->port[i], timeout, retries);
+
+		dtime = time(NULL) - start_time;
+		rc_avpair_assign(adt_vp, &dtime, 0);
+
+		result = rc_send_server (&data, msg);
+	}
+
+	rc_avpair_free(data.receive_pairs);
+
+	return result;
+}
+
+/*
+ * Function: rc_acct_proxy
+ *
+ * Purpose: Builds an accounting request with the value_pairs send
+ *
+ */
+
+int rc_acct_proxy(VALUE_PAIR *send)
+{
+	SEND_DATA       data;
+	int		result;
+	char		msg[4096];
+	int		i;
+	SERVER		*acctserver = rc_conf_srv("authserver");
+	int		timeout = rc_conf_int("radius_timeout");
+	int		retries = rc_conf_int("radius_retries");
+
+	data.send_pairs = send;
+	data.receive_pairs = NULL;
+
+	result = ERROR_RC;
+	for(i=0; (i<acctserver->max) && (result != OK_RC) && (result != BADRESP_RC)
+		; i++)
+	{
+		if (data.receive_pairs != NULL) {
+			rc_avpair_free(data.receive_pairs);
+			data.receive_pairs = NULL;
+		}
+		rc_buildreq(&data, PW_ACCOUNTING_REQUEST, acctserver->name[i],
+			    acctserver->port[i], timeout, retries);
+
+		result = rc_send_server (&data, msg);
+	}
+
+	rc_avpair_free(data.receive_pairs);
+
+	return result;
+}
+
+/*
+ * Function: rc_check
+ *
+ * Purpose: ask the server hostname on the specified port for a
+ *	    status message
+ *
+ */
+
+int rc_check(char *host, unsigned short port, char *msg)
+{
+	SEND_DATA       data;
+	int		result;
+	UINT4		client_id, service_type;
+	int		timeout = rc_conf_int("radius_timeout");
+	int		retries = rc_conf_int("radius_retries");
+
+	data.send_pairs = data.receive_pairs = NULL;
+
+	/*
+	 * Fill in NAS-IP-Address, although it isn't neccessary
+	 */
+
+	if ((client_id = rc_own_ipaddress()) == 0)
+		return (ERROR_RC);
+
+	rc_avpair_add(&(data.send_pairs), PW_NAS_IP_ADDRESS, &client_id, 0, VENDOR_NONE);
+
+	/*
+	 * Fill in Service-Type
+	 */
+
+	service_type = PW_ADMINISTRATIVE;
+	rc_avpair_add(&(data.send_pairs), PW_SERVICE_TYPE, &service_type, 0, VENDOR_NONE);
+
+	rc_buildreq(&data, PW_STATUS_SERVER, host, port, timeout, retries);
+	result = rc_send_server (&data, msg);
+
+	rc_avpair_free(data.receive_pairs);
+
+	return result;
+}
diff --git a/pppd/plugins/radius/radiusclient/lib/clientid.c b/pppd/plugins/radius/radiusclient/lib/clientid.c
new file mode 100644
index 0000000..e86cac0
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/clientid.c
@@ -0,0 +1,122 @@
+/*
+ * $Id: clientid.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 1995,1996,1997 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+
+struct map2id_s {
+	char *name;
+	UINT4 id;
+
+	struct map2id_s *next;
+};
+
+static struct map2id_s *map2id_list = NULL; 
+
+/*
+ * Function: rc_read_mapfile
+ *
+ * Purpose: Read in the ttyname to port id map file
+ *
+ * Arguments: the file name of the map file
+ *
+ * Returns: zero on success, negative integer on failure 
+ */
+
+int rc_read_mapfile(char *filename)
+{
+	char buffer[1024];
+	FILE *mapfd;
+	char *c, *name, *id, *q;
+	struct map2id_s *p;
+	int lnr = 0;
+
+        if ((mapfd = fopen(filename,"r")) == NULL)
+        {
+		rc_log(LOG_ERR,"rc_read_mapfile: can't read %s: %s", filename, strerror(errno));                                                        
+		return (-1);
+	}
+	
+#define SKIP(p) while(*p && isspace(*p)) p++;
+
+        while (fgets(buffer, sizeof(buffer), mapfd) != NULL)
+        {
+        	lnr++;
+        
+		q = buffer;
+		
+                SKIP(q);
+                                                
+                if ((*q == '\n') || (*q == '#') || (*q == '\0'))
+			continue;
+
+		if (( c = strchr(q, ' ')) || (c = strchr(q,'\t'))) {
+
+			*c = '\0'; c++;
+			SKIP(c);
+			
+			name = q;
+			id = c;
+			
+			if ((p = (struct map2id_s *)malloc(sizeof(*p))) == NULL) {
+				rc_log(LOG_CRIT,"rc_read_mapfile: out of memory");
+				return (-1);
+			}
+			
+			p->name = strdup(name);
+			p->id = atoi(id);
+			p->next = map2id_list;
+			map2id_list = p;			
+		
+		} else {
+			
+			rc_log(LOG_ERR, "rc_read_mapfile: malformed line in %s, line %d", filename, lnr);  
+			return (-1);
+
+		}
+	}
+	
+#undef SKIP
+
+	fclose(mapfd);
+
+	return 0;
+}
+
+/*
+ * Function: rc_map2id
+ *
+ * Purpose: Map ttyname to port id
+ *
+ * Arguments: full pathname of the tty
+ *
+ * Returns: port id, zero if no entry found
+ */
+
+UINT4 rc_map2id(char *name)
+{
+	struct map2id_s *p;
+	char ttyname[PATH_MAX];
+
+	*ttyname = '\0';
+	if (*name != '/')
+		strcpy(ttyname, "/dev/");
+		
+	strncat(ttyname, name, sizeof(ttyname));
+	
+	for(p = map2id_list; p; p = p->next)
+		if (!strcmp(ttyname, p->name)) return p->id;
+
+	rc_log(LOG_WARNING,"rc_map2id: can't find tty %s in map database", ttyname);
+	
+	return 0;
+}
diff --git a/pppd/plugins/radius/radiusclient/lib/config.c b/pppd/plugins/radius/radiusclient/lib/config.c
new file mode 100644
index 0000000..0b78c86
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/config.c
@@ -0,0 +1,555 @@
+/*
+ * $Id: config.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 1995,1996,1997 Lars Fenneberg
+ *
+ * Copyright 1992 Livingston Enterprises, Inc.
+ *
+ * Copyright 1992,1993, 1994,1995 The Regents of the University of Michigan 
+ * and Merit Network, Inc. All Rights Reserved
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+#include <options.h>
+
+static int test_config(char *);
+
+/*
+ * Function: find_option
+ *
+ * Purpose: find an option in the option list
+ *
+ * Returns: pointer to option on success, NULL otherwise
+ */
+ 
+static OPTION *find_option(char *optname, unsigned int type)
+{
+	int i;
+
+	/* there're so few options that a binary search seems not necessary */
+	for (i = 0; i < num_options; i++) {
+		if (!strcmp(config_options[i].name, optname) &&
+		    (config_options[i].type & type))
+		    	return &config_options[i];
+	}
+
+	return NULL;
+}
+
+/*
+ * Function: set_option_...
+ *
+ * Purpose: set a specific option doing type conversions
+ *
+ * Returns: 0 on success, -1 on failure
+ */
+
+static int set_option_str(char *filename, int line, OPTION *option, char *p)
+{ 
+	if (p)
+		option->val = (void *) strdup(p);
+	else
+		option->val = NULL;
+
+	return 0;
+}
+
+static int set_option_int(char *filename, int line, OPTION *option, char *p)
+{
+	int *iptr;
+
+	if (p == NULL) {
+		rc_log(LOG_ERR, "%s: line %d: bogus option value", filename, line);
+		return (-1);
+	}
+
+	if ((iptr = (int *) malloc(sizeof(iptr))) == NULL) {
+		rc_log(LOG_CRIT, "read_config: out of memory");
+		return (-1);
+	}
+	
+	*iptr = atoi(p);				
+	option->val = (void *) iptr;
+
+	return 0;
+}
+
+static int set_option_srv(char *filename, int line, OPTION *option, char *p)
+{
+	SERVER *serv;
+	char *q;
+	struct servent *svp;
+	int i;
+
+	if (p == NULL) {
+		rc_log(LOG_ERR, "%s: line %d: bogus option value", filename, line);
+		return (-1);
+	}
+
+	serv = (SERVER *) option->val;
+
+	for (i = 0; i < serv->max; i++) {
+		free(serv->name[i]);
+	}
+	serv->max = 0;
+
+	while ((p = strtok(p, ", \t")) != NULL) {
+
+		if ((q = strchr(p,':')) != NULL) {
+			*q = '\0';
+			q++;
+			serv->port[serv->max] = atoi(q);
+		} else {
+			if (!strcmp(option->name,"authserver"))
+				if ((svp = getservbyname ("radius", "udp")) == NULL)
+					serv->port[serv->max] = PW_AUTH_UDP_PORT;
+				else
+					serv->port[serv->max] = ntohs ((unsigned int) svp->s_port);
+			else if (!strcmp(option->name, "acctserver"))
+				if ((svp = getservbyname ("radacct", "udp")) == NULL)
+					serv->port[serv->max] = PW_ACCT_UDP_PORT;
+				else
+					serv->port[serv->max] = ntohs ((unsigned int) svp->s_port);
+			else {
+				rc_log(LOG_ERR, "%s: line %d: no default port for %s", filename, line, option->name);
+				return (-1);
+			}
+		}
+
+		serv->name[serv->max++] = strdup(p);
+
+		p = NULL;
+	}
+
+	return 0;
+}
+
+static int set_option_auo(char *filename, int line, OPTION *option, char *p)
+{
+	int *iptr;
+
+	if (p == NULL) {
+		rc_log(LOG_WARNING, "%s: line %d: bogus option value", filename, line);
+		return (-1);
+	}
+
+	if ((iptr = (int *) malloc(sizeof(iptr))) == NULL) {
+			rc_log(LOG_CRIT, "read_config: out of memory");
+			return (-1);
+	}
+			
+	*iptr = 0;
+	p = strtok(p, ", \t");
+
+	if (!strncmp(p, "local", 5))
+			*iptr = AUTH_LOCAL_FST;
+	else if (!strncmp(p, "radius", 6))
+			*iptr = AUTH_RADIUS_FST;
+	else {
+		rc_log(LOG_ERR,"%s: auth_order: unknown keyword: %s", filename, p);
+		return (-1); 
+	}
+			
+	p = strtok(NULL, ", \t");
+			
+	if (p && (*p != '\0')) {
+		if ((*iptr & AUTH_RADIUS_FST) && !strcmp(p, "local"))
+			*iptr = (*iptr) | AUTH_LOCAL_SND;
+		else if ((*iptr & AUTH_LOCAL_FST) && !strcmp(p, "radius"))
+			*iptr = (*iptr) | AUTH_RADIUS_SND;   
+		else {
+			rc_log(LOG_ERR,"%s: auth_order: unknown or unexpected keyword: %s", filename, p);
+			return (-1); 
+		}
+	}
+
+	option->val = (void *) iptr;
+
+	return 0;
+}
+
+
+/*
+ * Function: rc_read_config
+ *
+ * Purpose: read the global config file
+ * 
+ * Returns: 0 on success, -1 when failure
+ */
+
+int rc_read_config(char *filename)
+{
+	FILE *configfd;
+	char buffer[512], *p;
+	OPTION *option;
+	int line, pos;
+
+	if ((configfd = fopen(filename,"r")) == NULL)
+	{
+		rc_log(LOG_ERR,"rc_read_config: can't open %s: %s", filename, strerror(errno));
+		return (-1);
+	}
+
+	line = 0;
+	while ((fgets(buffer, sizeof(buffer), configfd) != NULL))
+	{
+		line++;
+		p = buffer;
+		
+		if ((*p == '\n') || (*p == '#') || (*p == '\0'))
+			continue;
+
+		p[strlen(p)-1] = '\0';
+		
+		
+		if ((pos = strcspn(p, "\t ")) == 0) {
+			rc_log(LOG_ERR, "%s: line %d: bogus format: %s", filename, line, p);
+			return (-1);
+		} 
+		
+		p[pos] = '\0';
+		
+		if ((option = find_option(p, OT_ANY)) == NULL) {
+			rc_log(LOG_ERR, "%s: line %d: unrecognized keyword: %s", filename, line, p);
+			return (-1);
+		}
+
+		if (option->status != ST_UNDEF) {
+			rc_log(LOG_ERR, "%s: line %d: duplicate option line: %s", filename, line, p);
+			return (-1);
+		}
+
+		p += pos+1;
+		while (isspace(*p)) 
+			p++;
+
+		switch (option->type) {
+			case OT_STR:
+				 if (set_option_str(filename, line, option, p) < 0)
+				 	return (-1);
+				break;					
+			case OT_INT:
+				 if (set_option_int(filename, line, option, p) < 0)
+				 	return (-1);
+				break;
+			case OT_SRV:
+				 if (set_option_srv(filename, line, option, p) < 0)
+				 	return (-1);
+				break;
+			case OT_AUO:
+				 if (set_option_auo(filename, line, option, p) < 0)
+				 	return (-1);
+				break;
+			default:
+				rc_log(LOG_CRIT, "rc_read_config: impossible case branch!");
+				abort();
+		}
+	}
+	fclose(configfd);
+
+	return test_config(filename);
+}
+
+/*
+ * Function: rc_conf_str, rc_conf_int, rc_conf_src
+ *
+ * Purpose: get the value of a config option
+ * 
+ * Returns: config option value
+ */
+
+char *rc_conf_str(char *optname)
+{
+	OPTION *option;
+
+	option = find_option(optname, OT_STR);
+	
+	if (option != NULL) {
+		return (char *)option->val;	
+	} else {
+		rc_log(LOG_CRIT, "rc_conf_str: unkown config option requested: %s", optname);
+		abort();
+	}
+}
+
+int rc_conf_int(char *optname)
+{
+	OPTION *option;
+
+	option = find_option(optname, OT_INT|OT_AUO);
+	
+	if (option != NULL) {
+		return *((int *)option->val);	
+	} else {
+		rc_log(LOG_CRIT, "rc_conf_int: unkown config option requested: %s", optname);
+		abort();
+	}
+}
+
+SERVER *rc_conf_srv(char *optname)
+{
+	OPTION *option;
+
+	option = find_option(optname, OT_SRV);
+	
+	if (option != NULL) {
+		return (SERVER *)option->val;	
+	} else {
+		rc_log(LOG_CRIT, "rc_conf_srv: unkown config option requested: %s", optname);
+		abort();
+	}
+}
+
+/*
+ * Function: test_config
+ *
+ * Purpose: test the configuration the user supplied
+ *
+ * Returns: 0 on success, -1 when failure
+ */
+
+static int test_config(char *filename)
+{
+#if 0
+	struct stat st;
+	char	    *file;
+#endif
+
+	if (!(rc_conf_srv("authserver")->max))
+	{
+		rc_log(LOG_ERR,"%s: no authserver specified", filename);
+		return (-1);
+	}
+	if (!(rc_conf_srv("acctserver")->max))
+	{
+		rc_log(LOG_ERR,"%s: no acctserver specified", filename);
+		return (-1);
+	}
+	if (!rc_conf_str("servers"))
+	{
+		rc_log(LOG_ERR,"%s: no servers file specified", filename);
+		return (-1);
+	}                                                                         
+	if (!rc_conf_str("dictionary"))
+	{
+		rc_log(LOG_ERR,"%s: no dictionary specified", filename);
+		return (-1);
+	}
+
+	if (rc_conf_int("radius_timeout") <= 0)
+	{
+		rc_log(LOG_ERR,"%s: radius_timeout <= 0 is illegal", filename);
+		return (-1);
+	}
+	if (rc_conf_int("radius_retries") <= 0) 
+	{
+		rc_log(LOG_ERR,"%s: radius_retries <= 0 is illegal", filename);
+		return (-1);
+	}	
+
+#if 0
+	file = rc_conf_str("login_local");
+	if (stat(file, &st) == 0)
+	{
+		if (!S_ISREG(st.st_mode)) {
+			rc_log(LOG_ERR,"%s: not a regular file: %s", filename, file);
+			return (-1);
+		}
+	} else {
+		rc_log(LOG_ERR,"%s: file not found: %s", filename, file);
+		return (-1);
+	}
+	file = rc_conf_str("login_radius");
+	if (stat(file, &st) == 0)
+	{
+		if (!S_ISREG(st.st_mode)) {
+			rc_log(LOG_ERR,"%s: not a regular file: %s", filename, file);
+			return (-1);
+		}
+	} else {
+		rc_log(LOG_ERR,"%s: file not found: %s", filename, file);
+		return (-1);
+	}
+#endif
+	
+	if (rc_conf_int("login_tries") <= 0)
+	{
+		rc_log(LOG_ERR,"%s: login_tries <= 0 is illegal", filename);
+		return (-1);
+	}	
+	if (rc_conf_str("seqfile") == NULL)
+	{
+		rc_log(LOG_ERR,"%s: seqfile not specified", filename);
+		return (-1);
+	}	
+	if (rc_conf_int("login_timeout") <= 0)
+	{
+		rc_log(LOG_ERR,"%s: login_timeout <= 0 is illegal", filename);
+		return (-1);
+	}	
+	if (rc_conf_str("mapfile") == NULL)
+	{
+		rc_log(LOG_ERR,"%s: mapfile not specified", filename);
+		return (-1);
+	}	
+	if (rc_conf_str("nologin") == NULL)
+	{
+		rc_log(LOG_ERR,"%s: nologin not specified", filename);
+		return (-1);
+	}	
+
+	return 0;
+}
+
+/*
+ * Function: rc_find_match
+ *
+ * Purpose: see if ip_addr is one of the ip addresses of hostname
+ *
+ * Returns: 0 on success, -1 when failure
+ *
+ */
+
+static int find_match (UINT4 *ip_addr, char *hostname)
+{
+	UINT4           addr;
+	char          **paddr;
+	struct hostent *hp;
+
+	if (rc_good_ipaddr (hostname) == 0)
+	{
+		if (*ip_addr == ntohl(inet_addr (hostname)))
+		{
+			return (0);
+		}
+	}
+	else
+	{
+		if ((hp = gethostbyname (hostname)) == (struct hostent *) NULL)
+		{
+			return (-1);
+		}
+		for (paddr = hp->h_addr_list; *paddr; paddr++)
+		{
+			addr = ** (UINT4 **) paddr;
+			if (ntohl(addr) == *ip_addr)
+			{
+				return (0);
+			}
+		}
+	}
+	return (-1);
+} 
+
+/*
+ * Function: rc_find_server
+ *
+ * Purpose: search a server in the servers file
+ *
+ * Returns: 0 on success, -1 on failure
+ *
+ */
+ 
+int rc_find_server (char *server_name, UINT4 *ip_addr, char *secret)
+{
+	UINT4    	myipaddr = 0;
+	int             len;
+	int             result;
+	FILE           *clientfd;
+	char           *h;
+	char           *s;
+	char           *host2;
+	char            buffer[128];
+	char            hostnm[AUTH_ID_LEN + 1];
+
+	/* Get the IP address of the authentication server */
+	if ((*ip_addr = rc_get_ipaddr (server_name)) == (UINT4) 0)
+		return (-1);
+
+	if ((clientfd = fopen (rc_conf_str("servers"), "r")) == (FILE *) NULL)
+	{
+		rc_log(LOG_ERR, "rc_find_server: couldn't open file: %s: %s", strerror(errno), rc_conf_str("servers"));
+		return (-1);
+	}
+	
+	if ((myipaddr = rc_own_ipaddress()) == 0)
+		return (-1);
+
+	result = 0;
+	while (fgets (buffer, sizeof (buffer), clientfd) != (char *) NULL)
+	{
+		if (*buffer == '#')
+			continue;
+
+		if ((h = strtok (buffer, " \t\n")) == NULL) /* first hostname */
+			continue;
+
+		memset (hostnm, '\0', AUTH_ID_LEN);
+		len = strlen (h);
+		if (len > AUTH_ID_LEN)
+		{
+			len = AUTH_ID_LEN;
+		}
+		strncpy (hostnm, h, (size_t) len);
+		hostnm[AUTH_ID_LEN] = '\0';
+
+		if ((s = strtok (NULL, " \t\n")) == NULL) /* and secret field */
+			continue;
+
+		memset (secret, '\0', MAX_SECRET_LENGTH);
+		len = strlen (s);
+		if (len > MAX_SECRET_LENGTH)
+		{
+			len = MAX_SECRET_LENGTH;
+		}
+		strncpy (secret, s, (size_t) len);
+		secret[MAX_SECRET_LENGTH] = '\0';
+
+		if (!strchr (hostnm, '/')) /* If single name form */
+		{
+			if (find_match (ip_addr, hostnm) == 0)
+			{
+				result++;
+				break;
+			}
+		}
+		else /* <name1>/<name2> "paired" form */
+		{
+			strtok (hostnm, "/");
+			if (find_match (&myipaddr, hostnm) == 0)
+			{	     /* If we're the 1st name, target is 2nd */
+				host2 = strtok (NULL, " ");
+				if (find_match (ip_addr, host2) == 0)
+				{
+					result++;
+					break;
+				}
+			}
+			else	/* If we were 2nd name, target is 1st name */
+			{
+				if (find_match (ip_addr, hostnm) == 0)
+				{
+					result++;
+					break;
+				}
+			}
+		}
+	}
+	fclose (clientfd);
+	if (result == 0)
+	{
+		memset (buffer, '\0', sizeof (buffer));
+		memset (secret, '\0', sizeof (secret));
+		rc_log(LOG_ERR, "rc_find_server: couldn't find RADIUS server %s in %s",
+			 server_name, rc_conf_str("servers"));
+		return (-1);
+	}
+	return 0;
+}
diff --git a/pppd/plugins/radius/radiusclient/lib/dict.c b/pppd/plugins/radius/radiusclient/lib/dict.c
new file mode 100644
index 0000000..95a0838
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/dict.c
@@ -0,0 +1,426 @@
+/*
+ * $Id: dict.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 2002 Roaring Penguin Software Inc.
+ *
+ * Copyright (C) 1995,1996,1997 Lars Fenneberg
+ *
+ * Copyright 1992 Livingston Enterprises, Inc.
+ *
+ * Copyright 1992,1993, 1994,1995 The Regents of the University of Michigan
+ * and Merit Network, Inc. All Rights Reserved
+ *
+ * See the file COPYRIGHT for the respective terms and conditions.
+ * If the file is missing contact me at lf@elemental.net
+ * and I'll send you a copy.
+ *
+ */
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+
+static DICT_ATTR *dictionary_attributes = NULL;
+static DICT_VALUE *dictionary_values = NULL;
+static VENDOR_DICT *vendor_dictionaries = NULL;
+
+/*
+ * Function: rc_read_dictionary
+ *
+ * Purpose: Initialize the dictionary.  Read all ATTRIBUTES into
+ *	    the dictionary_attributes list.  Read all VALUES into
+ *	    the dictionary_values list.  Construct VENDOR dictionaries
+ *          as required.
+ *
+ */
+
+int rc_read_dictionary (char *filename)
+{
+	FILE           *dictfd;
+	char            dummystr[AUTH_ID_LEN];
+	char            namestr[AUTH_ID_LEN];
+	char            valstr[AUTH_ID_LEN];
+	char            attrstr[AUTH_ID_LEN];
+	char            typestr[AUTH_ID_LEN];
+	char            vendorstr[AUTH_ID_LEN];
+	int             line_no;
+	DICT_ATTR      *attr;
+	DICT_VALUE     *dval;
+	VENDOR_DICT    *vdict;
+	char            buffer[256];
+	int             value;
+	int             type;
+	int             n;
+
+	if ((dictfd = fopen (filename, "r")) == (FILE *) NULL)
+	{
+		rc_log(LOG_ERR, "rc_read_dictionary: couldn't open dictionary %s: %s",
+				filename, strerror(errno));
+		return (-1);
+	}
+
+	line_no = 0;
+	while (fgets (buffer, sizeof (buffer), dictfd) != (char *) NULL)
+	{
+		line_no++;
+
+		/* Skip empty space */
+		if (*buffer == '#' || *buffer == '\0' || *buffer == '\n')
+		{
+			continue;
+		}
+
+		if (strncmp (buffer, "VENDOR", 6) == 0) {
+		    /* Read the VENDOR line */
+		    if (sscanf(buffer, "%s%s%d", dummystr, namestr, &value) != 3) {
+			rc_log(LOG_ERR, "rc_read_dictionary: invalid vendor on line %d of dictionary %s",
+			       line_no, filename);
+			return (-1);
+		    }
+		    /* Validate entry */
+		    if (strlen (namestr) > NAME_LENGTH) {
+			rc_log(LOG_ERR, "rc_read_dictionary: invalid name length on line %d of dictionary %s",
+			       line_no, filename);
+			return (-1);
+		    }
+		    /* Create new vendor entry */
+		    vdict = (VENDOR_DICT *) malloc (sizeof (VENDOR_DICT));
+		    if (!vdict) {
+			rc_log(LOG_CRIT, "rc_read_dictionary: out of memory");
+			return (-1);
+		    }
+		    strcpy(vdict->vendorname, namestr);
+		    vdict->vendorcode = value;
+		    vdict->attributes = NULL;
+		    vdict->next = vendor_dictionaries;
+		    vendor_dictionaries = vdict;
+		}
+		else if (strncmp (buffer, "ATTRIBUTE", 9) == 0)
+		{
+
+			/* Read the ATTRIBUTE line.  It is one of:
+			 * ATTRIBUTE attr_name attr_val type         OR
+			 * ATTRIBUTE attr_name attr_val type vendor  */
+			vendorstr[0] = 0;
+			n = sscanf(buffer, "%s%s%s%s%s", dummystr, namestr, valstr, typestr, vendorstr);
+			if (n != 4 && n != 5)
+			{
+				rc_log(LOG_ERR, "rc_read_dictionary: invalid attribute on line %d of dictionary %s",
+					 line_no, filename);
+				return (-1);
+			}
+
+			/*
+			 * Validate all entries
+			 */
+			if (strlen (namestr) > NAME_LENGTH)
+			{
+				rc_log(LOG_ERR, "rc_read_dictionary: invalid name length on line %d of dictionary %s",
+					 line_no, filename);
+				return (-1);
+			}
+
+			if (strlen (vendorstr) > NAME_LENGTH)
+			{
+				rc_log(LOG_ERR, "rc_read_dictionary: invalid name length on line %d of dictionary %s",
+					 line_no, filename);
+				return (-1);
+			}
+
+			if (!isdigit (*valstr))
+			{
+				rc_log(LOG_ERR,
+				 "rc_read_dictionary: invalid value on line %d of dictionary %s",
+					 line_no, filename);
+				return (-1);
+			}
+			value = atoi (valstr);
+
+			if (strcmp (typestr, "string") == 0)
+			{
+				type = PW_TYPE_STRING;
+			}
+			else if (strcmp (typestr, "integer") == 0)
+			{
+				type = PW_TYPE_INTEGER;
+			}
+			else if (strcmp (typestr, "ipaddr") == 0)
+			{
+				type = PW_TYPE_IPADDR;
+			}
+			else if (strcmp (typestr, "date") == 0)
+			{
+				type = PW_TYPE_DATE;
+			}
+			else
+			{
+				rc_log(LOG_ERR,
+				  "rc_read_dictionary: invalid type on line %d of dictionary %s",
+					 line_no, filename);
+				return (-1);
+			}
+
+			/* Search for vendor if supplied */
+			if (*vendorstr) {
+			    vdict = rc_dict_findvendor(vendorstr);
+			    if (!vdict) {
+				rc_log(LOG_ERR,
+				       "rc_read_dictionary: unknown vendor on line %d of dictionary %s",
+				       line_no, filename);
+				return (-1);
+			    }
+			} else {
+			    vdict = NULL;
+			}
+			/* Create a new attribute for the list */
+			if ((attr =
+				(DICT_ATTR *) malloc (sizeof (DICT_ATTR)))
+							== (DICT_ATTR *) NULL)
+			{
+				rc_log(LOG_CRIT, "rc_read_dictionary: out of memory");
+				return (-1);
+			}
+			strcpy (attr->name, namestr);
+			if (vdict) {
+			    attr->vendorcode = vdict->vendorcode;
+			} else {
+			    attr->vendorcode = VENDOR_NONE;
+			}
+			attr->value = value;
+			attr->type = type;
+
+			/* Insert it into the list */
+			if (vdict) {
+			    attr->next = vdict->attributes;
+			    vdict->attributes = attr;
+			} else {
+			    attr->next = dictionary_attributes;
+			    dictionary_attributes = attr;
+			}
+		}
+		else if (strncmp (buffer, "VALUE", 5) == 0)
+		{
+			/* Read the VALUE line */
+			if (sscanf (buffer, "%s%s%s%s", dummystr, attrstr,
+				    namestr, valstr) != 4)
+			{
+				rc_log(LOG_ERR,
+			   "rc_read_dictionary: invalid value entry on line %d of dictionary %s",
+					 line_no, filename);
+				return (-1);
+			}
+
+			/*
+			 * Validate all entries
+			 */
+			if (strlen (attrstr) > NAME_LENGTH)
+			{
+				rc_log(LOG_ERR,
+		      "rc_read_dictionary: invalid attribute length on line %d of dictionary %s",
+					 line_no, filename);
+				return (-1);
+			}
+
+			if (strlen (namestr) > NAME_LENGTH)
+			{
+				rc_log(LOG_ERR,
+			   "rc_read_dictionary: invalid name length on line %d of dictionary %s",
+					 line_no, filename);
+				return (-1);
+			}
+
+			if (!isdigit (*valstr))
+			{
+				rc_log(LOG_ERR,
+				 "rc_read_dictionary: invalid value on line %d of dictionary %s",
+					 line_no, filename);
+				return (-1);
+			}
+			value = atoi (valstr);
+
+			/* Create a new VALUE entry for the list */
+			if ((dval =
+				(DICT_VALUE *) malloc (sizeof (DICT_VALUE)))
+							== (DICT_VALUE *) NULL)
+			{
+				rc_log(LOG_CRIT, "rc_read_dictionary: out of memory");
+				return (-1);
+			}
+			strcpy (dval->attrname, attrstr);
+			strcpy (dval->name, namestr);
+			dval->value = value;
+
+			/* Insert it into the list */
+			dval->next = dictionary_values;
+			dictionary_values = dval;
+		}
+	}
+	fclose (dictfd);
+	return (0);
+}
+
+/*
+ * Function: rc_dict_getattr
+ *
+ * Purpose: Return the full attribute structure based on the
+ *	    attribute id number and vendor code.  If vendor code is VENDOR_NONE,
+ *          non-vendor-specific attributes are used
+ *
+ */
+
+DICT_ATTR *rc_dict_getattr (int attribute, int vendor)
+{
+	DICT_ATTR      *attr;
+	VENDOR_DICT    *dict;
+
+	if (vendor == VENDOR_NONE) {
+	    attr = dictionary_attributes;
+	    while (attr != (DICT_ATTR *) NULL) {
+		if (attr->value == attribute) {
+		    return (attr);
+		}
+		attr = attr->next;
+	    }
+	} else {
+	    dict = rc_dict_getvendor(vendor);
+	    if (!dict) {
+		return NULL;
+	    }
+	    attr = dict->attributes;
+	    while (attr) {
+		if (attr->value == attribute) {
+		    return attr;
+		}
+		attr = attr->next;
+	    }
+	}
+	return NULL;
+}
+
+/*
+ * Function: rc_dict_findattr
+ *
+ * Purpose: Return the full attribute structure based on the
+ *	    attribute name.
+ *
+ */
+
+DICT_ATTR *rc_dict_findattr (char *attrname)
+{
+	DICT_ATTR      *attr;
+	VENDOR_DICT    *dict;
+
+	attr = dictionary_attributes;
+	while (attr != (DICT_ATTR *) NULL)
+	{
+		if (strcasecmp (attr->name, attrname) == 0)
+		{
+			return (attr);
+		}
+		attr = attr->next;
+	}
+
+	/* Search vendor-specific dictionaries */
+	dict = vendor_dictionaries;
+	while (dict) {
+	    attr = dict->attributes;
+	    while (attr) {
+		if (strcasecmp (attr->name, attrname) == 0) {
+		    return (attr);
+		}
+		attr = attr->next;
+	    }
+	    dict = dict->next;
+	}
+	return ((DICT_ATTR *) NULL);
+}
+
+
+/*
+ * Function: rc_dict_findval
+ *
+ * Purpose: Return the full value structure based on the
+ *         value name.
+ *
+ */
+
+DICT_VALUE *rc_dict_findval (char *valname)
+{
+	DICT_VALUE     *val;
+
+	val = dictionary_values;
+	while (val != (DICT_VALUE *) NULL)
+	{
+		if (strcasecmp (val->name, valname) == 0)
+		{
+			return (val);
+		}
+		val = val->next;
+	}
+	return ((DICT_VALUE *) NULL);
+}
+
+/*
+ * Function: dict_getval
+ *
+ * Purpose: Return the full value structure based on the
+ *          actual value and the associated attribute name.
+ *
+ */
+
+DICT_VALUE * rc_dict_getval (UINT4 value, char *attrname)
+{
+	DICT_VALUE     *val;
+
+	val = dictionary_values;
+	while (val != (DICT_VALUE *) NULL)
+	{
+		if (strcmp (val->attrname, attrname) == 0 &&
+				val->value == value)
+		{
+			return (val);
+		}
+		val = val->next;
+	}
+	return ((DICT_VALUE *) NULL);
+}
+
+/*
+ * Function: rc_dict_findvendor
+ *
+ * Purpose: Return the vendor's dictionary given the vendor name.
+ *
+ */
+VENDOR_DICT * rc_dict_findvendor (char *vendorname)
+{
+    VENDOR_DICT *dict;
+
+    dict = vendor_dictionaries;
+    while (dict) {
+	if (!strcmp(vendorname, dict->vendorname)) {
+	    return dict;
+	}
+	dict = dict->next;
+    }
+    return NULL;
+}
+
+/*
+ * Function: rc_dict_getvendor
+ *
+ * Purpose: Return the vendor's dictionary given the vendor ID
+ *
+ */
+VENDOR_DICT * rc_dict_getvendor (int id)
+{
+    VENDOR_DICT *dict;
+
+    dict = vendor_dictionaries;
+    while (dict) {
+	if (id == dict->vendorcode) {
+	    return dict;
+	}
+	dict = dict->next;
+    }
+    return NULL;
+}
diff --git a/pppd/plugins/radius/radiusclient/lib/env.c b/pppd/plugins/radius/radiusclient/lib/env.c
new file mode 100644
index 0000000..f3d177b
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/env.c
@@ -0,0 +1,144 @@
+/*
+ * $Id: env.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 1995,1996,1997 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+
+/*
+ * Function: rc_new_env
+ *
+ * Purpose: allocate space for a new environment
+ *
+ */
+ 
+ENV *rc_new_env(int size)
+{
+	ENV *p;
+
+	if (size < 1)
+		return NULL;
+
+	if ((p = malloc(sizeof(*p))) == NULL)
+		return NULL;
+		
+	if ((p->env = malloc(size * sizeof(char *))) == NULL)
+	{
+		rc_log(LOG_CRIT, "rc_new_env: out of memory");
+		free(p);
+		return NULL;
+	} 
+
+	p->env[0] = NULL;
+	
+	p->size = 0;
+	p->maxsize = size;	
+		
+	return p;
+}
+
+/*
+ * Function: rc_free_env
+ *
+ * Purpose: free the space used by an env structure
+ *
+ */
+ 
+void rc_free_env(ENV *env)
+{
+	free(env->env);
+	free(env); 
+}
+
+/*
+ * Function: rc_add_env
+ *
+ * Purpose: add an environment entry
+ *
+ */
+ 
+int rc_add_env(ENV *env, char *name, char *value)
+{
+	int i;
+	char *new_env;
+
+	for (i = 0; env->env[i] != NULL; i++)
+	{
+		if (strncmp(env->env[i], name, MAX(strchr(env->env[i], '=') - env->env[i],strlen(name))) == 0)
+			break;	
+	}
+
+	if (env->env[i])
+	{
+		if ((new_env = realloc(env->env[i], strlen(name)+strlen(value)+2)) == NULL)
+			return (-1);
+
+		env->env[i] = new_env;
+
+		sprintf(env->env[i],"%s=%s", name, value);
+	} else {
+		if (env->size == (env->maxsize-1)) {
+			rc_log(LOG_CRIT, "rc_add_env: not enough space for environment (increase ENV_SIZE)");
+			return (-1);
+		}
+	
+		if ((env->env[env->size] = malloc(strlen(name)+strlen(value)+2)) == NULL) {
+			rc_log(LOG_CRIT, "rc_add_env: out of memory");
+			return (-1);
+		}
+	
+		sprintf(env->env[env->size],"%s=%s", name, value);
+	
+		env->size++;
+
+		env->env[env->size] = NULL;
+	}
+
+	return 0;		
+}
+
+/*
+ * Function: rc_import_env
+ *
+ * Purpose: imports an array of null-terminated strings
+ *
+ */
+ 
+int rc_import_env(ENV *env, char **import)
+{
+	char *es;
+	
+	while (*import)
+	{
+		es = strchr(*import, '=');
+		
+		if (!es)
+		{
+			import++;
+			continue;
+		}
+		
+		/* ok, i grant thats not very clean... */
+		*es = '\0';
+
+		if (rc_add_env(env, *import, es+1) < 0)
+		{
+			*es = '=';
+			return (-1);
+		}
+	
+		*es = '=';
+	
+		import++;
+	}
+	
+	return 0;
+}
diff --git a/pppd/plugins/radius/radiusclient/lib/ip_util.c b/pppd/plugins/radius/radiusclient/lib/ip_util.c
new file mode 100644
index 0000000..f207b0c
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/ip_util.c
@@ -0,0 +1,202 @@
+/*
+ * $Id: ip_util.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 1995,1996,1997 Lars Fenneberg
+ *
+ * Copyright 1992 Livingston Enterprises, Inc.
+ *
+ * Copyright 1992,1993, 1994,1995 The Regents of the University of Michigan 
+ * and Merit Network, Inc. All Rights Reserved
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+
+/*
+ * Function: rc_get_ipaddr
+ *
+ * Purpose: return an IP address in host long notation from a host
+ *          name or address in dot notation.
+ *
+ * Returns: 0 on failure
+ */
+
+UINT4 rc_get_ipaddr (char *host)
+{
+	struct hostent *hp;
+
+	if (rc_good_ipaddr (host) == 0)
+	{
+		return ntohl(inet_addr (host));
+	}
+	else if ((hp = gethostbyname (host)) == (struct hostent *) NULL)
+	{
+		rc_log(LOG_ERR,"rc_get_ipaddr: couldn't resolve hostname: %s", host);
+		return ((UINT4) 0);
+	}
+	return ntohl((*(UINT4 *) hp->h_addr));
+} 
+
+/*
+ * Function: rc_good_ipaddr
+ *
+ * Purpose: check for valid IP address in standard dot notation.
+ *
+ * Returns: 0 on success, -1 when failure
+ *
+ */
+
+int rc_good_ipaddr (char *addr)
+{
+	int             dot_count;
+	int             digit_count;
+
+	if (addr == NULL)
+		return (-1);
+
+	dot_count = 0;
+	digit_count = 0;
+	while (*addr != '\0' && *addr != ' ')
+	{
+		if (*addr == '.')
+		{
+			dot_count++;
+			digit_count = 0;
+		}
+		else if (!isdigit (*addr))
+		{
+			dot_count = 5;
+		}
+		else
+		{
+			digit_count++;
+			if (digit_count > 3)
+			{
+				dot_count = 5;
+			}
+		}
+		addr++;
+	}
+	if (dot_count != 3)
+	{
+		return (-1);
+	}
+	else
+	{
+		return (0);
+	}
+}
+
+/*
+ * Function: rc_ip_hostname
+ *
+ * Purpose: Return a printable host name (or IP address in dot notation)
+ *	    for the supplied IP address.
+ *
+ */
+ 
+const char *rc_ip_hostname (UINT4 h_ipaddr)
+{
+	struct hostent  *hp;
+	UINT4           n_ipaddr = htonl (h_ipaddr);
+
+	if ((hp = gethostbyaddr ((char *) &n_ipaddr, sizeof (struct in_addr),
+			    AF_INET)) == NULL) {
+		rc_log(LOG_ERR,"rc_ip_hostname: couldn't look up host by addr: %08lX", h_ipaddr);
+	}
+				  
+	return ((hp==NULL)?"unknown":hp->h_name);
+} 
+
+/*
+ * Function: rc_getport
+ *
+ * Purpose: get the port number for the supplied request type
+ *
+ */
+
+unsigned short rc_getport(int type)
+{
+	struct servent *svp;
+
+	if ((svp = getservbyname ((type==AUTH)?"radius":"radacct", "udp")) == NULL)
+	{
+		return ((type==AUTH)?PW_AUTH_UDP_PORT:PW_ACCT_UDP_PORT);
+	} else {
+		return ntohs ((unsigned short) svp->s_port);
+	}
+}
+
+/*
+ * Function: rc_own_hostname
+ *
+ * Purpose: get the hostname of this machine
+ *
+ * Returns  -1 on failure, 0 on success
+ *
+ */
+
+int
+rc_own_hostname(char *hostname, int len)
+{
+#ifdef HAVE_UNAME
+	struct	utsname uts;
+#endif
+
+#if defined(HAVE_UNAME)
+	if (uname(&uts) < 0)
+	{
+		rc_log(LOG_ERR,"rc_own_hostname: couldn't get own hostname");
+		return -1;
+	}
+	strncpy(hostname, uts.nodename, len);
+#elif defined(HAVE_GETHOSTNAME)
+	if (gethostname(hostname, len) < 0)
+	{
+		rc_log(LOG_ERR,"rc_own_hostname: couldn't get own hostname");
+		return -1;
+	}
+#elif defined(HAVE_SYSINFO)
+	if (sysinfo(SI_HOSTNAME, hostname, len) < 0)
+	{
+		rc_log(LOG_ERR,"rc_own_hostname: couldn't get own hostname");
+		return -1;
+	}
+#else
+	return -1;
+#endif	
+
+	return 0;
+}
+
+/*
+ * Function: rc_own_ipaddress
+ *
+ * Purpose: get the IP address of this host in host order
+ *
+ * Returns: IP address on success, 0 on failure
+ *
+ */
+
+UINT4 rc_own_ipaddress(void)
+{
+	static UINT4 this_host_ipaddr = 0;
+	char hostname[256];
+
+	if (!this_host_ipaddr) {
+		if (rc_own_hostname(hostname, sizeof(hostname)) < 0)
+			return 0;
+		if ((this_host_ipaddr = rc_get_ipaddr (hostname)) == 0) {
+			rc_log(LOG_ERR, "rc_own_ipaddress: couldn't get own IP address");
+			return 0;
+		}
+	} 
+	
+	return this_host_ipaddr;
+}
diff --git a/pppd/plugins/radius/radiusclient/lib/lock.c b/pppd/plugins/radius/radiusclient/lib/lock.c
new file mode 100644
index 0000000..f78c592
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/lock.c
@@ -0,0 +1,64 @@
+/*
+ * $Id: lock.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 1997 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+#include "config.h"
+#include "includes.h"
+
+#if defined(HAVE_FLOCK)
+
+int do_lock_exclusive(int fd)
+{
+	return flock(fd, LOCK_EX|LOCK_NB);
+}
+
+int do_unlock(int fd)
+{
+	return flock(fd, LOCK_UN);
+}
+
+#elif defined(HAVE_FCNTL)
+
+int do_lock_exclusive(int fd)
+{
+	flock_t fl;
+	int res;
+	
+	memset((void *)&fl, 0, sizeof(fl));
+	
+	fl.l_type = F_WRLCK;
+	fl.l_whence = fl.l_start = 0;
+	fl.l_len = 0; /* 0 means "to end of file" */
+
+	res = fcntl(fd, F_SETLK, &fl);
+	
+	if ((res == -1) && (errno == EAGAIN))
+		errno = EWOULDBLOCK;
+
+	return res;
+}
+
+int do_unlock(int fd)
+{
+	flock_t fl;
+	
+	memset((void *)&fl, 0, sizeof(fl));
+	
+	fl.l_type = F_UNLCK;
+	fl.l_whence = fl.l_start = 0;
+	fl.l_len = 0; /* 0 means "to end of file" */
+
+	return fcntl(fd, F_SETLK, &fl);
+}
+
+#else
+YOU_LOOSE "need either flock(2) or fcntl(2)"
+#endif
+	
diff --git a/pppd/plugins/radius/radiusclient/lib/log.c b/pppd/plugins/radius/radiusclient/lib/log.c
new file mode 100644
index 0000000..9e922a3
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/log.c
@@ -0,0 +1,53 @@
+/*
+ * $Id: log.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 1995,1996,1997 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+
+/*
+ * Function: rc_openlog
+ *
+ * Purpose: open log
+ *
+ * Arguments: identification string
+ *
+ * Returns: nothing
+ *
+ */
+
+void rc_openlog(char *ident)
+{
+	openlog(ident, LOG_PID, RC_LOG_FACILITY);
+}
+
+/*
+ * Function: rc_log
+ *
+ * Purpose: log information
+ *
+ * Arguments: priority (just like syslog), rest like printf
+ *
+ * Returns: nothing
+ *
+ */
+
+void rc_log(int prio, const char *format, ...)
+{
+	char buff[1024];
+	va_list ap;
+                                    
+	va_start(ap,format);
+    vsnprintf(buff, sizeof(buff), format, ap);
+    va_end(ap);
+                                                            
+	syslog(prio, "%s", buff);
+}
diff --git a/pppd/plugins/radius/radiusclient/lib/md5.c b/pppd/plugins/radius/radiusclient/lib/md5.c
new file mode 100644
index 0000000..5dc7652
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/md5.c
@@ -0,0 +1,348 @@
+/*
+ * $Id: md5.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ */
+
+/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
+ */
+
+/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
+rights reserved.
+
+License to copy and use this software is granted provided that it
+is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+Algorithm" in all material mentioning or referencing this software
+or this function.
+
+License is also granted to make and use derivative works provided
+that such works are identified as "derived from the RSA Data
+Security, Inc. MD5 Message-Digest Algorithm" in all material
+mentioning or referencing the derived work.
+
+RSA Data Security, Inc. makes no representations concerning either
+the merchantability of this software or the suitability of this
+software for any particular purpose. It is provided "as is"
+without express or implied warranty of any kind.
+
+These notices must be retained in any copies of any part of this
+documentation and/or software.
+ */
+
+#include <string.h>
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+
+typedef unsigned char		*POINTER;
+
+/* MD5 context. */
+typedef struct
+{
+	UINT4           state[4];  /* state (ABCD) */
+	UINT4           count[2];  /* number of bits, modulo 2^64 (lsb first) */
+	unsigned char   buffer[64]; /* input buffer */
+} MD5_CTX;
+
+static void MD5Init    (MD5_CTX *);
+static void MD5Update  (MD5_CTX *, unsigned char *, unsigned int);
+static void MD5Final   (unsigned char[16], MD5_CTX *);
+
+/* Constants for MD5Transform routine.
+ */
+#define S11 7
+#define S12 12
+#define S13 17
+#define S14 22
+#define S21 5
+#define S22 9
+#define S23 14
+#define S24 20
+#define S31 4
+#define S32 11
+#define S33 16
+#define S34 23
+#define S41 6
+#define S42 10
+#define S43 15
+#define S44 21
+
+static void MD5Transform (UINT4[4], unsigned char[64]);
+static void Encode (unsigned char *, UINT4 *, unsigned int);
+static void Decode (UINT4 *, unsigned char *, unsigned int);
+static void MD5_memcpy (POINTER, POINTER, unsigned int);
+static void MD5_memset (POINTER, int, unsigned int);
+
+static unsigned char PADDING[64] = {
+	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/* F, G, H and I are basic MD5 functions.
+ */
+#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
+#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
+#define H(x, y, z) ((x) ^ (y) ^ (z))
+#define I(x, y, z) ((y) ^ ((x) | (~z)))
+
+/* ROTATE_LEFT rotates x left n bits.
+ */
+#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
+
+/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
+Rotation is separate from addition to prevent recomputation.
+ */
+#define FF(a, b, c, d, x, s, ac) { \
+ (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+#define GG(a, b, c, d, x, s, ac) { \
+ (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+#define HH(a, b, c, d, x, s, ac) { \
+ (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+#define II(a, b, c, d, x, s, ac) { \
+ (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+
+void rc_md5_calc (unsigned char *output, unsigned char *input, unsigned int inlen)
+{
+	MD5_CTX         context;
+
+	MD5Init (&context);
+	MD5Update (&context, input, inlen);
+	MD5Final (output, &context);
+}
+
+/* MD5 initialization. Begins an MD5 operation, writing a new context.
+ */
+static void MD5Init (MD5_CTX *context)
+{
+	context->count[0] = context->count[1] = 0;
+
+	/*
+	 * Load magic initialization constants.
+	 */
+	context->state[0] = 0x67452301;
+	context->state[1] = 0xefcdab89;
+	context->state[2] = 0x98badcfe;
+	context->state[3] = 0x10325476;
+}
+
+/* MD5 block update operation. Continues an MD5 message-digest
+  operation, processing another message block, and updating the
+  context.
+ */
+static void MD5Update (MD5_CTX *context, unsigned char *input, unsigned int inputLen)
+{
+	unsigned int    i,
+	                index,
+	                partLen;
+
+	/* Compute number of bytes mod 64 */
+	index = (unsigned int) ((context->count[0] >> 3) & 0x3F);
+
+	/* Update number of bits */
+	if ((context->count[0] += ((UINT4) inputLen << 3))
+			< ((UINT4) inputLen << 3))
+		context->count[1]++;
+	context->count[1] += ((UINT4) inputLen >> 29);
+
+	partLen = 64 - index;
+
+	/*
+	 * Transform as many times as possible.
+	 */
+	if (inputLen >= partLen)
+	{
+		MD5_memcpy
+			((POINTER) & context->buffer[index], (POINTER) input, partLen);
+		MD5Transform (context->state, context->buffer);
+
+		for (i = partLen; i + 63 < inputLen; i += 64)
+			MD5Transform (context->state, &input[i]);
+
+		index = 0;
+	}
+	else
+		i = 0;
+
+	/* Buffer remaining input */
+	MD5_memcpy
+		((POINTER) & context->buffer[index], (POINTER) & input[i],
+		 inputLen - i);
+}
+
+/* MD5 finalization. Ends an MD5 message-digest operation, writing the
+  the message digest and zeroizing the context.
+ */
+static void MD5Final (unsigned char *digest, MD5_CTX *context)
+{
+	unsigned char   bits[8];
+	unsigned int    index,
+	                padLen;
+
+	/* Save number of bits */
+	Encode (bits, context->count, 8);
+
+	/*
+	 * Pad out to 56 mod 64.
+	 */
+	index = (unsigned int) ((context->count[0] >> 3) & 0x3f);
+	padLen = (index < 56) ? (56 - index) : (120 - index);
+	MD5Update (context, PADDING, padLen);
+
+	/* Append length (before padding) */
+	MD5Update (context, bits, 8);
+
+	/* Store state in digest */
+	Encode (digest, context->state, 16);
+
+	/*
+	 * Zeroize sensitive information.
+	 */
+	MD5_memset ((POINTER) context, 0, sizeof (*context));
+}
+
+/* MD5 basic transformation. Transforms state based on block.
+ */
+static void MD5Transform (UINT4 *state, unsigned char *block)
+{
+	UINT4           a = state[0],
+	                b = state[1],
+	                c = state[2],
+	                d = state[3],
+	                x[16];
+
+	Decode (x, block, 64);
+
+	/* Round 1 */
+	FF (a, b, c, d, x[0], S11, 0xd76aa478);	/* 1 */
+	FF (d, a, b, c, x[1], S12, 0xe8c7b756);	/* 2 */
+	FF (c, d, a, b, x[2], S13, 0x242070db);	/* 3 */
+	FF (b, c, d, a, x[3], S14, 0xc1bdceee);	/* 4 */
+	FF (a, b, c, d, x[4], S11, 0xf57c0faf);	/* 5 */
+	FF (d, a, b, c, x[5], S12, 0x4787c62a);	/* 6 */
+	FF (c, d, a, b, x[6], S13, 0xa8304613);	/* 7 */
+	FF (b, c, d, a, x[7], S14, 0xfd469501);	/* 8 */
+	FF (a, b, c, d, x[8], S11, 0x698098d8);	/* 9 */
+	FF (d, a, b, c, x[9], S12, 0x8b44f7af);	/* 10 */
+	FF (c, d, a, b, x[10], S13, 0xffff5bb1);	/* 11 */
+	FF (b, c, d, a, x[11], S14, 0x895cd7be);	/* 12 */
+	FF (a, b, c, d, x[12], S11, 0x6b901122);	/* 13 */
+	FF (d, a, b, c, x[13], S12, 0xfd987193);	/* 14 */
+	FF (c, d, a, b, x[14], S13, 0xa679438e);	/* 15 */
+	FF (b, c, d, a, x[15], S14, 0x49b40821);	/* 16 */
+
+	/* Round 2 */
+	GG (a, b, c, d, x[1], S21, 0xf61e2562);	/* 17 */
+	GG (d, a, b, c, x[6], S22, 0xc040b340);	/* 18 */
+	GG (c, d, a, b, x[11], S23, 0x265e5a51);	/* 19 */
+	GG (b, c, d, a, x[0], S24, 0xe9b6c7aa);	/* 20 */
+	GG (a, b, c, d, x[5], S21, 0xd62f105d);	/* 21 */
+	GG (d, a, b, c, x[10], S22, 0x2441453);	/* 22 */
+	GG (c, d, a, b, x[15], S23, 0xd8a1e681);	/* 23 */
+	GG (b, c, d, a, x[4], S24, 0xe7d3fbc8);	/* 24 */
+	GG (a, b, c, d, x[9], S21, 0x21e1cde6);	/* 25 */
+	GG (d, a, b, c, x[14], S22, 0xc33707d6);	/* 26 */
+	GG (c, d, a, b, x[3], S23, 0xf4d50d87);	/* 27 */
+	GG (b, c, d, a, x[8], S24, 0x455a14ed);	/* 28 */
+	GG (a, b, c, d, x[13], S21, 0xa9e3e905);	/* 29 */
+	GG (d, a, b, c, x[2], S22, 0xfcefa3f8);	/* 30 */
+	GG (c, d, a, b, x[7], S23, 0x676f02d9);	/* 31 */
+	GG (b, c, d, a, x[12], S24, 0x8d2a4c8a);	/* 32 */
+
+	/* Round 3 */
+	HH (a, b, c, d, x[5], S31, 0xfffa3942);	/* 33 */
+	HH (d, a, b, c, x[8], S32, 0x8771f681);	/* 34 */
+	HH (c, d, a, b, x[11], S33, 0x6d9d6122);	/* 35 */
+	HH (b, c, d, a, x[14], S34, 0xfde5380c);	/* 36 */
+	HH (a, b, c, d, x[1], S31, 0xa4beea44);	/* 37 */
+	HH (d, a, b, c, x[4], S32, 0x4bdecfa9);	/* 38 */
+	HH (c, d, a, b, x[7], S33, 0xf6bb4b60);	/* 39 */
+	HH (b, c, d, a, x[10], S34, 0xbebfbc70);	/* 40 */
+	HH (a, b, c, d, x[13], S31, 0x289b7ec6);	/* 41 */
+	HH (d, a, b, c, x[0], S32, 0xeaa127fa);	/* 42 */
+	HH (c, d, a, b, x[3], S33, 0xd4ef3085);	/* 43 */
+	HH (b, c, d, a, x[6], S34, 0x4881d05);	/* 44 */
+	HH (a, b, c, d, x[9], S31, 0xd9d4d039);	/* 45 */
+	HH (d, a, b, c, x[12], S32, 0xe6db99e5);	/* 46 */
+	HH (c, d, a, b, x[15], S33, 0x1fa27cf8);	/* 47 */
+	HH (b, c, d, a, x[2], S34, 0xc4ac5665);	/* 48 */
+
+	/* Round 4 */
+	II (a, b, c, d, x[0], S41, 0xf4292244);	/* 49 */
+	II (d, a, b, c, x[7], S42, 0x432aff97);	/* 50 */
+	II (c, d, a, b, x[14], S43, 0xab9423a7);	/* 51 */
+	II (b, c, d, a, x[5], S44, 0xfc93a039);	/* 52 */
+	II (a, b, c, d, x[12], S41, 0x655b59c3);	/* 53 */
+	II (d, a, b, c, x[3], S42, 0x8f0ccc92);	/* 54 */
+	II (c, d, a, b, x[10], S43, 0xffeff47d);	/* 55 */
+	II (b, c, d, a, x[1], S44, 0x85845dd1);	/* 56 */
+	II (a, b, c, d, x[8], S41, 0x6fa87e4f);	/* 57 */
+	II (d, a, b, c, x[15], S42, 0xfe2ce6e0);	/* 58 */
+	II (c, d, a, b, x[6], S43, 0xa3014314);	/* 59 */
+	II (b, c, d, a, x[13], S44, 0x4e0811a1);	/* 60 */
+	II (a, b, c, d, x[4], S41, 0xf7537e82);	/* 61 */
+	II (d, a, b, c, x[11], S42, 0xbd3af235);	/* 62 */
+	II (c, d, a, b, x[2], S43, 0x2ad7d2bb);	/* 63 */
+	II (b, c, d, a, x[9], S44, 0xeb86d391);	/* 64 */
+
+	state[0] += a;
+	state[1] += b;
+	state[2] += c;
+	state[3] += d;
+
+	/*
+	 * Zeroize sensitive information.
+	 */
+	MD5_memset ((POINTER) x, 0, sizeof (x));
+}
+
+/* Encodes input (UINT4) into output (unsigned char). Assumes len is
+  a multiple of 4.
+ */
+static void Encode (unsigned char *output, UINT4 *input, unsigned int len)
+{
+	unsigned int    i,
+	                j;
+
+	for (i = 0, j = 0; j < len; i++, j += 4)
+	{
+		output[j] = (unsigned char) (input[i] & 0xff);
+		output[j + 1] = (unsigned char) ((input[i] >> 8) & 0xff);
+		output[j + 2] = (unsigned char) ((input[i] >> 16) & 0xff);
+		output[j + 3] = (unsigned char) ((input[i] >> 24) & 0xff);
+	}
+}
+
+/* Decodes input (unsigned char) into output (UINT4). Assumes len is
+  a multiple of 4.
+ */
+static void Decode (UINT4 *output, unsigned char *input, unsigned int len)
+{
+	unsigned int    i,
+	                j;
+
+	for (i = 0, j = 0; j < len; i++, j += 4)
+		output[i] = ((UINT4) input[j]) | (((UINT4) input[j + 1]) << 8) |
+			(((UINT4) input[j + 2]) << 16) | (((UINT4) input[j + 3]) << 24);
+}
+
+static void MD5_memcpy (POINTER output, POINTER input, unsigned int len)
+{
+	memcpy(output, input, len);
+}
+
+static void MD5_memset (POINTER output, int value, unsigned int len)
+{
+	memset(output, value, len);
+}
diff --git a/pppd/plugins/radius/radiusclient/lib/memcmp.c b/pppd/plugins/radius/radiusclient/lib/memcmp.c
new file mode 100644
index 0000000..d0d86e0
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/memcmp.c
@@ -0,0 +1,22 @@
+/*
+ * $Id: memcmp.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Taken from the Linux kernel. GPL applies.
+ * Copyright (C) 1991, 1992  Linus Torvalds
+ *
+ */
+
+#include "config.h"
+#include "includes.h"
+
+int memcmp(const void * cs,const void * ct,size_t count)
+{
+	const unsigned char *su1, *su2;
+	signed char res = 0;
+                
+	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
+		if ((res = *su1 - *su2) != 0)
+			break;
+        return res;
+}
+                                                                        
\ No newline at end of file
diff --git a/pppd/plugins/radius/radiusclient/lib/options.h b/pppd/plugins/radius/radiusclient/lib/options.h
new file mode 100644
index 0000000..800ec81
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/options.h
@@ -0,0 +1,58 @@
+/*
+ * $Id: options.h,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 1996 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+#define OPTION_LEN	64
+
+/* ids for different option types */
+#define OT_STR		(1<<0)	  /* string */
+#define OT_INT		(1<<1)	  /* integer */
+#define OT_SRV		(1<<2)	  /* server list */
+#define OT_AUO		(1<<3)    /* authentication order */
+
+#define OT_ANY		((unsigned int)~0) /* used internally */
+
+/* status types */
+#define ST_UNDEF	(1<<0)	  /* option is undefined */
+
+typedef struct _option {
+	char name[OPTION_LEN];	  /* name of the option */
+	int type, status;	  /* type and status    */
+	void *val;		  /* pointer to option value */
+} OPTION;
+
+static SERVER acctserver = {0};
+static SERVER authserver = {0};
+
+static OPTION config_options[] = {
+/* internally used options */
+{"config_file",		OT_STR, ST_UNDEF, NULL},
+/* General options */
+{"auth_order",	 	OT_AUO, ST_UNDEF, NULL},
+{"login_tries",	 	OT_INT, ST_UNDEF, NULL},
+{"login_timeout",	OT_INT, ST_UNDEF, NULL},
+{"nologin",		OT_STR, ST_UNDEF, NULL},
+{"issue",		OT_STR, ST_UNDEF, NULL},
+/* RADIUS specific options */
+{"authserver",		OT_SRV, ST_UNDEF, &authserver},
+{"acctserver",		OT_SRV, ST_UNDEF, &acctserver},
+{"servers",		OT_STR, ST_UNDEF, NULL},
+{"dictionary",		OT_STR, ST_UNDEF, NULL},
+{"login_radius",	OT_STR, ST_UNDEF, NULL},
+{"seqfile",		OT_STR, ST_UNDEF, NULL},
+{"mapfile",		OT_STR, ST_UNDEF, NULL},
+{"default_realm",	OT_STR, ST_UNDEF, NULL},
+{"radius_timeout",	OT_INT, ST_UNDEF, NULL},
+{"radius_retries",	OT_INT,	ST_UNDEF, NULL},
+/* local options */
+{"login_local",		OT_STR, ST_UNDEF, NULL},
+};
+
+static int num_options = ((sizeof(config_options))/(sizeof(config_options[0])));
diff --git a/pppd/plugins/radius/radiusclient/lib/sendserver.c b/pppd/plugins/radius/radiusclient/lib/sendserver.c
new file mode 100644
index 0000000..34c489c
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/sendserver.c
@@ -0,0 +1,504 @@
+/*
+ * $Id: sendserver.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 1995,1996,1997 Lars Fenneberg
+ *
+ * Copyright 1992 Livingston Enterprises, Inc.
+ *
+ * Copyright 1992,1993, 1994,1995 The Regents of the University of Michigan
+ * and Merit Network, Inc. All Rights Reserved
+ *
+ * See the file COPYRIGHT for the respective terms and conditions.
+ * If the file is missing contact me at lf@elemental.net
+ * and I'll send you a copy.
+ *
+ */
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+#include <pathnames.h>
+
+static void rc_random_vector (unsigned char *);
+static int rc_check_reply (AUTH_HDR *, char *, unsigned char *, unsigned char);
+
+/*
+ * Function: rc_pack_list
+ *
+ * Purpose: Packs an attribute value pair list into a buffer.
+ *
+ * Returns: Number of octets packed.
+ *
+ */
+
+static int rc_pack_list (VALUE_PAIR *vp, char *secret, AUTH_HDR *auth)
+{
+    int             length, i, pc, secretlen, padded_length;
+    int             total_length = 0;
+    UINT4           lvalue;
+    unsigned char   passbuf[MAX(AUTH_PASS_LEN, CHAP_VALUE_LENGTH)];
+    unsigned char   md5buf[256];
+    unsigned char   *buf, *vector, *lenptr;
+
+    buf = auth->data;
+
+    while (vp != (VALUE_PAIR *) NULL)
+	{
+
+	    if (vp->vendorcode != VENDOR_NONE) {
+		*buf++ = PW_VENDOR_SPECIFIC;
+
+		/* Place-holder for where to put length */
+		lenptr = buf++;
+
+		/* Insert vendor code */
+		*buf++ = 0;
+		*buf++ = (((unsigned int) vp->vendorcode) >> 16) & 255;
+		*buf++ = (((unsigned int) vp->vendorcode) >> 8) & 255;
+		*buf++ = ((unsigned int) vp->vendorcode) & 255;
+
+		/* Insert vendor-type */
+		*buf++ = vp->attribute;
+
+		/* Insert value */
+		switch(vp->type) {
+		case PW_TYPE_STRING:
+		    length = vp->lvalue;
+		    *lenptr = length + 8;
+		    *buf++ = length+2;
+		    memcpy(buf, vp->strvalue, (size_t) length);
+		    buf += length;
+		    total_length += length+8;
+		    break;
+		case PW_TYPE_INTEGER:
+		case PW_TYPE_IPADDR:
+		    length = sizeof(UINT4);
+		    *lenptr = length + 8;
+		    *buf++ = length+2;
+		    lvalue = htonl(vp->lvalue);
+		    memcpy(buf, (char *) &lvalue, sizeof(UINT4));
+		    buf += length;
+		    total_length += length+8;
+		    break;
+		default:
+		    break;
+		}
+	    } else {
+		*buf++ = vp->attribute;
+		switch (vp->attribute) {
+		case PW_USER_PASSWORD:
+
+		    /* Encrypt the password */
+
+		    /* Chop off password at AUTH_PASS_LEN */
+		    length = vp->lvalue;
+		    if (length > AUTH_PASS_LEN) length = AUTH_PASS_LEN;
+
+		    /* Calculate the padded length */
+		    padded_length = (length+(AUTH_VECTOR_LEN-1)) & ~(AUTH_VECTOR_LEN-1);
+
+		    /* Record the attribute length */
+		    *buf++ = padded_length + 2;
+
+		    /* Pad the password with zeros */
+		    memset ((char *) passbuf, '\0', AUTH_PASS_LEN);
+		    memcpy ((char *) passbuf, vp->strvalue, (size_t) length);
+
+		    secretlen = strlen (secret);
+		    vector = (char *)auth->vector;
+		    for(i = 0; i < padded_length; i += AUTH_VECTOR_LEN) {
+			/* Calculate the MD5 digest*/
+			strcpy ((char *) md5buf, secret);
+			memcpy ((char *) md5buf + secretlen, vector,
+				AUTH_VECTOR_LEN);
+			rc_md5_calc (buf, md5buf, secretlen + AUTH_VECTOR_LEN);
+
+			/* Remeber the start of the digest */
+			vector = buf;
+
+			/* Xor the password into the MD5 digest */
+			for (pc = i; pc < (i + AUTH_VECTOR_LEN); pc++) {
+			    *buf++ ^= passbuf[pc];
+			}
+		    }
+
+		    total_length += padded_length + 2;
+
+		    break;
+#if 0
+		case PW_CHAP_PASSWORD:
+
+		    *buf++ = CHAP_VALUE_LENGTH + 2;
+
+		    /* Encrypt the Password */
+		    length = vp->lvalue;
+		    if (length > CHAP_VALUE_LENGTH) {
+			length = CHAP_VALUE_LENGTH;
+		    }
+		    memset ((char *) passbuf, '\0', CHAP_VALUE_LENGTH);
+		    memcpy ((char *) passbuf, vp->strvalue, (size_t) length);
+
+		    /* Calculate the MD5 Digest */
+		    secretlen = strlen (secret);
+		    strcpy ((char *) md5buf, secret);
+		    memcpy ((char *) md5buf + secretlen, (char *) auth->vector,
+			    AUTH_VECTOR_LEN);
+		    rc_md5_calc (buf, md5buf, secretlen + AUTH_VECTOR_LEN);
+
+		    /* Xor the password into the MD5 digest */
+		    for (i = 0; i < CHAP_VALUE_LENGTH; i++) {
+			*buf++ ^= passbuf[i];
+		    }
+		    total_length += CHAP_VALUE_LENGTH + 2;
+
+		    break;
+#endif
+		default:
+		    switch (vp->type) {
+		    case PW_TYPE_STRING:
+			length = vp->lvalue;
+			*buf++ = length + 2;
+			memcpy (buf, vp->strvalue, (size_t) length);
+			buf += length;
+			total_length += length + 2;
+			break;
+
+		    case PW_TYPE_INTEGER:
+		    case PW_TYPE_IPADDR:
+			*buf++ = sizeof (UINT4) + 2;
+			lvalue = htonl (vp->lvalue);
+			memcpy (buf, (char *) &lvalue, sizeof (UINT4));
+			buf += sizeof (UINT4);
+			total_length += sizeof (UINT4) + 2;
+			break;
+
+		    default:
+			break;
+		    }
+		    break;
+		}
+		vp = vp->next;
+	    }
+	}
+    return total_length;
+}
+
+/*
+ * Function: rc_send_server
+ *
+ * Purpose: send a request to a RADIUS server and wait for the reply
+ *
+ */
+
+int rc_send_server (SEND_DATA *data, char *msg)
+{
+	int             sockfd;
+	struct sockaddr salocal;
+	struct sockaddr saremote;
+	struct sockaddr_in *sin;
+	struct timeval  authtime;
+	fd_set          readfds;
+	AUTH_HDR       *auth, *recv_auth;
+	UINT4           auth_ipaddr;
+	char           *server_name;	/* Name of server to query */
+	int             salen;
+	int             result;
+	int             total_length;
+	int             length;
+	int             retry_max;
+	int		secretlen;
+	char            secret[MAX_SECRET_LENGTH + 1];
+	unsigned char   vector[AUTH_VECTOR_LEN];
+	char            recv_buffer[BUFFER_LEN];
+	char            send_buffer[BUFFER_LEN];
+	int		retries;
+	VALUE_PAIR	*vp;
+
+	server_name = data->server;
+	if (server_name == (char *) NULL || server_name[0] == '\0')
+		return (ERROR_RC);
+
+	if ((vp = rc_avpair_get(data->send_pairs, PW_SERVICE_TYPE)) && \
+	    (vp->lvalue == PW_ADMINISTRATIVE))
+	{
+		strcpy(secret, MGMT_POLL_SECRET);
+		if ((auth_ipaddr = rc_get_ipaddr(server_name)) == 0)
+			return (ERROR_RC);
+	}
+	else
+	{
+		if (rc_find_server (server_name, &auth_ipaddr, secret) != 0)
+		{
+			return (ERROR_RC);
+		}
+	}
+
+	sockfd = socket (AF_INET, SOCK_DGRAM, 0);
+	if (sockfd < 0)
+	{
+		memset (secret, '\0', sizeof (secret));
+		rc_log(LOG_ERR, "rc_send_server: socket: %s", strerror(errno));
+		return (ERROR_RC);
+	}
+
+	length = sizeof (salocal);
+	sin = (struct sockaddr_in *) & salocal;
+	memset ((char *) sin, '\0', (size_t) length);
+	sin->sin_family = AF_INET;
+	sin->sin_addr.s_addr = htonl(INADDR_ANY);
+	sin->sin_port = htons ((unsigned short) 0);
+	if (bind (sockfd, (struct sockaddr *) sin, length) < 0 ||
+		   getsockname (sockfd, (struct sockaddr *) sin, &length) < 0)
+	{
+		close (sockfd);
+		memset (secret, '\0', sizeof (secret));
+		rc_log(LOG_ERR, "rc_send_server: bind: %s: %s", server_name, strerror(errno));
+		return (ERROR_RC);
+	}
+
+	retry_max = data->retries;	/* Max. numbers to try for reply */
+	retries = 0;			/* Init retry cnt for blocking call */
+
+	/* Build a request */
+	auth = (AUTH_HDR *) send_buffer;
+	auth->code = data->code;
+	auth->id = data->seq_nbr;
+
+	if (data->code == PW_ACCOUNTING_REQUEST)
+	{
+		total_length = rc_pack_list(data->send_pairs, secret, auth) + AUTH_HDR_LEN;
+
+		auth->length = htons ((unsigned short) total_length);
+
+		memset((char *) auth->vector, 0, AUTH_VECTOR_LEN);
+		secretlen = strlen (secret);
+		memcpy ((char *) auth + total_length, secret, secretlen);
+		rc_md5_calc (vector, (char *) auth, total_length + secretlen);
+		memcpy ((char *) auth->vector, (char *) vector, AUTH_VECTOR_LEN);
+	}
+	else
+	{
+		rc_random_vector (vector);
+		memcpy ((char *) auth->vector, (char *) vector, AUTH_VECTOR_LEN);
+
+		total_length = rc_pack_list(data->send_pairs, secret, auth) + AUTH_HDR_LEN;
+
+		auth->length = htons ((unsigned short) total_length);
+	}
+
+	sin = (struct sockaddr_in *) & saremote;
+	memset ((char *) sin, '\0', sizeof (saremote));
+	sin->sin_family = AF_INET;
+	sin->sin_addr.s_addr = htonl (auth_ipaddr);
+	sin->sin_port = htons ((unsigned short) data->svc_port);
+
+	for (;;)
+	{
+		sendto (sockfd, (char *) auth, (unsigned int) total_length, (int) 0,
+			(struct sockaddr *) sin, sizeof (struct sockaddr_in));
+
+		authtime.tv_usec = 0L;
+		authtime.tv_sec = (long) data->timeout;
+		FD_ZERO (&readfds);
+		FD_SET (sockfd, &readfds);
+		if (select (sockfd + 1, &readfds, NULL, NULL, &authtime) < 0)
+		{
+			if (errno == EINTR)
+				continue;
+			rc_log(LOG_ERR, "rc_send_server: select: %s", strerror(errno));
+			memset (secret, '\0', sizeof (secret));
+			close (sockfd);
+			return (ERROR_RC);
+		}
+		if (FD_ISSET (sockfd, &readfds))
+			break;
+
+		/*
+		 * Timed out waiting for response.  Retry "retry_max" times
+		 * before giving up.  If retry_max = 0, don't retry at all.
+		 */
+		if (++retries >= retry_max)
+		{
+			rc_log(LOG_ERR,
+				"rc_send_server: no reply from RADIUS server %s:%u",
+				 rc_ip_hostname (auth_ipaddr), data->svc_port);
+			close (sockfd);
+			memset (secret, '\0', sizeof (secret));
+			return (TIMEOUT_RC);
+		}
+	}
+	salen = sizeof (saremote);
+	length = recvfrom (sockfd, (char *) recv_buffer,
+			   (int) sizeof (recv_buffer),
+			   (int) 0, &saremote, &salen);
+
+	if (length <= 0)
+	{
+		rc_log(LOG_ERR, "rc_send_server: recvfrom: %s:%d: %s", server_name,\
+			 data->svc_port, strerror(errno));
+		close (sockfd);
+		memset (secret, '\0', sizeof (secret));
+		return (ERROR_RC);
+	}
+
+	recv_auth = (AUTH_HDR *)recv_buffer;
+
+	result = rc_check_reply (recv_auth, secret, vector, data->seq_nbr);
+
+	data->receive_pairs = rc_avpair_gen(recv_auth);
+
+	close (sockfd);
+	memset (secret, '\0', sizeof (secret));
+
+	if (result != OK_RC) return (result);
+
+	*msg = '\0';
+	vp = data->receive_pairs;
+	while (vp)
+	{
+		if ((vp = rc_avpair_get(vp, PW_REPLY_MESSAGE)))
+		{
+			strcat(msg, vp->strvalue);
+			strcat(msg, "\n");
+			vp = vp->next;
+		}
+	}
+
+	if ((recv_auth->code == PW_ACCESS_ACCEPT) ||
+		(recv_auth->code == PW_PASSWORD_ACK) ||
+		(recv_auth->code == PW_ACCOUNTING_RESPONSE))
+	{
+		result = OK_RC;
+	}
+	else
+	{
+		result = BADRESP_RC;
+	}
+
+	return (result);
+}
+
+/*
+ * Function: rc_check_reply
+ *
+ * Purpose: verify items in returned packet.
+ *
+ * Returns:	OK_RC       -- upon success,
+ *		BADRESP_RC  -- if anything looks funny.
+ *
+ */
+
+static int rc_check_reply (AUTH_HDR *auth, char *secret, unsigned char *vector,\
+			   unsigned char seq_nbr)
+{
+	int             secretlen;
+	int             totallen;
+	unsigned char   calc_digest[AUTH_VECTOR_LEN];
+	unsigned char   reply_digest[AUTH_VECTOR_LEN];
+
+	totallen = ntohs (auth->length);
+
+	/* Verify that id (seq. number) matches what we sent */
+	if (auth->id != seq_nbr)
+	{
+		rc_log(LOG_ERR, "check_radius_reply: received non-matching id in RADIUS server response");
+		return (BADRESP_RC);
+	}
+
+	/* Verify the reply digest */
+	memcpy ((char *) reply_digest, (char *) auth->vector, AUTH_VECTOR_LEN);
+	memcpy ((char *) auth->vector, (char *) vector, AUTH_VECTOR_LEN);
+	secretlen = strlen (secret);
+	memcpy ((char *) auth + totallen, secret, secretlen);
+	rc_md5_calc (calc_digest, (char *) auth, totallen + secretlen);
+
+#ifdef DIGEST_DEBUG
+	{
+		int i;
+
+		fputs("reply_digest: ", stderr);
+		for (i = 0; i < AUTH_VECTOR_LEN; i++)
+		{
+			fprintf(stderr,"%.2x ", (int) reply_digest[i]);
+		}
+		fputs("\ncalc_digest:  ", stderr);
+		for (i = 0; i < AUTH_VECTOR_LEN; i++)
+		{
+			fprintf(stderr,"%.2x ", (int) calc_digest[i]);
+		}
+		fputs("\n", stderr);
+	}
+#endif
+
+	if (memcmp ((char *) reply_digest, (char *) calc_digest,
+		    AUTH_VECTOR_LEN) != 0)
+	{
+#ifdef RADIUS_116
+		/* the original Livingston radiusd v1.16 seems to have
+		   a bug in digest calculation with accounting requests,
+		   authentication request are ok. i looked at the code
+		   but couldn't find any bugs. any help to get this
+		   kludge out are welcome. preferably i want to
+		   reproduce the calculation bug here to be compatible
+		   to stock Livingston radiusd v1.16.	-lf, 03/14/96
+		 */
+		if (auth->code == PW_ACCOUNTING_RESPONSE)
+			return (OK_RC);
+#endif
+		rc_log(LOG_ERR, "check_radius_reply: received invalid reply digest from RADIUS server");
+		return (BADRESP_RC);
+	}
+
+	return (OK_RC);
+
+}
+
+/*
+ * Function: rc_random_vector
+ *
+ * Purpose: generates a random vector of AUTH_VECTOR_LEN octets.
+ *
+ * Returns: the vector (call by reference)
+ *
+ */
+
+static void rc_random_vector (unsigned char *vector)
+{
+	int             randno;
+	int             i;
+#if defined(HAVE_DEV_URANDOM)
+	int		fd;
+
+/* well, I added this to increase the security for user passwords.
+   we use /dev/urandom here, as /dev/random might block and we don't
+   need that much randomness. BTW, great idea, Ted!     -lf, 03/18/95	*/
+
+	if ((fd = open(_PATH_DEV_URANDOM, O_RDONLY)) >= 0)
+	{
+		unsigned char *pos;
+		int readcount;
+
+		i = AUTH_VECTOR_LEN;
+		pos = vector;
+		while (i > 0)
+		{
+			readcount = read(fd, (char *)pos, i);
+			pos += readcount;
+			i -= readcount;
+		}
+
+		close(fd);
+		return;
+	} /* else fall through */
+#endif
+	srand (time (0) + getppid() + getpid()); /* random enough :) */
+	for (i = 0; i < AUTH_VECTOR_LEN;)
+	{
+		randno = rand ();
+		memcpy ((char *) vector, (char *) &randno, sizeof (int));
+		vector += sizeof (int);
+		i += sizeof (int);
+	}
+
+	return;
+}
diff --git a/pppd/plugins/radius/radiusclient/lib/strcasecmp.c b/pppd/plugins/radius/radiusclient/lib/strcasecmp.c
new file mode 100644
index 0000000..190da22
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/strcasecmp.c
@@ -0,0 +1,36 @@
+/*
+ * $Id: strcasecmp.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 1996 Lars Fenneberg and Christian Graefe
+ *
+ * This file is provided under the terms and conditions of the GNU general 
+ * public license, version 2 or any later version, incorporated herein by 
+ * reference. 
+ *
+ */
+
+#include "config.h"
+#include "includes.h"
+
+#ifdef HAVE_STRICMP
+# define strcasecmp(a,b)	stricmp(a,b)
+#else
+
+/*
+ * Function: strcasecmp
+ *
+ * Purpose:  strcasecmp replacement for systems which lack strcasecmp and
+ *			 stricmp
+ */
+
+int strcasecmp(char *s1, char *s2)
+{
+	while (*s1 && *s2 && toupper(*s1) == toupper(*s2))
+    	s1++, s2++;
+        
+    if (!*s1 && !*s2)
+    	return 0;    
+    else
+    	return (toupper(*s1) - toupper(*s2));                            
+}
+#endif
diff --git a/pppd/plugins/radius/radiusclient/lib/strdup.c b/pppd/plugins/radius/radiusclient/lib/strdup.c
new file mode 100644
index 0000000..0c487bf
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/strdup.c
@@ -0,0 +1,33 @@
+/*
+ * $Id: strdup.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 1996 Lars Fenneberg and Christian Graefe
+ *
+ * This file is provided under the terms and conditions of the GNU general 
+ * public license, version 2 or any later version, incorporated herein by 
+ * reference. 
+ *
+ */
+
+#include "config.h"
+#include "includes.h"
+
+/*
+ * Function: strdup
+ *
+ * Purpose:  strdup replacement for systems which lack it
+ *
+ */
+
+char *strdup(char *str)
+{
+	char *p;
+
+	if (str == NULL)
+		return NULL;
+
+	if ((p = (char *)malloc(strlen(str)+1)) == NULL)
+		return p;
+
+	return strcpy(p, str);	
+}
diff --git a/pppd/plugins/radius/radiusclient/lib/strerror.c b/pppd/plugins/radius/radiusclient/lib/strerror.c
new file mode 100644
index 0000000..849f58e
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/strerror.c
@@ -0,0 +1,40 @@
+/*
+ * $Id: strerror.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 1996 Lars Fenneberg and Christian Graefe
+ *
+ * This file is provided under the terms and conditions of the GNU general 
+ * public license, version 2 or any later version, incorporated herein by 
+ * reference. 
+ *
+ */
+
+#include "config.h"
+#include "includes.h"
+
+/*
+ * if we're missing strerror, these are mostly not defined either
+ */
+extern int sys_nerr;
+extern char *sys_errlist[];
+
+/*
+ * Function: strerror
+ *
+ * Purpose:  implements strerror for systems which lack it. if these
+ *			 systems even lack sys_errlist, you loose...
+ *
+ */
+
+
+char *strerror(int err)
+{
+	static char buf[32];
+
+	if (err >= 0 && err < sys_nerr)
+		return sys_errlist[err];
+	else {
+		sprintf(buf, "unknown error: %d", errno);
+		return buf;
+	}
+}
diff --git a/pppd/plugins/radius/radiusclient/lib/util.c b/pppd/plugins/radius/radiusclient/lib/util.c
new file mode 100644
index 0000000..392db24
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/lib/util.c
@@ -0,0 +1,237 @@
+/*
+ * $Id: util.c,v 1.1 2002/01/22 16:03:02 dfs Exp $
+ *
+ * Copyright (C) 1995,1996,1997 Lars Fenneberg
+ *
+ * Copyright 1992 Livingston Enterprises, Inc.
+ *
+ * Copyright 1992,1993, 1994,1995 The Regents of the University of Michigan 
+ * and Merit Network, Inc. All Rights Reserved
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+
+/*
+ * Function: rc_str2tm
+ *
+ * Purpose: Turns printable string into correct tm struct entries.
+ *
+ */
+
+static const char * months[] =
+		{
+			"Jan", "Feb", "Mar", "Apr", "May", "Jun",
+			"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+		};
+
+void rc_str2tm (char *valstr, struct tm *tm)
+{
+	int             i;
+
+	/* Get the month */
+	for (i = 0; i < 12; i++)
+	{
+		if (strncmp (months[i], valstr, 3) == 0)
+		{
+			tm->tm_mon = i;
+			i = 13;
+		}
+	}
+
+	/* Get the Day */
+	tm->tm_mday = atoi (&valstr[4]);
+
+	/* Now the year */
+	tm->tm_year = atoi (&valstr[7]) - 1900;
+}
+
+/*
+ * Function: rc_getifname
+ *
+ * Purpose: get the network interface name associated with this tty
+ *
+ */
+
+char *rc_getifname(char *tty)
+{
+#if defined(BSD4_4) || defined(linux)	
+	static char 	name[512];
+	int		fd;
+
+	if ((fd = open(tty, O_RDWR|O_NDELAY)) < 0) {
+		rc_log(LOG_ERR, "rc_getifname: can't open %s: %s", tty, strerror(errno));
+		return NULL;
+	}
+#endif	
+	
+#ifdef BSD4_4
+	strcpy(name,ttyname(fd));
+	if (strlen(name) < 1) {
+		rc_log(LOG_ERR, "rc_getifname: can't get attached interface of %s: %s", tty, strerror(errno));
+		close(fd);
+		return NULL;
+	}
+#elif linux
+	if (ioctl(fd, SIOCGIFNAME, name) < 0) {
+		rc_log(LOG_ERR, "rc_getifname: can't ioctl %s: %s", tty, strerror(errno));
+		close(fd);
+		return NULL;
+	}
+#else
+	return NULL;
+#endif
+
+#if defined(BSD4_4) || defined(linux)	
+	close(fd);
+	return name;
+#endif
+}
+
+/*
+ * Function: rc_getstr
+ *
+ * Purpose: Reads in a string from the user (with or witout echo)
+ *
+ */
+
+char *rc_getstr (char *prompt, int do_echo)
+{
+	int             in, out;
+	char           *p;
+	sigset_t        newset;
+	sigset_t        oldset;
+	struct termios  term_old, term_new;
+	static char     buf[GETSTR_LENGTH];
+	int		is_term, flags, old_flags;
+	char		c;
+	int		flushed = 0;
+
+	in = fileno(stdin);
+	out = fileno(stdout);
+
+	(void) sigemptyset (&newset);
+	(void) sigaddset (&newset, SIGINT);
+	(void) sigaddset (&newset, SIGTSTP);
+	(void) sigaddset (&newset, SIGQUIT);
+
+	(void) sigprocmask (SIG_BLOCK, &newset, &oldset);
+
+	if ((is_term = isatty(in)))
+	{
+	
+		(void) tcgetattr (in, &term_old);
+		term_new = term_old;
+		if (do_echo)
+			term_new.c_lflag |= ECHO;
+		else 
+			term_new.c_lflag &= ~ECHO;
+	
+		if (tcsetattr (in, TCSAFLUSH, &term_new) == 0)
+			flushed = 1;
+			
+	}
+	else
+	{
+		is_term = 0;
+		if ((flags = fcntl(in, F_GETFL, 0)) >= 0) {
+			old_flags = flags;
+			flags |= O_NONBLOCK;
+			
+			fcntl(in, F_SETFL, flags);
+			
+			while (read(in, &c, 1) > 0)
+				/* nothing */;
+				
+			fcntl(in, F_SETFL, old_flags);
+			
+			flushed = 1;
+		}  
+	}
+		
+	write(out, prompt, strlen(prompt));
+
+	/* well, this looks ugly, but it handles the following end of line
+	   markers: \r \r\0 \r\n \n \n\r, at least at a second pass */
+
+	p = buf;
+	for (;;)
+	{
+		if (read(in, &c, 1) <= 0)
+			return NULL;
+		
+		if (!flushed && ((c == '\0') || (c == '\r') || (c == '\n'))) {
+			flushed = 1;
+			continue;
+		}
+
+		if ((c == '\r') || (c == '\n'))
+			break;
+
+		flushed = 1;
+
+		if (p < buf + GETSTR_LENGTH)
+		{
+			if (do_echo && !is_term)
+				write(out, &c, 1);
+			*p++ = c;
+		}
+	}
+
+	*p = '\0';
+	
+	if (!do_echo || !is_term) write(out, "\r\n", 2);
+	
+	if (is_term)
+		tcsetattr (in, TCSAFLUSH, &term_old);
+	else {
+		if ((flags = fcntl(in, F_GETFL, 0)) >= 0) {
+			old_flags = flags;
+			flags |= O_NONBLOCK;
+			
+			fcntl(in, F_SETFL, flags);
+			
+			while (read(in, &c, 1) > 0)
+				/* nothing */;
+				
+			fcntl(in, F_SETFL, old_flags);
+		}  
+	}
+
+	(void) sigprocmask (SIG_SETMASK, &oldset, NULL);
+
+	return (buf);
+}
+
+void rc_mdelay(int msecs)
+{
+	struct timeval tv;
+	
+	tv.tv_sec = (int) msecs / 1000;
+	tv.tv_usec = (msecs % 1000) * 1000;
+
+	select(0,(fd_set *)NULL,(fd_set *)NULL,(fd_set *)NULL, &tv);
+}
+
+/*
+ * Function: rc_mksid
+ *
+ * Purpose: generate a quite unique string
+ *
+ * Remarks: not that unique at all...
+ *
+ */
+
+char *
+rc_mksid (void)
+{
+  static char buf[14];
+  sprintf (buf, "%08lX%04X", (unsigned long int) time (NULL), (unsigned int) getpid ());
+  return buf;
+}
diff --git a/pppd/plugins/radius/radiusclient/login.radius/Makefile.am b/pppd/plugins/radius/radiusclient/login.radius/Makefile.am
new file mode 100644
index 0000000..afccf95
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/login.radius/Makefile.am
@@ -0,0 +1,18 @@
+# 
+#  $Id: Makefile.am,v 1.1 2002/01/22 16:03:02 dfs Exp $
+# 
+#  Copyright (C) 1997 Lars Fenneberg
+# 
+#  See the file COPYRIGHT for the respective terms and conditions. 
+#  If the file is missing contact me at lf@elemental.net 
+#  and I'll send you a copy.
+# 
+#
+
+AUTOMAKE_OPTIONS = foreign
+
+SUBDIRS = migs
+
+EXTRA_DIST = README login.radius
+
+sbin_SCRIPTS = login.radius
diff --git a/pppd/plugins/radius/radiusclient/login.radius/Makefile.in b/pppd/plugins/radius/radiusclient/login.radius/Makefile.in
new file mode 100644
index 0000000..06453aa
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/login.radius/Makefile.in
@@ -0,0 +1,304 @@
+# Makefile.in generated automatically by automake 1.3 from Makefile.am
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+# 
+#  $Id: Makefile.in,v 1.1 2002/01/22 16:03:02 dfs Exp $
+# 
+#  Copyright (C) 1997 Lars Fenneberg
+# 
+#  See the file COPYRIGHT for the respective terms and conditions. 
+#  If the file is missing contact me at lf@elemental.net 
+#  and I'll send you a copy.
+# 
+#
+
+
+SHELL = /bin/sh
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+sbindir = @sbindir@
+libexecdir = @libexecdir@
+datadir = @datadir@
+sysconfdir = @sysconfdir@
+sharedstatedir = @sharedstatedir@
+localstatedir = @localstatedir@
+libdir = @libdir@
+infodir = @infodir@
+mandir = @mandir@
+includedir = @includedir@
+oldincludedir = /usr/include
+
+DISTDIR =
+
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+
+top_builddir = ..
+
+ACLOCAL = @ACLOCAL@
+AUTOCONF = @AUTOCONF@
+AUTOMAKE = @AUTOMAKE@
+AUTOHEADER = @AUTOHEADER@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+transform = @program_transform_name@
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_alias = @build_alias@
+build_triplet = @build@
+host_alias = @host_alias@
+host_triplet = @host@
+target_alias = @target_alias@
+target_triplet = @target@
+AR = @AR@
+CC = @CC@
+LD = @LD@
+LIBTOOL = @LIBTOOL@
+LIBVERSION = @LIBVERSION@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+NM = @NM@
+PACKAGE = @PACKAGE@
+RANLIB = @RANLIB@
+RC_LOG_FACILITY = @RC_LOG_FACILITY@
+RC_SECURE_PATH = @RC_SECURE_PATH@
+VERSION = @VERSION@
+pkgsysconfdir = @pkgsysconfdir@
+
+AUTOMAKE_OPTIONS = foreign
+
+SUBDIRS = migs
+
+EXTRA_DIST = README login.radius
+
+sbin_SCRIPTS = login.radius
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = ../config.h
+CONFIG_CLEAN_FILES = 
+SCRIPTS =  $(sbin_SCRIPTS)
+
+DIST_COMMON =  README Makefile.am Makefile.in
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = tar
+GZIP = --best
+all: all-recursive all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && $(AUTOMAKE) --foreign --include-deps login.radius/Makefile
+
+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+
+install-sbinSCRIPTS: $(sbin_SCRIPTS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(sbindir)
+	@list='$(sbin_SCRIPTS)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    echo " $(INSTALL_SCRIPT) $$p $(DESTDIR)$(sbindir)/`echo $$p|sed '$(transform)'`"; \
+	    $(INSTALL_SCRIPT) $$p $(DESTDIR)$(sbindir)/`echo $$p|sed '$(transform)'`; \
+	  else if test -f $(srcdir)/$$p; then \
+	    echo " $(INSTALL_SCRIPT) $(srcdir)/$$p $(DESTDIR)$(sbindir)/`echo $$p|sed '$(transform)'`"; \
+	    $(INSTALL_SCRIPT) $(srcdir)/$$p $(DESTDIR)$(sbindir)/`echo $$p|sed '$(transform)'`; \
+	  else :; fi; fi; \
+	done
+
+uninstall-sbinSCRIPTS:
+	@$(NORMAL_UNINSTALL)
+	list='$(sbin_SCRIPTS)'; for p in $$list; do \
+	  rm -f $(DESTDIR)$(sbindir)/`echo $$p|sed '$(transform)'`; \
+	done
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+
+@SET_MAKE@
+
+all-recursive install-data-recursive install-exec-recursive \
+installdirs-recursive install-recursive uninstall-recursive  \
+check-recursive installcheck-recursive info-recursive dvi-recursive:
+	@set fnord $(MAKEFLAGS); amf=$$2; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  target=`echo $@ | sed s/-recursive//`; \
+	  echo "Making $$target in $$subdir"; \
+	  (cd $$subdir && $(MAKE) $$target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done && test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@set fnord $(MAKEFLAGS); amf=$$2; \
+	rev=''; list='$(SUBDIRS)'; for subdir in $$list; do \
+	  rev="$$subdir $$rev"; \
+	done; \
+	for subdir in $$rev; do \
+	  target=`echo $@ | sed s/-recursive//`; \
+	  echo "Making $$target in $$subdir"; \
+	  (cd $$subdir && $(MAKE) $$target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  (cd $$subdir && $(MAKE) tags); \
+	done
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP)
+	here=`pwd` && cd $(srcdir) \
+	  && mkid -f$$here/ID $(SOURCES) $(HEADERS) $(LISP)
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test -f $$subdir/TAGS && tags="$$tags -i $$here/$$subdir/TAGS"; \
+	done; \
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$unique$(LISP)$$tags" \
+	  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $$unique $(LISP) -o $$here/TAGS)
+
+mostlyclean-tags:
+
+clean-tags:
+
+distclean-tags:
+	-rm -f TAGS ID
+
+maintainer-clean-tags:
+
+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
+
+subdir = login.radius
+
+distdir: $(DISTFILES)
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  test -f $(distdir)/$$file \
+	  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	  || cp -p $$d/$$file $(distdir)/$$file; \
+	done
+	for subdir in $(SUBDIRS); do \
+	  test -d $(distdir)/$$subdir \
+	  || mkdir $(distdir)/$$subdir \
+	  || exit 1; \
+	  chmod 777 $(distdir)/$$subdir; \
+	  (cd $$subdir && $(MAKE) top_distdir=../$(top_distdir) distdir=../$(distdir)/$$subdir distdir) \
+	    || exit 1; \
+	done
+info: info-recursive
+dvi: dvi-recursive
+check: all-am
+	$(MAKE) check-recursive
+installcheck: installcheck-recursive
+all-am: Makefile $(SCRIPTS)
+
+install-exec-am: install-sbinSCRIPTS
+
+uninstall-am: uninstall-sbinSCRIPTS
+
+install-exec: install-exec-recursive install-exec-am
+	@$(NORMAL_INSTALL)
+
+install-data: install-data-recursive
+	@$(NORMAL_INSTALL)
+
+install: install-recursive install-exec-am
+	@:
+
+uninstall: uninstall-recursive uninstall-am
+
+install-strip:
+	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install
+installdirs: installdirs-recursive
+	$(mkinstalldirs)  $(DATADIR)$(sbindir)
+
+
+mostlyclean-generic:
+	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-rm -f Makefile $(DISTCLEANFILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+mostlyclean-am:  mostlyclean-tags mostlyclean-generic
+
+clean-am:  clean-tags clean-generic mostlyclean-am
+
+distclean-am:  distclean-tags distclean-generic clean-am
+
+maintainer-clean-am:  maintainer-clean-tags maintainer-clean-generic \
+		distclean-am
+
+mostlyclean:  mostlyclean-recursive mostlyclean-am
+
+clean:  clean-recursive clean-am
+
+distclean:  distclean-recursive distclean-am
+	-rm -f config.status
+	-rm -f libtool
+
+maintainer-clean:  maintainer-clean-recursive maintainer-clean-am
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+.PHONY: uninstall-sbinSCRIPTS install-sbinSCRIPTS install-data-recursive \
+uninstall-data-recursive install-exec-recursive \
+uninstall-exec-recursive installdirs-recursive uninstalldirs-recursive \
+all-recursive check-recursive installcheck-recursive info-recursive \
+dvi-recursive mostlyclean-recursive distclean-recursive clean-recursive \
+maintainer-clean-recursive tags tags-recursive mostlyclean-tags \
+distclean-tags clean-tags maintainer-clean-tags distdir info dvi \
+installcheck all-am install-exec-am uninstall-am install-exec \
+install-data install uninstall all installdirs mostlyclean-generic \
+distclean-generic clean-generic maintainer-clean-generic clean \
+mostlyclean distclean maintainer-clean
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/pppd/plugins/radius/radiusclient/login.radius/README b/pppd/plugins/radius/radiusclient/login.radius/README
new file mode 100644
index 0000000..7edef1b
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/login.radius/README
@@ -0,0 +1,9 @@
+You can find login.radius script examples here.
+
+login.radius
+	
+	Dummy script.
+
+migs
+
+	Sample login.radius contributed by Miguel A.L. Paraz <map@iphil.net>.
diff --git a/pppd/plugins/radius/radiusclient/login.radius/login.radius b/pppd/plugins/radius/radiusclient/login.radius/login.radius
new file mode 100755
index 0000000..a3c7a6a
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/login.radius/login.radius
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# $Id: login.radius,v 1.1 2002/01/22 16:03:02 dfs Exp $
+#
+# Copyright (C) 1998 Lars Fenneberg
+#
+# See the file COPYRIGHT for the respective terms and conditions. 
+# If the file is missing contact me at lf@elemental.net 
+# and I'll send you a copy.
+#
+
+cat <<EOF
+This is the dummy login.radius script. If you want that this script
+does something useful you'll have to replace it.
+
+The following RADIUS environment variables are set:
+EOF
+
+set | egrep '^RADIUS_'
+
+echo
+echo "Bye, bye."
+
+exit 0
diff --git a/pppd/plugins/radius/radiusclient/login.radius/migs/Makefile.am b/pppd/plugins/radius/radiusclient/login.radius/migs/Makefile.am
new file mode 100644
index 0000000..81c8f51
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/login.radius/migs/Makefile.am
@@ -0,0 +1,14 @@
+# 
+#  $Id: Makefile.am,v 1.1 2002/01/22 16:03:02 dfs Exp $
+# 
+#  Copyright (C) 1997 Lars Fenneberg
+# 
+#  See the file COPYRIGHT for the respective terms and conditions. 
+#  If the file is missing contact me at lf@elemental.net 
+#  and I'll send you a copy.
+# 
+#
+
+AUTOMAKE_OPTIONS = foreign
+
+EXTRA_DIST = README ip-down ip-up login.radius
diff --git a/pppd/plugins/radius/radiusclient/login.radius/migs/Makefile.in b/pppd/plugins/radius/radiusclient/login.radius/migs/Makefile.in
new file mode 100644
index 0000000..60807df
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/login.radius/migs/Makefile.in
@@ -0,0 +1,186 @@
+# Makefile.in generated automatically by automake 1.3 from Makefile.am
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+# 
+#  $Id: Makefile.in,v 1.1 2002/01/22 16:03:02 dfs Exp $
+# 
+#  Copyright (C) 1997 Lars Fenneberg
+# 
+#  See the file COPYRIGHT for the respective terms and conditions. 
+#  If the file is missing contact me at lf@elemental.net 
+#  and I'll send you a copy.
+# 
+#
+
+
+SHELL = /bin/sh
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+sbindir = @sbindir@
+libexecdir = @libexecdir@
+datadir = @datadir@
+sysconfdir = @sysconfdir@
+sharedstatedir = @sharedstatedir@
+localstatedir = @localstatedir@
+libdir = @libdir@
+infodir = @infodir@
+mandir = @mandir@
+includedir = @includedir@
+oldincludedir = /usr/include
+
+DISTDIR =
+
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+
+top_builddir = ../..
+
+ACLOCAL = @ACLOCAL@
+AUTOCONF = @AUTOCONF@
+AUTOMAKE = @AUTOMAKE@
+AUTOHEADER = @AUTOHEADER@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+transform = @program_transform_name@
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_alias = @build_alias@
+build_triplet = @build@
+host_alias = @host_alias@
+host_triplet = @host@
+target_alias = @target_alias@
+target_triplet = @target@
+AR = @AR@
+CC = @CC@
+LD = @LD@
+LIBTOOL = @LIBTOOL@
+LIBVERSION = @LIBVERSION@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+NM = @NM@
+PACKAGE = @PACKAGE@
+RANLIB = @RANLIB@
+RC_LOG_FACILITY = @RC_LOG_FACILITY@
+RC_SECURE_PATH = @RC_SECURE_PATH@
+VERSION = @VERSION@
+pkgsysconfdir = @pkgsysconfdir@
+
+AUTOMAKE_OPTIONS = foreign
+
+EXTRA_DIST = README ip-down ip-up login.radius
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = ../../config.h
+CONFIG_CLEAN_FILES = 
+DIST_COMMON =  README Makefile.am Makefile.in
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = tar
+GZIP = --best
+all: Makefile
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && $(AUTOMAKE) --foreign --include-deps login.radius/migs/Makefile
+
+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+tags: TAGS
+TAGS:
+
+
+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
+
+subdir = login.radius/migs
+
+distdir: $(DISTFILES)
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  test -f $(distdir)/$$file \
+	  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	  || cp -p $$d/$$file $(distdir)/$$file; \
+	done
+info:
+dvi:
+check: all
+	$(MAKE)
+installcheck:
+install-exec: 
+	@$(NORMAL_INSTALL)
+
+install-data: 
+	@$(NORMAL_INSTALL)
+
+install: install-exec install-data all
+	@:
+
+uninstall: 
+
+install-strip:
+	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install
+installdirs:
+
+
+mostlyclean-generic:
+	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-rm -f Makefile $(DISTCLEANFILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+mostlyclean:  mostlyclean-generic
+
+clean:  clean-generic mostlyclean
+
+distclean:  distclean-generic clean
+	-rm -f config.status
+	-rm -f libtool
+
+maintainer-clean:  maintainer-clean-generic distclean
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+.PHONY: tags distdir info dvi installcheck install-exec install-data \
+install uninstall all installdirs mostlyclean-generic distclean-generic \
+clean-generic maintainer-clean-generic clean mostlyclean distclean \
+maintainer-clean
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/pppd/plugins/radius/radiusclient/login.radius/migs/README b/pppd/plugins/radius/radiusclient/login.radius/migs/README
new file mode 100644
index 0000000..fe35eb6
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/login.radius/migs/README
@@ -0,0 +1,10 @@
+This sample login.radius was contributed by Miguel A.L. Paraz
+<map@iphil.net>. It implements PPP, Telnet and Rlogin connections.
+
+There currently is no documentation but the scripts are very clear and
+should provide a good starting point.
+
+The ip-up and ip-down scripts must be installed under /etc/ppp so that the
+pppd can find them.
+
+lf, 970524
diff --git a/pppd/plugins/radius/radiusclient/login.radius/migs/ip-down b/pppd/plugins/radius/radiusclient/login.radius/migs/ip-down
new file mode 100644
index 0000000..c29bd2a
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/login.radius/migs/ip-down
@@ -0,0 +1,69 @@
+#!/usr/bin/perl
+#
+# ip-down
+# 
+# Script started when the PPP daemon disconnects.
+#
+
+use strict;
+use GDBM_File;
+
+
+#### RADIUS Begins
+
+my ($sessionid, $username, $port, $portid, $timeout) = split (/:/, $ARGV[5]);
+
+if ($sessionid) 
+{
+# Code to inform the server that we're getting out.
+
+# Port information database.
+    my $path_portinfo = "/var/ipoint/acct/portinfo"; 
+
+
+# Radius accounting record generator.
+    my $prog_radacct = "/usr/local/lib/radiusclient/radacct";
+
+# The session ID, username, raw port and ID are given to this script 
+# through the ipparam parameter of pppd 2.2.0e and above.
+
+# Generate the accounting entry, and hand it over to RADIUS.
+
+# Delete the port info entry since the user has logged off, but make use
+# of the starting time.
+    my (%s, @e, $sessiontime);
+    tie (%s, "GDBM_File", $path_portinfo, GDBM_WRCREAT, 0600);
+    @e = split (':', $s{$portid});
+
+    if ($e[4])
+    {
+	$sessiontime = time() - $e[4];
+    }
+
+    delete $s{$portid};
+    untie (%s);
+
+# Generate the accounting entry, and hand it over to RADIUS.
+
+    open  (H, "| $prog_radacct -i $port");
+
+    my $cmd =
+	"Acct-Session-ID = \"$sessionid\"\n" .
+	"User-Name = \"$username\"\n" .
+	"Acct-Status-Type = Stop\n" .
+	"Acct-Authentic = RADIUS\n" .
+	"Service-Type = Framed\n" .
+	"Framed-Protocol = PPP\n" .
+	"Framed-IP-Address = $ARGV[4]\n";
+
+    if ($sessiontime)
+    {
+	$cmd .= "Acct-Session-Time = $sessiontime\n";
+    }
+
+    print H $cmd;
+    close (H);
+}
+
+#### RADIUS Ends
+
diff --git a/pppd/plugins/radius/radiusclient/login.radius/migs/ip-up b/pppd/plugins/radius/radiusclient/login.radius/migs/ip-up
new file mode 100644
index 0000000..c1e06db
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/login.radius/migs/ip-up
@@ -0,0 +1,121 @@
+#!/usr/bin/perl
+#
+# ip-up
+# 
+# Script started when the PPP daemon makes a connection.
+#
+
+# This script is given:
+# interface-name tty-device speed local-IP-address remote-IP-address
+# Since this is a PPP server, local-IP-address does not change.
+
+# TODO: Clean up this file and make it really modular.
+
+use strict;
+use GDBM_File;
+
+#### RADIUS section Begins
+
+# Configuration section.
+
+# Port information database.
+my $path_portinfo = "/var/ipoint/acct/portinfo"; 
+
+
+# Radius accounting record generator.
+    my $prog_radacct = "/usr/local/lib/radiusclient/radacct";
+
+sub netmask 
+{
+    my $count = int ($_[0] / 8);
+    
+    my $c1 = ("255." x $count);
+    $c1 = substr ($c1, 0, -1) if ($count == 4);
+    my $c2 = (256 - (1<<(8 - ($_[0] - $count * 8)))) || "0";
+    $c2 .= '.' if ($count < 3);
+    my $c3 = substr (("0." x (3-$count)), 0, -1);
+    return $c1 . $c2. $c3;
+}
+
+my ($sessionid, $username, $port, $portid, $timeout, $routelist) = 
+    split (/:/, $ARGV[5]);
+
+if ($sessionid) 
+{
+# I-Way code to inform the server that we're getting in.
+
+# If there was routing, add it.  Format for $route, from the Framed-Route
+# parameter, is address/netmask gateway metric.  If gateway is 0.0.0.0,
+# add the route here.
+
+# Unescape the route list.
+    $routelist =~ s/%20/ /g;
+
+    my $route;
+
+    # Debug this.
+    open (H, ">>/tmp/ip-up.log");
+    print H "ROUTELIST: " . $routelist . "\n";
+
+    foreach $route (split ("@", $routelist)) {
+	# Split the route into the components.
+	my @routevalue = split (' ', $route);
+	my ($netmaskcmd, $gwcmd, $metriccmd);
+	my @network = split ("/", $routevalue[0]);
+	
+	if ($network[1]) {
+	    $netmaskcmd = "netmask " . netmask($network[1]);
+	}
+
+	if ($routevalue[1] eq "0.0.0.0") {
+	    $gwcmd = "gw $ARGV[4]";
+	}
+	elsif ($routevalue[1]) {
+	    $gwcmd = "gw $routevalue[1]";
+	}
+	
+	if ($routevalue[2]) {
+	    $metriccmd = "metric $routevalue[2]";
+	}
+
+	my $routecmd = "/sbin/route add -net $network[0] $netmaskcmd $gwcmd " .
+	    "$metriccmd";
+    
+	system ($routecmd);
+	print H "COMMAND: " . $routecmd . "\n";
+    }
+    close (H);
+
+# The session ID, username, raw port and ID are given to this script 
+# through the ipparam parameter of pppd 2.2.0e and above.
+
+# Generate the accounting entry, and hand it over to RADIUS.
+
+    open  (H, "| $prog_radacct -i $port");
+
+    my $cmd =
+	"Acct-Session-ID = \"$sessionid\"\n" .
+	"User-Name = \"$username\"\n" .
+	"Acct-Status-Type = Start\n" .
+	"Acct-Authentic = RADIUS\n" .
+	"Service-Type = Framed\n" .
+	"Framed-Protocol = PPP\n" .
+	"Framed-IP-Address = $ARGV[4]\n";
+
+    print H $cmd;
+    close (H);
+}
+
+# Store the username, the connection type, the IP address, the PID of pppd.
+# Index it on the port ID, since 'portman' makes use of this.
+
+my ($timenow, %s);
+$timenow = time();
+tie (%s, "GDBM_File", $path_portinfo, GDBM_WRCREAT, 0600);
+$s{$portid} = join (':', $username, "Framed-User/PPP", $ARGV[4], getppid (),
+		    $timenow, $timeout);
+untie (%s);
+
+
+#### RADIUS ends
+
diff --git a/pppd/plugins/radius/radiusclient/login.radius/migs/login.radius b/pppd/plugins/radius/radiusclient/login.radius/migs/login.radius
new file mode 100644
index 0000000..3852695
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/login.radius/migs/login.radius
@@ -0,0 +1,312 @@
+#!/usr/bin/perl
+#
+# login program to invoke PPP.
+# RADIUS accounting is NOT handled by this; it is handled by /etc/ppp/
+# ip-up and ip-down which are invoked when the TCP/IP connection is up.
+
+# version 0.1   November 5 1996
+# clean up the code, minor features.
+
+# version 0.02  May 8 1996
+#
+# start implementing other types of logins, not only Framed.
+# Also honor static IP addresses.
+#
+# version 0.01  April 1 1996
+#
+# - ignore RADIUS server requests for Framed-User, just
+#   do PPP.  Later, this should be honored.  For now,
+#   just use RADIUS for authentication; it's much simpler.
+#   Always use dynamic addresses.
+#
+
+use strict;
+use GDBM_File;
+
+#### CONFIGURATION SECTION ##################################################
+
+# Local IP address for the PPP connection.
+my $ip_address_local = "203.176.0.3";
+
+# First IP address for this terminal server, if dynamic addressing
+# is requested, or if nothing is specified for Framed-IP-Address.
+my $ip_address_begin = "203.176.0.161";
+
+# IP translation factor; subtract this value from radclient before adding
+# the beginning IP address.
+my $ip_translate_factor = 32;
+
+# Debugging to screen?
+my $debug = 1;
+
+# PPP parameters:
+
+# Async map - this one escapes only XON and XOFF characters.
+my $asyncmap = "0x000A0000";
+
+# MTU and MRU. 296 is good for interactive performance,
+# but larger ones will lead to less overhead for file transfers.
+# Maximum is 1500.
+my ($mtu, $mru) = (296, 296);
+
+# If we're using proxy ARP, set this to "proxyarp", else leave it blank.
+# my $proxyarp = "proxyarp";
+my $proxyarp = "";
+
+# Login host for non-framed connections.
+# This should only be an IP address, since that's what
+# Login-IP-Host should be.
+my $login_host = "203.176.0.4"; # marikit.iphil.net
+
+# Programs and files.
+my $prog_pppd     = "/usr/sbin/pppd";
+my $prog_radacct  = "/usr/local/lib/radiusclient/radacct";
+my $prog_rlogin   = "/usr/bin/rlogin";
+my $prog_telnet   = "/bin/telnet";
+my $prog_tcpclear = "/bin/telnet -e ''";
+my $prog_tty      = "/usr/bin/tty";
+my $prog_who      = "/usr/bin/who";
+
+my $path_portinfo         = "/var/ipoint/acct/portinfo";
+my $path_radiusclient_map = "/etc/radclient/port-id-map";
+
+#############################################################################
+
+# Main program.
+
+print "Starting.\n" if ($debug);
+
+# Run 'who am i' to determine the current port.
+my $port = `$prog_tty`;
+chomp ($port);
+
+# Translate port numbers to numbers for RADIUS.
+# This translation is done again by radacct, but it may be useful here.
+# Remove if CPU time is a problem.
+
+my ($portid, $line);
+open (H, $path_radiusclient_map);
+while (($line = <H>) && (!$portid))
+{
+    my @info = split (/\s+/, $line);
+    $portid = $info[1] if ($info[0] eq $port);
+}
+close (H);
+
+if ($debug)
+{
+    # Print out all the RADIUS variables.
+    my @el = grep (/^RADIUS/, keys (%ENV));
+    my $e;
+    foreach $e (@el)
+    {
+	print "$e = " . $ENV{$e} . "\n";
+    }
+}
+
+# If the service type is Framed, then give them PPP.
+# SLIP is not implemented (and will probably never be).
+
+my $username = $ENV{"RADIUS_USER_NAME"};
+
+# Generate a "unique" string for the session ID.
+my $sessionid = "$$" . time ();
+
+if ($ENV{"RADIUS_SERVICE_TYPE"} =~ /^Framed$/)
+{
+   
+# Use the specified IP address, or generate one if none is specified,
+# or a dynamic one requested.  Or, let the user negotiate the address.
+
+    my $ip_address = $ENV{"RADIUS_FRAMED_IP_ADDRESS"};
+
+    if (!$ip_address || ($ip_address eq "255.255.255.254"))
+    {
+	my @ipn = split (/\./, $ip_address_begin);
+	$ipn[3] += $portid - $ip_translate_factor;
+	$ip_address = join ('.', @ipn);
+
+	if ($debug)
+	{
+	    print "port: $port\n";
+	    print "portid: $portid\n";
+	    print "ip_translate_factor: $ip_translate_factor\n";
+	    print "ip_address: $ip_address\n";
+	    print "mru: $mru\n";
+	}
+
+    }
+    elsif ($ip_address eq "255.255.255.255")
+    {
+	# Clear it out so that pppd will let the remote end specify the
+	# IP address.
+	$ip_address = "";
+    }
+
+    # Override the specified MTU.
+    $mtu = $ENV{"RADIUS_FRAMED_MTU"} if $ENV{"RADIUS_FRAMED_MTU"};
+
+    # If no compression is specified, turn it off.
+    my $compress;
+    if (!$ENV{"RADIUS_FRAMED_COMPRESSION"})
+    {
+	$compress = "-vj";
+    }
+
+# Fix up the parameters to be passed to ip-up.  Include Framed-Route.
+# Escape spaces with %20's.
+
+    # Split up the framed route into multiple parts.
+    # Separate the different given routes with bars.
+    my $routelist = join ("@", map {$ENV{$_}}
+			     grep {/^RADIUS_FRAMED_ROUTE/} keys (%ENV)
+			    );
+    $routelist =~ s/ /%20/g;
+
+    my $param = join (':', $sessionid, $username, $port, $portid,
+		      $ENV{"RADIUS_SESSION_TIMEOUT"}, $routelist);
+
+		      
+# Run pppd through exec, so that it grabs hold of the terminal
+# and catches disconnections.
+
+    # Portmaster-style prompt.
+    if ($ENV{"RADIUS_SESSION_TIMEOUT"})
+    {
+	print "Session timeout: " . $ENV{"RADIUS_SESSION_TIMEOUT"} .
+	    " seconds.\n";
+    }
+    print "PPP session from ($ip_address_local) to $ip_address beginning....";
+    my $pppdcmd =
+	"$prog_pppd $ip_address_local:$ip_address modem crtscts " .
+	"asyncmap $asyncmap lock -detach $compress " .
+	"ipparam $param mtu $mtu mru $mru $proxyarp";
+
+    exec ($pppdcmd);
+}
+elsif ($ENV{"RADIUS_SERVICE_TYPE"} =~ /Login/)
+{
+    # Warning:  This code has not been tested as well as the PPP version,
+    # as of now (19961107).
+
+    # Determine what host to connect to.
+    if (($ENV{"RADIUS_LOGIN_IP_HOST"} eq "0.0.0.0") ||
+	!defined ($ENV{"RADIUS_LOGIN_IP_HOST"}))
+    {
+	# Do nothing, it's already specified above in the config section.
+    }
+    elsif ($ENV{"RADIUS_LOGIN_IP_HOST"} eq "255.255.255.255")
+    {
+	# The user should be able to choose.  Prompt the user.
+	print "Host to connect to?  ";
+	$login_host = <STDIN>;
+	chomp ($login_host);
+    }
+    else
+    {
+	# Use what's specified by the RADIUS server.
+	$login_host = $ENV{"RADIUS_LOGIN_IP_HOST"};
+    }
+    
+    # Log into a host.  Default to telnet.  Do the accounting
+    # now, since the target of the login wouldn't know how to
+    # account for it.
+
+    # Start accounting.  Send the record.
+    open  (H, "| $prog_radacct") || die ("Cannot run $prog_radacct");
+
+    my $login_service = $ENV{"RADIUS_LOGIN_SERVICE"};
+
+    my $cmd =
+	"Acct-Session-ID = \"$sessionid\"\n" .
+	"User-Name = \"$username\"\n" .
+	"Acct-Status-Type = Start\n" .
+        "Acct-Authentic = RADIUS\n" .
+        "Service-Type = Login\n" .
+        "Login-Service = " . $login_service . "\n" .
+        "Login-IP-Host = $login_host\n";
+
+    print H $cmd;
+    close (H);
+
+    # Time.
+    my $timestart = time ();
+
+    # What protocol are we running?
+    my ($prog_run, $login_port);
+
+    if ($login_service eq "Rlogin")
+    {
+	$prog_run = $prog_rlogin;
+    }
+    elsif ($login_service eq "Telnet")
+    {
+	$prog_run = $prog_telnet;
+	$login_port = $ENV{"RADIUS_LOGIN_PORT"};
+    }
+    elsif ($login_service eq "TCP-Clear")
+    {
+	$prog_run = $prog_tcpclear;
+	$login_port = $ENV{"RADIUS_LOGIN_PORT"};
+    }
+
+    # Store the user information into portinfo.  We need to
+    # manually fork, since we have to know the PID of the program.
+
+    my $pid = fork ();
+    if ($pid == 0)
+    {
+	# Child.  Run the program.
+	# print "Connecting to $login_host:\n";
+	my $cmd = "$prog_run $login_host $login_port";
+	exec ("$cmd");
+    }
+    else
+    {
+	# Parent.  
+	# Create the portinfo record, which needs the pid of the program
+	# to kill.
+	# The IP address is all zero, as it is not applicable here.
+	# Store the time now, and the Session-Timeout.
+
+	my %db_portinfo;
+
+	tie (%db_portinfo, "GDBM_File", $path_portinfo, GDBM_WRCREAT, 0600);
+	$db_portinfo{$portid} =
+	    join (':', $username, "Login/$login_service",
+		  "0.0.0.0", $pid, $timestart, $ENV{"RADIUS_SESSION_TIMEOUT"});
+	untie (%db_portinfo);
+
+	# Wait for the session to finish.
+	waitpid ($pid, 0);
+    }
+    # Stop.  Send the record.
+    open  (H, "| $prog_radacct") || die ("Cannot run $prog_radacct");
+
+    my $timespent = time () - $timestart;
+
+    my $cmd =
+	"Acct-Session-ID = \"$sessionid\"\n" .
+	"User-Name = \"$username\"\n" .
+	"Acct-Status-Type = Stop\n" .
+        "Acct-Authentic = RADIUS\n" .
+        "Service-Type = Login\n" .
+        "Login-Service = " . $login_service . "\n" .
+        "Login-IP-Host = $login_host\n" .
+        "Acct-Session-Time = $timespent\n";
+
+    print H $cmd;
+    close (H);
+
+    # Remove the record from portinfo.
+    my %db_portinfo;
+    tie (%db_portinfo, "GDBM_File", $path_portinfo, GDBM_WRCREAT, 0600);
+    delete $db_portinfo{$portid};
+    untie (%db_portinfo);
+}
+
+### END ####
+
+
+
+
diff --git a/pppd/plugins/radius/radiusclient/ltconfig b/pppd/plugins/radius/radiusclient/ltconfig
new file mode 100755
index 0000000..7bba4e6
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/ltconfig
@@ -0,0 +1,1064 @@
+#! /bin/sh
+
+# ltconfig - Create a system-specific libtool.
+# When updating this script, search for LINENUM and fix line number refs.
+# Generated automatically from ltconfig.in by configure.
+# Copyright (C) 1996, 1997, Free Software Foundation, Inc.
+# Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+#
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# A lot of this script is taken from autoconf-2.10.
+
+# The name of this program.
+progname=`echo "$0" | sed 's%^.*/%%'`
+
+# Constants:
+PROGRAM=ltconfig
+PACKAGE=libtool
+VERSION=1.0
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.c 1>&5'
+rm="rm -f"
+
+help="Try \`$progname --help' for more information."
+
+# Global variables:
+can_build_shared=yes
+enable_shared=yes
+# All known linkers require a `.a' archive for static linking.
+enable_static=yes
+ltmain=
+silent=
+srcdir=
+ac_config_guess=
+ac_config_sub=
+host=
+nonopt=
+verify_host=yes
+with_gcc=no
+with_gnu_ld=no
+
+old_AR="$AR"
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
+old_CPPFLAGS="$CPPFLAGS"
+old_LD="$LD"
+old_LN_S="$LN_S"
+old_RANLIB="$RANLIB"
+
+test -z "$AR" && AR=ar
+
+# Parse the command line options.
+args=
+prev=
+for option
+do
+  case "$option" in
+  -*=*) optarg=`echo "$option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
+  *) optarg= ;;
+  esac
+
+  # If the previous option needs an argument, assign it.
+  if test -n "$prev"; then
+    eval "$prev=\$option"
+    prev=
+    continue
+  fi
+
+  case "$option" in
+  --help) cat <<EOM
+Usage: $progname [OPTION]... LTMAIN [HOST]
+
+Generate a system-specific libtool script.
+
+    --disable-shared       do not build shared libraries
+    --disable-static       do not build static libraries
+    --help                 display this help and exit
+    --no-verify            do not verify that HOST is a valid host type
+    --quiet                same as \`--silent'
+    --silent               don't print informational messages
+    --srcdir=DIR           find \`config.guess' in DIR
+    --version              output version information and exit
+    --with-gcc             assume that the GNU C compiler will be used
+    --with-gnu-ld          assume that the C compiler uses the GNU linker
+
+LTMAIN is the \`ltmain.sh' shell script fragment that provides basic libtool
+functionality.
+
+HOST is the canonical host system name [default=guessed].
+EOM
+  exit 0
+  ;;
+
+  --disable-shared) enable_shared=no ;;
+
+  --disable-static) enable_static=no ;;
+
+  --quiet | --silent) silent=yes ;;
+
+  --srcdir) prev=srcdir ;;
+  --srcdir=*) srcdir="$optarg" ;;
+
+  --no-verify) verify_host=no ;;
+
+  --version) echo "$PROGRAM (GNU $PACKAGE) $VERSION"; exit 0 ;;
+
+  --with-gcc) with_gcc=yes ;;
+  --with-gnu-ld) with_gnu_ld=yes ;;
+
+  -*)
+    echo "$progname: unrecognized option \`$option'" 1>&2
+    echo "$help" 1>&2
+    exit 1
+    ;;
+
+  *)
+    if test -z "$ltmain"; then
+      ltmain="$option"
+    elif test -z "$host"; then
+# FIXME This generates an unnecessary warning for sparc-sun-solaris4.1.3_U1
+#      if test -n "`echo $option| sed 's/[-a-z0-9.]//g'`"; then
+#        echo "$progname: warning \`$option' is not a valid host type" 1>&2
+#      fi
+      host="$option"
+    else
+      echo "$progname: too many arguments" 1>&2
+      echo "$help" 1>&2
+      exit 1
+    fi ;;
+  esac
+done
+
+if test -z "$ltmain"; then
+  echo "$progname: you must specify a LTMAIN file" 1>&2
+  echo "$help" 1>&2
+  exit 1
+fi
+
+if test -f "$ltmain"; then :
+else
+  echo "$progname: warning: \`$ltmain' does not exist" 1>&2
+fi
+
+# Quote any args containing shell metacharacters.
+ltconfig_args=
+for arg
+do
+  case "$arg" in
+  *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
+  ltconfig_args="$ltconfig_args '$arg'" ;;
+  *) ltconfig_args="$ltconfig_args $arg" ;;
+  esac
+done
+
+# A relevant subset of AC_INIT.
+
+# File descriptor usage:
+# 0 standard input
+# 1 file creation
+# 2 errors and warnings
+# 3 some systems may open it to /dev/tty
+# 4 used on the Kubota Titan
+# 5 compiler messages saved in config.log
+# 6 checking for... messages and results
+if test "$silent" = yes; then
+  exec 6>/dev/null
+else
+  exec 6>&1
+fi
+exec 5>>./config.log
+
+# NLS nuisances.
+# Only set LANG and LC_ALL to C if already set.
+# These must not be set unconditionally because not all systems understand
+# e.g. LANG=C (notably SCO).
+if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
+if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
+
+if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
+  # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
+  if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
+    ac_n= ac_c='
+' ac_t='	'
+  else
+    ac_n=-n ac_c= ac_t=
+  fi
+else
+  ac_n= ac_c='\c' ac_t=
+fi
+
+if test -z "$srcdir"; then
+  # Assume the source directory is the same one as the path to ltmain.sh.
+  srcdir=`echo "$ltmain" | sed 's%/[^/]*$%%'`
+  test "$srcdir" = "$ltmain" && srcdir=.
+fi
+
+if test "$verify_host" = yes; then
+  # Check for config.guess and config.sub.
+  ac_aux_dir=
+  for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+    if test -f $ac_dir/config.guess; then
+      ac_aux_dir=$ac_dir
+      break
+    fi
+  done
+  if test -z "$ac_aux_dir"; then
+    echo "$progname: cannot find config.guess in $srcdir $srcdir/.. $srcdir/../.." 1>&2
+    echo "$help" 1>&2
+    exit 1
+  fi
+  ac_config_guess=$ac_aux_dir/config.guess
+  ac_config_sub=$ac_aux_dir/config.sub
+
+  # Make sure we can run config.sub.
+  if $ac_config_sub sun4 >/dev/null 2>&1; then :
+  else
+    echo "$progname: cannot run $ac_config_sub" 1>&2
+    echo "$help" 1>&2
+    exit 1
+  fi
+
+  echo $ac_n "checking host system type""... $ac_c" 1>&6
+
+  host_alias=$host
+  case "$host_alias" in
+  "")
+    if host_alias=`$ac_config_guess`; then :
+    else
+      echo "$progname: cannot guess host type; you must specify one" 1>&2
+      echo "$help" 1>&2
+      exit 1
+    fi ;;
+  esac
+  host=`$ac_config_sub $host_alias`
+  echo "$ac_t""$host" 1>&6
+
+elif test -z "$host"; then
+  echo "$progname: you must specify a host type if you use \`--no-verify'" 1>&2
+  echo "$help" 1>&2
+  exit 1
+else
+  host_alias=$host
+fi
+
+# Transform *-*-linux* to *-*-linux-gnu*, to support old configure scripts.
+case "$host" in
+*-*-linux-gnu*) ;;
+*-*-linux*) host=`echo $host | sed 's/^\(.*-.*-linux\)\(.*\)$/\1-gnu\2/'`
+esac
+
+host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR cru $oldlib$oldobjs'
+old_postinstall_cmds='chmod 644 $oldlib'
+
+# If RANLIB is not set, then run the test.
+if test "${RANLIB+set}" != "set"; then
+  result=no
+
+  echo $ac_n "checking for ranlib... $ac_c" 1>&6
+  IFS="${IFS= 	}"; save_ifs="$IFS"; IFS="${IFS}:"
+  for dir in $PATH; do
+    test -z "$dir" && dir=.
+    if test -f $dir/ranlib; then
+      RANLIB="ranlib"
+      result="ranlib"
+      break
+    fi
+  done
+  IFS="$save_ifs"
+
+  echo $ac_t "$result" 1>&6
+fi
+
+if test -n "$RANLIB"; then
+  old_archive_cmds="$old_archive_cmds;\$RANLIB \$oldlib"
+  old_postinstall_cmds="$old_postinstall_cmds;\$RANLIB \$oldlib"
+fi
+
+# Check to see if we are using GCC.
+if test "$with_gcc" != yes || test -z "$CC"; then
+  # If CC is not set, then try to find GCC or a usable CC.
+  if test -z "$CC"; then
+    echo $ac_n "checking for gcc... $ac_c" 1>&6
+    IFS="${IFS= 	}"; save_ifs="$IFS"; IFS="${IFS}:"
+    for dir in $PATH; do
+      IFS="$save_ifs"
+      test -z "$dir" && dir=.
+      if test -f $dir/gcc; then
+	CC="gcc"
+	break
+      fi
+    done
+    IFS="$save_ifs"
+
+    if test -n "$CC"; then
+      echo "$ac_t""$CC" 1>&6
+    else
+      echo "$ac_t""no" 1>&6
+    fi
+  fi
+
+  # Not "gcc", so try "cc", rejecting "/usr/ucb/cc".
+  if test -z "$CC"; then
+    echo $ac_n "checking for cc... $ac_c" 1>&6
+    IFS="${IFS= 	}"; save_ifs="$IFS"; IFS="${IFS}:"
+    cc_rejected=no
+    for dir in $PATH; do
+      test -z "$dir" && dir=.
+      if test -f $dir/cc; then
+	if test "$dir/cc" = "/usr/ucb/cc"; then
+	  cc_rejected=yes
+	  continue
+	fi
+	CC="cc"
+	break
+      fi
+    done
+    IFS="$save_ifs"
+    if test $cc_rejected = yes; then
+      # We found a bogon in the path, so make sure we never use it.
+      set dummy $CC
+      shift
+      if test $# -gt 0; then
+	# We chose a different compiler from the bogus one.
+	# However, it has the same name, so the bogon will be chosen
+	# first if we set CC to just the name; use the full file name.
+	shift
+	set dummy "$dir/cc" "$@"
+	shift
+	CC="$@"
+      fi
+    fi
+
+    if test -n "$CC"; then
+      echo "$ac_t""$CC" 1>&6
+    else
+      echo "$ac_t""no" 1>&6
+    fi
+
+    if test -z "$CC"; then
+      echo "$progname: error: no acceptable cc found in \$PATH" 1>&2
+      exit 1
+    fi
+  fi
+
+  # Now see if the compiler is really GCC.
+  with_gcc=no
+  echo $ac_n "checking whether we are using GNU C... $ac_c" 1>&6
+
+  trap "$rm conftest.c; exit 1" 1 2 15
+  $rm conftest.c
+  cat > conftest.c <<EOF
+#ifdef __GNUC__
+  yes;
+#endif
+EOF
+  # LINENUM
+  if { ac_try='${CC-cc} -E conftest.c'; { (eval echo $progname:378: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+    with_gcc=yes
+  fi
+  $rm conftest.c
+  echo $ac_t "$with_gcc" 1>&6
+fi
+
+# Allow CC to be a program name with arguments.
+set dummy $CC
+compiler="$2"
+
+echo $ac_n "checking for $compiler option to produce PIC... $ac_c" 1>&6
+pic_flag=
+profile_flag_pattern=
+special_shlib_compile_flags=
+wl=
+link_static_flag=
+
+if test "$with_gcc" = yes; then
+  pic_flag='-fPIC'
+  profile_flag_pattern='-pg?'
+  wl='-Wl,'
+  link_static_flag='-static'
+else
+  # PORTME Check for PIC flags for the system compiler.
+  case "$host_os" in
+  aix3* | aix4*)
+    # FIXME All rs/6000 code is PIC, but is there any non-rs/6000 AIX platform?
+    pic_flag=
+    link_static_flag='-bnso -bI:/lib/syscalls.exp'
+    ;;
+
+  hpux9* | hpux10*)
+    # FIXME is there a better link_static_flag that works with the bundled CC?
+    wl='-Wl,'
+    link_static_flag='${wl}-a ${wl}archive'
+    pic_flag='+Z'
+    ;;
+
+  irix5* | irix6*)
+    wl='-Wl,'
+    link_static_flag='-non_shared'
+    # PIC (with -KPIC) is the default.
+    pic_flag=
+    ;;
+
+  osf3* | osf4*)
+    # FIXME - pic_flag is probably required for hppa*-osf* and i860-osf*
+    wl='-Wl,'
+    link_static_flag='-non_shared'
+    ;;
+
+  sco3.2v5*)
+    pic_flag='-Kpic'
+    link_static_flag='-dn'
+    special_shlib_compile_flags='-belf'
+    ;;
+
+  solaris2*)
+    pic_flag='-KPIC'
+    link_static_flag='-Bstatic'
+    wl='-Wl,'
+    ;;
+
+  sunos4*)
+    pic_flag='-PIC'
+    link_static_flag='-Bstatic'
+    wl='-Qoption ld '
+    ;;
+
+  *)
+    can_build_shared=no
+    ;;
+  esac
+fi
+
+case "$host_cpu" in
+rs6000 | powerpc | powerpcle)
+  # Yippee! All RS/6000 and PowerPC code is position-independent.
+  pic_flag=
+  ;;
+esac
+
+if test -n "$pic_flag"; then
+  echo $ac_t "$pic_flag" 1>&6
+  pic_flag=" $pic_flag"
+else
+  echo $ac_t none 1>&6
+fi
+
+# Check for any special shared library compilation flags.
+if test -n "$special_shlib_compile_flags"; then
+  echo "$progname: warning: \`$CC' requires \`$special_shlib_compile_flags' to build shared libraries" 1>&2
+  if echo "$old_CC $old_CFLAGS " | egrep -e "[ 	]$special_shlib_compile_flags[ 	]" >/dev/null; then :
+  else
+    echo "$progname: add \`$special_shlib_compile_flags' to the CC or CFLAGS env variable and reconfigure" 1>&2
+    can_build_shared=no
+  fi
+fi
+
+# See if we are using a broken GCC collect2 program.
+if test "$with_gcc" = yes; then
+  echo $ac_n "checking for broken GCC collect2... $ac_c" 1>&6
+
+  # FIXME: Run a test here, instead of relying on the canonical system name.
+  case "$host_os" in
+  aix3*)
+    can_build_shared=no
+    echo $ac_t yes 1>&6
+    echo "$progname: to build shared libraries, set the CC env variable to \`xlc' and reconfigure" 1>&2
+    ;;
+  *)
+    echo $ac_t no 1>&6
+    ;;
+  esac
+fi
+
+echo $ac_n "checking for $compiler option to statically link programs... $ac_c" 1>&6
+if test -n "$link_static_flag"; then
+  echo $ac_t "$link_static_flag" 1>&6
+else
+  echo $ac_t none 1>&6
+fi
+
+if test -z "$LN_S"; then
+  # Check to see if we can use ln -s, or we need hard links.
+  echo $ac_n "checking whether ln -s works... $ac_c" 1>&6
+  rm -f conftestdata
+  if ln -s X conftestdata 2>/dev/null; then
+    rm -f conftestdata
+    LN_S="ln -s"
+  else
+    LN_S=ln
+  fi
+  if test "$LN_S" = "ln -s"; then
+    echo "$ac_t"yes 1>&6
+  else
+    echo "$ac_t"no 1>&6
+  fi
+fi
+
+if test "$with_gnu_ld" != yes || test -z "$LD"; then
+  if test -z "$LD"; then
+    if test "$with_gnu_ld" = yes; then
+      echo $ac_n "checking for GNU ld... $ac_c" 1>&6
+    else
+      echo $ac_n "checking for non-GNU ld... $ac_c" 1>&6
+    fi
+
+    IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+    for ac_dir in $PATH; do
+      test -z "$ac_dir" && ac_dir=.
+      if test -f "$ac_dir/ld"; then
+	LD="$ac_dir/ld"
+	# Check to see if the program is GNU ld.  I'd rather use --version,
+	# but apparently some GNU ld's only accept -v.
+	# Break only if it was the GNU/non-GNU ld that we prefer.
+	if "$LD" -v 2>&1 < /dev/null | egrep '(GNU ld|with BFD)' > /dev/null; then
+	  test "$with_gnu_ld" = yes && break
+	else
+	  test "$with_gnu_ld" != yes && break
+	fi
+      fi
+    done
+    IFS="$ac_save_ifs"
+
+    if test -n "$LD"; then
+      echo "$ac_t""$LD" 1>&6
+    else
+      echo "$ac_t""no" 1>&6
+    fi
+
+    if test -z "$LD"; then
+      echo "$progname: error: no acceptable ld found in \$PATH" 1>&2
+      exit 1
+    fi
+  fi
+
+  echo $ac_n "checking whether we are using GNU ld... $ac_c" 1>&6
+  # I'd rather use --version here, but apparently some GNU ld's only accept -v.
+  if $LD -v 2>&1 </dev/null | egrep '(GNU ld|with BFD)' > /dev/null; then
+    with_gnu_ld=yes
+  fi
+  echo $ac_t "$with_gnu_ld" 1>&6
+fi
+
+# See if the linker supports building shared libraries.
+echo $ac_n "checking whether the linker ($LD) supports shared libraries... $ac_c" 1>&6
+
+allow_undefined_flag=
+archive_cmds=
+export_dynamic_flag=
+hardcode_libdir_flag_spec=
+hardcode_libdir_separator=
+hardcode_direct=no
+hardcode_minus_L=no
+hardcode_runpath_var=no
+hardcode_shlibpath_var=unsupported
+runpath_var=
+
+ld_shlibs=yes
+if test "$with_gnu_ld" = yes; then
+  # See if GNU ld supports shared libraries.
+
+  case "$host_os" in
+  sunos4*)
+    ld_shlibs=yes
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  *)
+    if $LD --help 2>&1 | egrep ': supported targets:.* elf' > /dev/null; then
+      runpath_var=LD_RUN_PATH
+      hardcode_runpath_var=yes
+      ld_shlibs=yes
+    else
+      ld_shlibs=no
+    fi
+    ;;
+  esac
+
+  if test "$ld_shlibs" = yes; then
+    archive_cmds='$cc -shared ${wl}-soname $wl$soname -o $lib$libobjs$deplibs'
+    hardcode_libdir_flag_spec='${wl}-rpath $wl$libdir'
+    export_dynamic_flag='${wl}-export-dynamic'
+  fi
+else
+  # PORTME fill in a description of your system's linker (not GNU ld)
+  case "$host_os" in
+  aix3*)
+    allow_undefined_flag=unsupported
+    archive_cmds='/usr/ucb/nm$libobjs | egrep \" [BD] \" | sed \"s/^.* //\" > $lib.exp;$LD -o $objdir/$soname$libobjs -bE:$lib.exp -T512 -H512 -bM:SRE -lc$deplibs;$AR cru $lib $objdir/$soname'
+    # Note: this linker hardcodes the directories in LIBPATH if there
+    # are no directories specified by -L.
+    hardcode_minus_L=yes
+    ;;
+
+  aix4*)
+    allow_undefined_flag=unsupported
+    archive_cmds='/bin/nm -B$libobjs | egrep \" [BD] \" | sed \"s/^.* //\" > $lib.exp;$cc -o $objdir/$soname$libobjs ${wl}-bE:$lib.exp ${wl}-bM:SRE ${wl}-bnoentry$deplibs;$AR cru $lib $objdir/$soname'
+    hardcode_direct=yes
+    hardcode_minus_L=yes
+    ;;
+
+  # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+  # support.  Future versions do this automatically, but an explicit c++rt0.o
+  # doesn't break anything, and helps significantly (at the cost of a little
+  # extra space).
+  freebsd2.2*)
+    archive_cmds='$LD -Bshareable -o $lib$libobjs$deplibs /usr/lib/c++rt0.o'
+    hardcode_direct=yes
+    hardcode_minus_L=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  # Unfortunately, older versions of FreeBSD 2 don't have this feature.
+  freebsd2*)
+    archive_cmds='$LD -Bshareable -o $lib$libobjs$deplibs'
+    hardcode_direct=yes
+    hardcode_minus_L=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  # FreeBSD 3, at last, uses gcc -shared to do shared libraries.
+  freebsd3*)
+    archive_cmds='$CC -shared -o $lib$libobjs$deplibs'
+    hardcode_direct=yes
+    hardcode_minusL=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  hpux9*)
+    archive_cmds='$rm $objdir/$soname;$LD -b +s +b $install_libdir -o $objdir/$soname$libobjs$deplibs;mv $objdir/$soname $lib'
+    hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+    hardcode_direct=yes
+    hardcode_minus_L=yes
+    ;;
+
+  hpux10*)
+    archive_cmds='$LD -b +h $soname +s +b $install_libdir -o $lib$libobjs$deplibs'
+    hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+    hardcode_direct=yes
+    hardcode_minus_L=yes
+    ;;
+
+  irix5* | irix6*)
+    archive_cmds='$LD -shared -o $lib -soname $soname -set_version $verstring$libobjs -lc$deplibs'
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    ;;
+
+  netbsd* | openbsd*)
+    # Tested with NetBSD 1.2 ld
+    archive_cmds='$LD -Bshareable -o $lib$libobjs$deplibs'
+    hardcode_libdir_flag_spec='-R$libdir'
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  osf3* | osf4*)
+    allow_undefined_flag=' -expect_unresolved'
+    archive_cmds='$LD -shared${allow_undefined_flag} -o $lib -soname $soname -set_version $verstring$libobjs -lc$deplibs'
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    hardcode_libdir_separator=:
+    ;;
+
+  sco3.2v5*)
+    archive_cmds='$LD -G -o $lib$libobjs$deplibs'
+    hardcode_direct=yes
+    ;;
+
+  solaris2*)
+    archive_cmds='$LD -G -z text -h $soname -o $lib$libobjs$deplibs'
+    hardcode_libdir_flag_spec='-R$libdir'
+    hardcode_shlibpath_var=no
+    ;;
+
+  sunos4*)
+    archive_cmds='$LD -assert pure-text -Bstatic -o $lib$libobjs'
+    hardcode_libdir_flag_spec='-L$libdir'
+    hardcode_direct=yes
+    hardcode_minus_L=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  *)
+    ld_shlibs=no
+    can_build_shared=no
+    ;;
+  esac
+fi
+echo $ac_t "$ld_shlibs" 1>&6
+
+# Check hardcoding attributes.
+echo $ac_n "checking how to hardcode library paths into programs... $ac_c" 1>&6
+hardcode_action=
+if test -n "$hardcode_libdir_flag_spec" || \
+   test "$hardcode_runpath_var" = yes; then
+
+  # We can hardcode non-existant directories.
+  if test "$hardcode_direct" != no && \
+     test "$hardcode_minus_L" != no && \
+     test "$hardcode_shlibpath_var" != no; then
+
+    # Linking always hardcodes the temporary library directory.
+    hardcode_action=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    hardcode_action=immediate
+  fi
+elif test "$hardcode_direct" != yes && \
+     test "$hardcode_minus_L" != yes && \
+     test "$hardcode_shlibpath_var" != yes; then
+  # We can't hardcode anything.
+  hardcode_action=unsupported
+else
+  # We can only hardcode existing directories.
+  hardcode_action=relink
+fi
+echo $ac_t "$hardcode_action" 1>&6
+test "$hardcode_action" = unsupported && can_build_shared=no
+
+
+reload_flag=
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+echo $ac_n "checking for $LD option to reload object files... $ac_c" 1>&6
+# PORTME Some linker may need a different reload flag.
+reload_flag='-r'
+echo $ac_t "$reload_flag"
+test -n "$reload_flag" && reload_flag=" $reload_flag"
+
+# PORTME Fill in your ld.so characteristics
+library_names_spec=
+soname_spec=
+postinstall_cmds=
+finish_cmds=
+shlibpath_var=
+version_type=none
+dynamic_linker="$host_os ld.so"
+
+echo $ac_n "checking dynamic linker characteristics... $ac_c" 1>&6
+case "$host_os" in
+aix3* | aix4*)
+  version_type=linux
+  library_names_spec='$libname.so.$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX has no versioning support, so we append a major version to the name.
+  soname_spec='$libname.so.$major'
+  ;;
+
+freebsd2* | freebsd3*)
+  version_type=sunos
+  library_names_spec='$libname.so.$versuffix $libname.so'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+gnu*)
+  version_type=sunos
+  library_names_spec='$libname.so.$versuffix'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+hpux9* | hpux10*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  dynamic_linker="$host_os dld.sl"
+  version_type=sunos
+  shlibpath_var=SHLIB_PATH
+  library_names_spec='$libname.sl.$versuffix $libname.sl.$major $libname.sl'
+  soname_spec='$libname.sl.$major'
+  # HP-UX runs *really* slowly unless shared libraries are mode 555.
+  postinstall_cmds='chmod 555 $lib'
+  ;;
+
+irix5* | irix6*)
+  version_type=osf
+  soname_spec='$libname.so'
+  library_names_spec='$libname.so.$versuffix $libname.so'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux-gnuoldld* | linux-gnuaout* | linux-gnucoff*)
+  dynamic_linker=no
+  ;;
+
+# This must be Linux ELF.
+linux-gnu*)
+  version_type=linux
+  library_names_spec='$libname.so.$versuffix $libname.so.$major $libname.so'
+  soname_spec='$libname.so.$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+
+  if test -f /lib/ld.so.1; then
+    dynamic_linker='GNU ld.so'
+  else
+    # Only the GNU ld.so supports shared libraries on MkLinux.
+    case "$host_cpu" in
+    powerpc*) dynamic_linker=no ;;
+    *) dynamic_linker='Linux ld.so' ;;
+    esac
+  fi
+  ;;
+
+netbsd* | openbsd*)
+  version_type=sunos
+  library_names_spec='$libname.so.$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+osf3* | osf4*)
+  version_type=osf
+  soname_spec='$libname.so'
+  library_names_spec='$libname.so.$versuffix $libname.so'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+sco3.2v5*)
+  version_type=osf
+  soname_spec='$libname.so.$major'
+  library_names_spec='$libname.so.$versuffix $libname.so.$major $libname.so'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+solaris2*)
+  version_type=linux
+  library_names_spec='$libname.so.$versuffix $libname.so.$major $libname.so'
+  soname_spec='$libname.so.$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='$libname.so.$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+echo "$ac_t""$dynamic_linker"
+test "$dynamic_linker" = no && can_build_shared=no
+
+# FIXME need to add library stripping features
+# strip -x works for most platforms, though not for static libraries on NetBSD
+# HP-UX requires "-r" for library stripping
+striplib=
+old_striplib=
+
+#echo $ac_n "checking for static library strip program... $ac_c" 1>&6
+#if test -n "$old_striplib"; then
+#  echo $ac_t "$old_striplib" 1>&6
+#else
+#  echo $ac_t none 1>&6
+#fi
+
+#if test "$can_build_shared" = yes; then
+#  echo $ac_n "checking for shared library strip program... $ac_c" 1>&6
+#
+#  if test -n "$striplib"; then
+#    echo $ac_t "$striplib" 1>&6
+#  else
+#    echo $ac_t none 1>&6
+#  fi
+#fi
+
+# Report the consequences.
+echo "checking if libtool supports shared libraries... $can_build_shared" 1>&6
+
+echo $ac_n "checking whether to build shared libraries... $ac_c" 1>&6
+test "$can_build_shared" = "no" && enable_shared=no
+
+# On AIX, shared libraries and static libraries use the same namespace.
+case "$host_os" in
+aix*)
+  test "$enable_shared" = yes && enable_static=no
+  if test -n "$RANLIB"; then
+    archive_cmds="$archive_cmds;\$RANLIB \$lib"
+    postinstall_cmds='$RANLIB $lib'
+  fi
+  ;;
+esac
+
+echo "$ac_t""$enable_shared" 1>&6
+
+# Make sure either enable_shared or enable_static is yes.
+test "$enable_shared" = yes || enable_static=yes
+
+echo "checking whether to build static libraries... $enable_static" 1>&6
+
+ofile=libtool
+trap "$rm $ofile; exit 1" 1 2 15
+echo creating $ofile
+rm -fr $ofile
+cat <<EOF > $ofile
+#! /bin/sh
+
+# libtool - Provide generalized library-building support services.
+#
+# Generated automatically by $PROGRAM - GNU $PACKAGE $VERSION
+# This program was configured as follows,
+# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+#
+# CC="$old_CC" CFLAGS="$old_CFLAGS" CPPFLAGS="$old_CPPFLAGS" \\
+# LD="$old_LD" RANLIB="$old_RANLIB" LN_S="$old_LN_S" \\
+#   $0$ltconfig_args
+#
+# Compiler and other test output produced by $progname, useful for
+# debugging $progname, is in ./config.log if it exists.
+
+# The version of $progname that generated this script.
+LTCONFIG_VERSION="$VERSION"
+
+# Whether or not to build libtool libraries.
+build_libtool_libs=$enable_shared
+
+# Whether or not to build old-style libraries.
+build_old_libs=$enable_static
+
+# The host system.
+host_alias="$host_alias"
+host="$host"
+
+# The archiver.
+AR='$AR'
+
+# The linker used to build libraries.
+LD='$LD'
+
+# Whether we need hard or soft links.
+LN_S='$LN_S'
+
+# How to create reloadable object files.
+reload_flag='$reload_flag'
+reload_cmds='$reload_cmds'
+
+# How to pass a linker flag through the compiler.
+wl='$wl'
+
+# Additional compiler flags for building library objects.
+pic_flag='$pic_flag'
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag='$link_static_flag'
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag='$export_dynamic_flag'
+
+# Pattern to match compiler flags for creating libNAME_p libraries:
+profile_flag_pattern='$profile_flag_pattern'
+
+# Library versioning type.
+version_type=$version_type
+
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME.
+library_names_spec='$library_names_spec'
+
+# The coded name of the library, if different from the real name.
+soname_spec='$soname_spec'
+
+# Commands used to build and install an old-style archive.
+RANLIB='$RANLIB'
+old_archive_cmds='$old_archive_cmds'
+old_postinstall_cmds='$old_postinstall_cmds'
+
+# Commands used to build and install a shared archive.
+archive_cmds='$archive_cmds'
+postinstall_cmds='$postinstall_cmds'
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag='$allow_undefined_flag'
+
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds='$finish_cmds'
+
+# How to strip a library file.
+striplib='$striplib'
+old_striplib='$old_striplib'
+
+# This is the shared library runtime path variable.
+runpath_var=$runpath_var
+
+# This is the shared library path variable.
+shlibpath_var=$shlibpath_var
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec='$hardcode_libdir_flag_spec'
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator='$hardcode_libdir_separator'
+
+# Set to yes if using DIR/libNAME.so during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct=$hardcode_direct
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L=$hardcode_minus_L
+
+# Set to yes if using RUNPATH_VAR=DIR during linking hardcodes DIR into the
+# resulting binary.
+hardcode_runpath_var=$hardcode_runpath_var
+
+# Set to yes if using SHLIBPATH_VAR=DIR during linking hardcodes DIR into
+# the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var
+
+EOF
+
+# Detect if we are using a relative or absolute path to ltmain.sh.
+case "$ltmain" in
+/*) cat <<EOF2 >> $ofile
+# Execute the libtool backend.
+. $ltmain
+EOF2
+  ;;
+*) cat <<EOF3 >> $ofile
+# Find the path to this script.
+thisdir=\`echo "\$0" | sed -e 's%/[^/]*\$%%'\`
+test "X\$0" = "X\$thisdir" && thisdir=.
+
+# Execute the libtool backend.
+. \$thisdir/$ltmain
+EOF3
+  ;;
+esac
+
+echo 'exit 1' >> $ofile
+
+chmod +x $ofile
+exit 0
+
+# Local Variables:
+# mode:shell-script
+# sh-indentation:2
+# End:
diff --git a/pppd/plugins/radius/radiusclient/ltmain.sh b/pppd/plugins/radius/radiusclient/ltmain.sh
new file mode 100644
index 0000000..cf2ef91
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/ltmain.sh
@@ -0,0 +1,1813 @@
+# ltmain.sh - Provide generalized library-building support services.
+# Generated automatically from ltmain.sh.in by configure.
+# Copyright (C) 1996, 1997 Free Software Foundation, Inc.
+# Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# The name of this program.
+progname=`echo "$0" | sed 's%^.*/%%'`
+
+# Constants.
+PROGRAM=ltmain.sh
+PACKAGE=libtool
+VERSION=1.0
+
+default_mode=
+help="Try \`$progname --help' for more information."
+magic="%%%MAGIC variable%%%"
+mkdir="mkdir"
+mv="mv -f"
+objdir=.libs
+rm="rm -f"
+
+if test "$LTCONFIG_VERSION" != "$VERSION"; then
+  echo "$progname: ltconfig version \`$LTCONFIG_VERSION' does not match $PROGRAM version \`$VERSION'" 1>&2
+  echo "Fatal configuration error.  See the $PACKAGE docs for more information." 1>&2
+  exit 1
+fi
+
+#
+if test "$build_libtool_libs" != yes && test "$build_old_libs" != yes; then
+  echo "$progname: not configured to build any kind of library" 1>&2
+  echo "Fatal configuration error.  See the $PACKAGE docs for more information." 1>&2
+  exit 1
+fi
+
+# Global variables.
+mode=$default_mode
+nonopt=
+prev=
+prevopt=
+run=
+show=echo
+show_help=
+
+# Parse our command line options once, thoroughly.
+while test $# -gt 0
+do
+  arg="$1"
+  shift
+
+  case "$arg" in
+  -*=*) optarg=`echo "$arg" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
+  *) optarg= ;;
+  esac
+
+  # If the previous option needs an argument, assign it.
+  if test -n "$prev"; then
+    eval "$prev=\$arg"
+    prev=
+    prevopt=
+    continue
+  fi
+
+  # Have we seen a non-optional argument yet?
+  case "$arg" in
+  --help)
+    show_help=yes
+    ;;
+
+  --version)
+    echo "$PROGRAM (GNU $PACKAGE) $VERSION"
+    exit 0
+    ;;
+
+  --dry-run | -n)
+    run=:
+    ;;
+
+  --features)
+    echo "host: $host"
+    if test "$build_libtool_libs" = yes; then
+      echo "enable shared libraries"
+    else
+      echo "disable shared libraries"
+    fi
+    if test "$build_old_libs" = yes; then
+      echo "enable static libraries"
+    else
+      echo "disable static libraries"
+    fi
+    exit 0
+    ;;
+
+  --finish) mode="finish" ;;
+
+  --mode) prevopt="--mode" prev=mode ;;
+  --mode=*) mode="$optarg" ;;
+
+  -*)
+    echo "$progname: unrecognized option \`$arg'" 1>&2
+    echo "$help" 1>&2
+    exit 1
+    ;;
+
+  *)
+    nonopt="$arg"
+    break
+    ;;
+  esac
+done
+
+
+if test -n "$prevopt"; then
+  echo "$progname: option \`$prevopt' requires an argument" 1>&2
+  echo "$help" 1>&2
+  exit 1
+fi
+
+
+if test -z "$show_help"; then
+
+  # Infer the operation mode.
+  if test -z "$mode"; then
+    case "$nonopt" in
+    *cc)
+      mode=link
+      for arg
+      do
+        case "$arg" in
+        -c)
+           mode=compile
+           break
+           ;;
+        esac
+      done
+      ;;
+    *install*|cp)
+      mode=install
+      ;;
+    *rm)
+      mode=uninstall
+      ;;
+    *.la)
+      mode=dlname
+      ;;
+    *)
+      # Just use the default operation mode.
+      if test -z "$mode"; then
+	if test -n "$nonopt"; then
+	  echo "$progname: warning: cannot infer operation mode from \`$nonopt'" 1>&2
+	else
+	  echo "$progname: warning: cannot infer operation mode without MODE-ARGS" 1>&2
+	fi
+      fi
+      ;;
+    esac
+  fi
+
+  # Change the help message to a mode-specific one.
+  generic_help="$help"
+  help="Try \`$progname --help --mode=$mode' for more information."
+
+  # These modes are in order of execution frequency so that they run quickly.
+  case "$mode" in
+  # libtool compile mode
+  compile)
+    progname="$progname: compile"
+    # Get the compilation command and the source file.
+    base_compile="$nonopt"
+    lastarg=
+    srcfile=
+
+    for arg
+    do
+      # Quote any args containing shell metacharacters.
+      case "$arg" in
+      *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*|*\"*)
+	 quote_arg="'$arg'" ;;
+      *) quote_arg="$arg" ;;
+      esac
+
+      base_compile="$base_compile$lastarg"
+      srcfile="$quote_arg"
+      lastarg=" $srcfile"
+    done
+
+    # Get the name of the library object.
+    libobj=`echo "$srcfile" | sed -e 's%^.*/%%'`
+
+    # Recognize several different file suffixes.
+    xform='[cCFSf]'
+    case "$libobj" in
+    *.c++) xform='c++' ;;
+    *.cc) xform=cc ;;
+    *.cpp) xform=cpp ;;
+    *.cxx) xform=cxx ;;
+    *.f90) xform=f90 ;;
+    *.for) xform='for' ;;
+    esac
+
+    libobj=`echo "$libobj" | sed -e "s/\.$xform$/.lo/"`
+
+    case "$libobj" in
+    *.lo) obj=`echo "$libobj" | sed -e 's/\.lo$/.o/'` ;;
+    *)
+      echo "$progname: cannot determine name of library object from \`$srcfile'" 1>&2
+      exit 1
+      ;;
+    esac
+
+    if test -z "$base_compile"; then
+      echo "$progname: you must specify a compilation command" 1>&2
+      echo "$help" 1>&2
+      exit 1
+    fi
+
+    # Delete any leftover library objects.
+    if test "$build_old_libs" = yes; then
+      $run $rm $obj $libobj
+      trap "$run $rm $obj $libobj; exit 1" 1 2 15
+    else
+      $run $rm $libobj
+      trap "$run $rm $libobj; exit 1" 1 2 15
+    fi
+
+    # Only build a PIC object if we are building libtool libraries.
+    if test "$build_libtool_libs" = yes; then
+      # All platforms use -DPIC, to notify preprocessed assembler code.
+      $show "$base_compile$pic_flag -DPIC $srcfile"
+      if $run eval "$base_compile$pic_flag -DPIC $srcfile"; then :
+      else
+	test -n "$obj" && $run $rm $obj
+	exit 1
+      fi
+
+      # If we have no pic_flag, then copy the object into place and finish.
+      if test -z "$pic_flag"; then
+	$show "$LN_S $obj $libobj"
+	$run $LN_S $obj $libobj
+	exit $?
+      fi
+
+      # Just move the object, then go on to compile the next one
+      $show "$mv $obj $libobj"
+      $run $mv $obj $libobj || exit 1
+    fi
+
+    # Only build a position-dependent object if we build old libraries.
+    if test "$build_old_libs" = yes; then
+      $show "$base_compile $srcfile"
+      if $run eval "$base_compile $srcfile"; then :
+      else
+        $run $rm $obj $libobj
+        exit 1
+      fi
+    fi
+
+    # Create an invalid libtool object if no PIC, so that we don't accidentally
+    # link it into a program.
+    if test "$build_libtool_libs" != yes; then
+      $show "echo timestamp > $libobj"
+      $run eval "echo timestamp > $libobj" || exit $?
+    fi
+
+    exit 0
+    ;;
+
+  # libtool link mode
+  link)
+    progname="$progname: link"
+    # Go through the arguments, transforming them on the way.
+    cc="$nonopt"
+    args="$cc"
+    allow_undefined=no
+    compile_command="$cc"
+    finalize_command="$cc"
+    compile_shlibpath=
+    finalize_shlibpath=
+    deplibs=
+    export_dynamic=no
+    hardcode_libdirs=
+    install_libdir=
+    libobjs=
+    link_against_libtool_libs=
+    link_static=
+    ltlibs=
+    objs=
+    prev=
+    prevarg=
+    perm_rpath=
+    temp_rpath=
+    vinfo=
+
+    # We need to know -static, to get the right output filenames.
+    for arg
+    do
+      case "$arg" in
+      -static)
+        build_libtool_libs=no
+        build_old_libs=yes
+        break
+        ;;
+      esac
+    done
+
+    for arg
+    do
+      # If the previous option needs an argument, assign it.
+      if test -n "$prev"; then
+	case "$prev" in
+	output)
+	  compile_command="$compile_command @OUTPUT@"
+	  finalize_command="$finalize_command @OUTPUT@"
+	  args="$args $arg"
+	  ;;
+	esac
+
+	eval "$prev=\$arg"
+	prev=
+
+	continue
+      fi
+
+      args="$args $arg"
+      prevarg="$arg"
+
+      case "$arg" in
+      -allow-undefined) allow_undefined=yes ;;
+
+      -export-dynamic)
+	export_dynamic=yes
+	compile_command="$compile_command $export_dynamic_flag"
+	finalize_command="$finalize_command $export_dynamic_flag"
+	continue
+	;;
+
+      -L*)
+	dir=`echo "$arg" | sed 's%^-L\(.*\)$%\1%'`
+	case "$dir" in
+	/*)
+	  ;;
+	*)
+	  echo "$progname: \`-L$dir' cannot specify a relative directory" 1>&2
+	  exit 1
+	  ;;
+	esac
+	deplibs="$deplibs $arg"
+	;;
+
+      -l*) deplibs="$deplibs $arg" ;;
+
+      -o) prev=output ;;
+
+      -rpath)
+	prev=install_libdir
+	continue
+	;;
+
+      -static)
+	link_static="`eval echo \"$link_static_flag\"`"
+	compile_command="$compile_command $link_static"
+	continue
+	;;
+
+      -version-file)
+	echo "$progname: \`-version-file' has been replaced by \`-version-info'" 1>&2
+	echo "$help" 1>&2
+	exit 1
+	;;
+
+      -version-info)
+	prev=vinfo
+	continue
+	;;
+
+      -*) cc="$cc $arg" ;; # Some other compiler flag.
+
+      *.o)
+	# A standard object.
+	objs="$objs $arg"
+	;;
+
+      *.a)
+	# Find the relevant object directory and library name.
+	file=`echo "$arg" | sed 's%^.*/%%'`
+	dir=`echo "$arg" | sed 's%/[^/]*$%/%'`
+	test "$dir" = "$arg" && dir=
+
+	# Standard archive.
+	objs="$objs $arg"
+	;;
+
+      *.lo)
+	# A library object.
+	libobjs="$libobjs $arg"
+	;;
+
+      *.la)
+	# A libtool-controlled library.
+
+	libdir=
+	library_names=
+	old_library=
+
+	# Check to see that this really is a libtool archive.
+	if egrep "^# Generated by $PROGRAM" $arg >/dev/null 2>&1; then :
+	else
+	  echo "$progname: \`$arg' is not a valid libtool archive" 1>&2
+	  exit 1
+	fi
+
+	# If there is no directory component, then add one.
+	case "$arg" in
+	*/*) . $arg ;;
+	*) . ./$arg ;;
+	esac
+
+	if test -z "$libdir"; then
+	  echo "$progname: \`$arg' contains no -rpath information" 1>&2
+	  exit 1
+	fi
+
+	# Get the name of the library we link against.
+	linklib=
+	for l in $old_library $library_names; do
+	  linklib="$l"
+	done
+
+	if test -z "$linklib"; then
+	  echo "$progname: cannot find name of link library for \`$arg'" 1>&2
+	  exit 1
+	fi
+
+	# Find the relevant object directory and library name.
+	name=`echo "$arg" | sed 's%^.*/%%; s/\.la$//; s/^lib//'`
+	dir=`echo "$arg" | sed 's%/[^/]*$%%'`
+	if test "$dir" = "$arg"; then
+	  dir="$objdir"
+	else
+	  dir="$dir/$objdir"
+	fi
+
+	if test "$build_libtool_libs" = yes && test -n "$library_names"; then
+	  link_against_libtool_libs="$link_against_libtool_libs $arg"
+	  if test -n "$shlibpath_var"; then
+	    # Make sure the rpath contains only unique directories.
+	    case "$temp_rpath " in
+	    "* $dir *") ;;
+	    *) temp_rpath="$temp_rpath $dir" ;;
+	    esac
+	  fi
+
+	  if test -n "$hardcode_libdir_flag_spec"; then
+	    if test -n "$hardcode_libdir_separator"; then
+	      if test -z "$hardcode_libdirs"; then
+		# Put the magic libdir with the hardcode flag.
+		hardcode_libdirs="$libdir"
+		libdir="@HARDCODE_LIBDIRS@"
+	      else
+		# Just accumulate the libdirs.
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		libdir=
+	      fi
+	    fi
+
+	    if test -n "$libdir"; then
+	      hardcode_libdir_flag=`eval echo \"$hardcode_libdir_flag_spec\"`
+	      compile_command="$compile_command $hardcode_libdir_flag"
+	      finalize_command="$finalize_command $hardcode_libdir_flag"
+	    fi
+	  elif test "$hardcode_runpath_var" = yes; then
+	    # Do the same for the permanent run path.
+	    case "$perm_rpath " in
+	    "* $libdir *") ;;
+	    *) perm_rpath="$perm_rpath $libdir" ;;
+	    esac
+	  fi
+
+
+	  case "$hardcode_action" in
+	  immediate)
+	    if test "$hardcode_direct" = no; then
+	      compile_command="$compile_command $dir/$linklib"
+	    elif test "$hardcode_minus_L" = no; then
+	      compile_command="$compile_command -L$dir -l$name"
+	    elif test "$hardcode_shlibpath_var" = no; then
+	      compile_shlibpath="$compile_shlibpath$dir:"
+	      compile_command="$compile_command -l$name"
+	    fi
+	    ;;
+
+	  relink)
+	    # We need an absolute path.
+	    case "$dir" in
+	    /*) ;;
+	    *)
+	      absdir=`cd "$dir" && pwd`
+	      if test -z "$absdir"; then
+		echo "$progname: cannot determine absolute directory name of \`$dir'" 1>&2
+		exit 1
+	      fi
+	      dir="$absdir"
+	      ;;
+	    esac
+
+	    if test "$hardcode_direct" = yes; then
+	      compile_command="$compile_command $dir/$linklib"
+	    elif test "$hardcode_minus_L" = yes; then
+	      compile_command="$compile_command -L$dir -l$name"
+	    elif test "$hardcode_shlibpath_var" = yes; then
+	      compile_shlibpath="$compile_shlibpath$dir:"
+	      compile_command="$compile_command -l$name"
+	    fi
+	    ;;
+
+	  *)
+	    echo "$progname: \`$hardcode_action' is an unknown hardcode action" 1>&2
+	    exit 1
+	    ;;
+	  esac
+
+	  # Finalize command for both is simple: just hardcode it.
+	  if test "$hardcode_direct" = yes; then
+	    finalize_command="$finalize_command $libdir/$linklib"
+	  elif test "$hardcode_minus_L" = yes; then
+	    finalize_command="$finalize_command -L$libdir -l$name"
+	  elif test "$hardcode_shlibpath_var" = yes; then
+	    finalize_shlibpath="$finalize_shlibpath$libdir:"
+	    finalize_command="$finalize_command -l$name"
+          else
+            # We can't seem to hardcode it, guess we'll fake it.
+	    finalize_command="$finalize_command -L$libdir -l$name"
+	  fi
+        else
+          # Transform directly to old archives if we don't build new libraries.
+          if test -n "$pic_flag" && test -z "$old_library"; then
+            echo "$progname: cannot find static library for \`$arg'" 1>&2
+	    exit 1
+	  fi
+	  test -n "$old_library" && linklib="$old_library"
+          compile_command="$compile_command $dir/$linklib"
+	  finalize_command="$finalize_command $dir/$linklib"
+        fi
+	continue
+	;;
+
+      *)
+        echo "$progname: unknown file suffix for \`$arg'" 1>&2
+	echo "$help" 1>&2
+	exit 1
+	;;
+      esac
+
+      compile_command="$compile_command $arg"
+      finalize_command="$finalize_command $arg"
+    done
+
+    if test -n "$prev"; then
+      echo "$progname: the \`$prevarg' option requires an argument" 1>&2
+      echo "$help" 1>&2
+      exit 1
+    fi
+
+    # Substitute the hardcoded libdirs into the compile commands.
+    if test "$hardcode_libdir_colon_separated" = yes; then
+      compile_command=`echo "$compile_command" | sed "s%@HARDCODE_LIBDIRS@%$hardcode_libdirs%g"`
+      finalize_command=`echo "$finalize_command" | sed "s%@HARDCODE_LIBDIRS@%$hardcode_libdirs%g"`
+    fi
+
+    oldlib=
+    oldobjs=
+    case "$output" in
+    "")
+      echo "$progname: you must specify an output file" 1>&2
+      echo "$help" 1>&2
+      exit 1
+      ;;
+
+    */*)
+      echo "$progname: output file \`$output' must have no directory components" 1>&2
+      exit 1
+      ;;
+
+    *.la)
+      libname=`echo "$output" | sed 's/\.la$//'`
+
+      # All the library-specific variables (install_libdir is set above).
+      library_names=
+      old_library=
+      dlname=
+      current=0
+      revision=0
+      age=0
+
+      if test -n "$objs"; then
+	echo "$progname: cannot build libtool library \`$output' from non-libtool objects:$objs" 2>&1
+	exit 1
+      fi
+
+      # How the heck are we supposed to write a wrapper for a shared library?
+      if test -n "$link_against_libtool_libs"; then
+        echo "$progname: libtool library \`$output' may not depend on uninstalled libraries:$link_against_libtool_libs" 1>&2
+	exit 1
+      fi
+
+      if test -z "$install_libdir"; then
+	echo "$progname: you must specify an installation directory with \`-rpath'" 1>&2
+	exit 1
+      fi
+
+      # Parse the version information argument.
+      IFS="${IFS= 	}"; save_ifs="$IFS"; IFS=':'
+      set dummy $vinfo
+      IFS="$save_ifs"
+
+      if test -n "$5"; then
+        echo "$progname: too many parameters to \`-version-info'" 1>&2
+	echo "$help" 1>&2
+	exit 1
+      fi
+
+      test -n "$2" && current="$2"
+      test -n "$3" && revision="$3"
+      test -n "$4" && age="$4"
+
+      # Check that each of the things are valid numbers.
+      case "$current" in
+      0 | [1-9] | [1-9][0-9]*) ;;
+      *)
+	echo "$progname: CURRENT \`$current' is not a nonnegative integer" 1>&2
+        echo "$progname: \`$vinfo' is not valid version information" 1>&2
+        exit 1
+	;;
+      esac
+
+      case "$revision" in
+      0 | [1-9] | [1-9][0-9]*) ;;
+      *)
+	echo "$progname: REVISION \`$revision' is not a nonnegative integer" 1>&2
+        echo "$progname: \`$vinfo' is not valid version information" 1>&2
+        exit 1
+	;;
+      esac
+
+      case "$age" in
+      0 | [1-9] | [1-9][0-9]*) ;;
+      *)
+	echo "$progname: AGE \`$age' is not a nonnegative integer" 1>&2
+        echo "$progname: \`$vinfo' is not valid version information" 1>&2
+        exit 1
+	;;
+      esac
+
+      if test $age -gt $current; then
+        echo "$progname: AGE \`$age' is greater than the current interface number \`$current'" 1>&2
+        echo "$progname: \`$vinfo' is not valid version information" 1>&2
+        exit 1
+      fi
+
+      # Calculate the version variables.
+      version_vars="version_type current age revision"
+      case "$version_type" in
+      none) ;;
+
+      linux)
+	version_vars="$version_vars major versuffix"
+	major=`expr $current - $age`
+	versuffix="$major.$age.$revision"
+	;;
+
+      osf)
+	version_vars="$version_vars versuffix verstring"
+	major=`expr $current - $age`
+	versuffix="$current.$age.$revision"
+	verstring="$versuffix"
+
+	# Add in all the interfaces that we are compatible with.
+	loop=$age
+	while test $loop != 0; do
+	  iface=`expr $current - $loop`
+	  loop=`expr $loop - 1`
+	  verstring="$verstring:${iface}.0"
+	done
+
+	# Make executables depend on our current version.
+	verstring="$verstring:${current}.0"
+	;;
+
+      sunos)
+	version_vars="$version_vars major versuffix"
+	major="$current"
+	versuffix="$current.$revision"
+	;;
+
+      *)
+	echo "$progname: unknown library version type \`$version_type'" 1>&2
+	echo "Fatal configuration error.  See the $PACKAGE docs for more information." 1>&2
+	exit 1
+	;;
+      esac
+
+      # Create the output directory, or remove our outputs if we need to.
+      if test -d $objdir; then
+        $show "$rm $objdir/$libname.*"
+        $run $rm $objdir/$libname.*
+      else
+        $show "$mkdir $objdir"
+	$run $mkdir $objdir || exit $?
+      fi
+
+      # Check to see if the archive will have undefined symbols.
+      if test "$allow_undefined" = yes; then
+	if test "$allow_undefined_flag" = unsupported; then
+	  echo "$progname: warning: undefined symbols not allowed in $host shared libraries" 1>&2
+	  build_libtool_libs=no
+	fi
+      else
+	# Clear the flag.
+	allow_undefined_flag=
+      fi
+
+      if test "$build_libtool_libs" = yes; then
+	# Get the real and link names of the library.
+	library_names=`eval echo \"$library_names_spec\"`
+	set dummy $library_names
+	realname="$2"
+	shift; shift
+
+	if test -n "$soname_spec"; then
+	  soname=`eval echo \"$soname_spec\"`
+	else
+	  soname="$realname"
+	fi
+
+	lib="$objdir/$realname"
+	linknames=
+	for link
+	do
+	  linknames="$linknames $link"
+	done
+
+	# Use standard objects if they are PIC.
+	test -z "$pic_flag" && libobjs=`echo "$libobjs " | sed 's/\.lo /.o /g; s/ $//g'`
+
+	# Do each of the archive commands.
+	cmds=`eval echo \"$archive_cmds\"`
+	IFS="${IFS= 	}"; save_ifs="$IFS"; IFS=';'
+	for cmd in $cmds; do
+	  IFS="$save_ifs"
+	  $show "$cmd"
+	  $run eval "$cmd" || exit $?
+	done
+	IFS="$save_ifs"
+
+	# Create links to the real library.
+	for link in $linknames; do
+	  $show "(cd $objdir && $LN_S $realname $link)"
+	  $run eval "(cd $objdir && $LN_S $realname $link)" || exit $?
+	done
+
+	# If -export-dynamic was specified, set the dlname.
+	if test "$export_dynamic" = yes; then
+	  # On all known operating systems, these are identical.
+	  dlname="$soname"
+	fi
+      fi
+      ;;
+
+    *.lo | *.o)
+      if test -n "$link_against_libtool_libs"; then
+	echo "$progname: error: cannot link libtool libraries into reloadable objects" 1>&2
+	exit 1
+      fi
+
+      if test -n "$deplibs"; then
+	echo "$progname: warning: \`-l' and \`-L' are ignored while creating objects" 1>&2
+      fi
+
+      if test -n "$install_libdir"; then
+        echo "$progname: warning: \`-rpath' is ignored while creating objects" 1>&2
+      fi
+
+      if test -n "$vinfo"; then
+	echo "$progname: warning: \`-version-info' is ignored while creating objects" 1>&2
+      fi
+
+      case "$output" in
+      *.lo)
+	if test -n "$objs"; then
+	  echo "$progname: cannot build library object \`$output' from non-libtool objects" 1>&2
+	  exit 1
+	fi
+	libobj="$output"
+	obj=`echo "$output" | sed 's/\.lo$/.o/'`
+	;;
+      *)
+        libobj=
+	obj="$output"
+	;;
+      esac
+
+      # Delete the old objects.
+      $run $rm $obj $libobj
+
+      # Create the old-style object.
+      reload_objs="$objs"`echo "$libobjs " | sed 's/[^ 	]*\.a //g; s/\.lo /.o /g; s/ $//g'`
+
+      output="$obj"
+      cmds=`eval echo \"$reload_cmds\"`
+      IFS="${IFS= 	}"; save_ifs="$IFS"; IFS=';'
+      for cmd in $cmds; do
+        IFS="$save_ifs"
+        $show "$cmd"
+	$run eval "$cmd" || exit $?
+      done
+      IFS="$save_ifs"
+
+      # Exit if we aren't doing a library object file.
+      test -z "$libobj" && exit 0
+
+      if test "$build_libtool_libs" != yes; then
+        # Create an invalid libtool object if no PIC, so that we don't
+        # accidentally link it into a program.
+	$show "echo timestamp > $libobj"
+	$run eval "echo timestamp > $libobj" || exit $?
+	exit 0
+      fi
+
+      if test -n "$pic_flag"; then
+	# Only do commands if we really have different PIC objects.
+	reload_objs="$libobjs"
+	output="$libobj"
+        cmds=`eval echo \"$reload_cmds\"`
+        IFS="${IFS= 	}"; save_ifs="$IFS"; IFS=';'
+        for cmd in $cmds; do
+          IFS="$save_ifs"
+          $show "$cmd"
+          $run eval "$cmd" || exit $?
+        done
+        IFS="$save_ifs"
+      else
+        # Just create a symlink.
+        $show "$LN_S $obj $libobj"
+        $run $LN_S $obj $libobj || exit 1
+      fi
+
+      exit 0
+      ;;
+
+    *)
+      if test -n "$install_libdir"; then
+        echo "$progname: warning: \`-rpath' is ignored while linking programs" 1>&2
+      fi
+
+      if test -n "$vinfo"; then
+	echo "$progname: warning: \`-version-info' is ignored while linking programs" 1>&2
+      fi
+
+      if test -n "$libobjs"; then
+	# Transform all the library objects into standard objects.
+	compile_command=`echo "$compile_command " | sed 's/\.lo /.o /g; s/ $//'`
+	finalize_command=`echo "$finalize_command " | sed 's/\.lo /.o /g; s/ $//'`
+      fi
+
+      if test -z "$link_against_libtool_libs" || test "$build_libtool_libs" != yes; then
+	# Replace the output file specification.
+	compile_command=`echo "$compile_command" | sed 's%@OUTPUT@%'"$output"'%g'`
+	finalize_command=`echo "$finalize_command" | sed 's%@OUTPUT@%'"$output"'%g'`
+
+	# We have no uninstalled library dependencies, so finalize right now.
+	$show "$compile_command"
+	$run $compile_command
+	status=$?
+
+	# If we failed to link statically, then try again.
+	if test $status -ne 0 && test -n "$link_static"; then
+	  echo "$progname: cannot link \`$output' statically; retrying semi-dynamically" 1>&2
+	  compile_command=`echo "$compile_command " | sed "s% $link_static % %;s/ $//"`
+	  $show "$finalize_command"
+	  $run $finalize_command
+	  status=$?
+	fi
+	exit $status
+      fi
+
+      # Replace the output file specification.
+      compile_command=`echo "$compile_command" | sed 's%@OUTPUT@%'"$objdir/$output"'%g'`
+      finalize_command=`echo "$finalize_command" | sed 's%@OUTPUT@%'"$objdir/$output"'T%g'`
+
+      # Create the binary in the object directory, then wrap it.
+      if test -d $objdir; then :
+      else
+        $show "$mkdir $objdir"
+        $run $mkdir $objdir || exit $?
+      fi
+
+      if test -n "$shlibpath_var"; then
+        # We should set the shlibpath_var
+	rpath=
+	for dir in $temp_rpath; do
+	  case "$dir" in
+	  /*)
+	    # Absolute path.
+	    rpath="$rpath$dir:"
+	    ;;
+	  *)
+	    # Relative path: add a thisdir entry.
+	    rpath="$rpath\$thisdir/$dir:"
+	    ;;
+	  esac
+	done
+	temp_rpath="$rpath"
+      fi
+
+      # Delete the old output file.
+      $run $rm $output
+
+      if test -n "$compile_shlibpath"; then
+	compile_command="$shlibpath_var=\"$compile_shlibpath\$$shlibpath_var\" $compile_command"
+      fi
+      if test -n "$finalize_shlibpath"; then
+	finalize_command="$shlibpath_var=\"$finalize_shlibpath\$$shlibpath_var\" $finalize_command"
+      fi
+
+      if test -n "$perm_rpath"; then
+	# We should set the runpath_var.
+	rpath=
+	for dir in $perm_rpath; do
+	  rpath="$rpath$dir:"
+	done
+	compile_command="$runpath_var=\"$rpath\$$runpath_var\" $compile_command"
+	finalize_command="$runpath_var=\"$rpath\$$runpath_var\" $finalize_command"
+      fi
+
+      case "$hardcode_action" in
+      relink)
+	# AGH! Flame the AIX and HP-UX people for me, will ya?
+	echo "$progname: warning: using a buggy system linker" 1>&2
+	echo "$progname: relinking will be required before \`$output' can be installed" 1>&2
+	;;
+      esac
+
+      $show "$compile_command"
+      $run eval "$compile_command" || exit $?
+
+      # Now create the wrapper script.
+      echo "creating $output"
+
+      # Only actually do things if our run command is non-null.
+      if test -z "$run"; then
+	$rm $output
+	trap "$rm $output; exit 1" 1 2 15
+
+	cat > $output <<EOF
+#! /bin/sh
+
+# $output - temporary wrapper script for $objdir/$output
+# Generated by $PROGRAM - GNU $PACKAGE $VERSION
+#
+# The $output program cannot be directly executed until all the libtool
+# libraries that it depends on are installed.
+#
+# This wrapper script should never be moved out of \``pwd`'.
+# If it is, it will not operate correctly.
+
+# This environment variable determines our operation mode.
+if test "\$libtool_install_magic" = "$magic"; then
+  # install mode needs the following variables:
+  link_against_libtool_libs='$link_against_libtool_libs'
+  finalize_command='$finalize_command'
+else
+  # Find the directory that this script lives in.
+  thisdir=\`echo \$0 | sed 's%/[^/]*$%%'\`
+  test "x\$thisdir" = "x\$0" && thisdir=.
+
+  # Try to get the absolute directory name.
+  absdir=\`cd "\$thisdir" && pwd\`
+  test -n "\$absdir" && thisdir="\$absdir"
+
+  progdir="\$thisdir/$objdir"
+  program="$output"
+
+  if test -f "\$progdir/\$program"; then
+    # Run the actual program with our arguments.
+    args=
+    for arg
+    do
+      # Quote arguments (to preserve shell metacharacters).
+      args="\$args '\$arg'"
+    done
+
+    # Export the path to the program.
+    PATH="\$progdir:\$PATH"
+    export PATH
+EOF
+
+	# Export our shlibpath_var if we have one.
+	if test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+	  cat >> $output <<EOF
+
+    # Add our own library path to $shlibpath_var
+    $shlibpath_var="$temp_rpath\$$shlibpath_var"
+
+    # Some systems cannot cope with colon-terminated $shlibpath_var
+    $shlibpath_var=\`echo \$$shlibpath_var | sed -e 's/:*\$//'\`
+
+    export $shlibpath_var
+EOF
+	fi
+
+        cat >> $output <<EOF
+
+    eval "exec \$program \$args"
+
+    echo "\$0: cannot exec \$program \$args"
+    exit 1
+  else
+    # The program doesn't exist.
+    echo "\$0: error: \$progdir/\$program does not exist" 1>&2
+    echo "This script is just a wrapper for \$program." 1>&2
+    echo "See the $PACKAGE documentation for more information." 1>&2
+    exit 1
+  fi
+fi
+EOF
+	chmod +x $output
+      fi
+      exit 0
+      ;;
+    esac
+
+
+    # See if we need to build an old-fashioned archive.
+    if test "$build_old_libs" = "yes"; then
+      # Now set the variables for building old libraries.
+      oldlib="$objdir/$libname.a"
+
+      # Transform .lo files to .o files.
+      oldobjs="$objs"`echo "$libobjs " | sed 's/[^ 	]*\.a //g; s/\.lo /.o /g; s/ $//g'`
+
+      if test -d "$objdir"; then
+	$show "$rm $oldlib"
+	$run $rm $oldlib
+      else
+	$show "$mkdir $objdir"
+	$run $mkdir $objdir
+      fi
+
+      # Do each command in the archive commands.
+      cmds=`eval echo \"$old_archive_cmds\"`
+      IFS="${IFS= 	}"; save_ifs="$IFS"; IFS=';'
+      for cmd in $cmds; do
+        IFS="$save_ifs"
+        $show "$cmd"
+	$run eval "$cmd" || exit $?
+      done
+      IFS="$save_ifs"
+    fi
+
+    # Now create the libtool archive.
+    case "$output" in
+    *.la)
+      old_library=
+      test "$build_old_libs" = yes && old_library="$libname.a"
+
+      echo "creating $output"
+
+      # Only create the output if not a dry run.
+      if test -z "$run"; then
+	cat > $output <<EOF
+# $output - a libtool library file
+# Generated by $PROGRAM - GNU $PACKAGE $VERSION
+
+# The name that we can dlopen(3).
+dlname='$dlname'
+
+# Names of this library.
+library_names='$library_names'
+
+# The name of the static archive.
+old_library='$old_library'
+
+# Version information for $libname.
+current=$current
+age=$age
+revision=$revision
+
+# Directory that this library needs to be installed in:
+libdir='$install_libdir'
+EOF
+      fi
+
+      # Do a symbolic link so that the libtool archive can be found in
+      # LD_LIBRARY_PATH before the program is installed.
+      $show "(cd $objdir && $LN_S ../$output $output)"
+      $run eval "(cd $objdir && $LN_S ../$output $output)" || exit 1
+      ;;
+    esac
+    exit 0
+    ;;
+
+  # libtool install mode
+  install)
+    progname="$progname: install"
+
+    # The first argument is the name of the installation program.
+    install_prog="$nonopt"
+
+    # We need to accept at least all the BSD install flags.
+    dest=
+    files=
+    opts=
+    prev=
+    install_type=
+    isdir=
+    stripme=
+    for arg
+    do
+      if test -n "$dest"; then
+        files="$files $dest"
+	dest="$arg"
+	continue
+      fi
+
+      case "$arg" in
+      -d) isdir=yes ;;
+      -f) prev="-f" ;;
+      -g) prev="-g" ;;
+      -m) prev="-m" ;;
+      -o) prev="-o" ;;
+      -s)
+	stripme=" -s"
+	continue
+	;;
+      -*) ;;
+
+      *)
+	# If the previous option needed an argument, then skip it.
+	if test -n "$prev"; then
+	  prev=
+	else
+	  dest="$arg"
+	  continue
+	fi
+        ;;
+      esac
+      install_prog="$install_prog $arg"
+    done
+
+    if test -z "$install_prog"; then
+      echo "$progname: you must specify an install program" 1>&2
+      echo "$help" 1>&2
+      exit 1
+    fi
+
+    if test -n "$prev"; then
+      echo "$progname: the \`$prev' option requires an argument" 1>&2
+      echo "$help" 1>&2
+      exit 1
+    fi
+
+    if test -z "$files"; then
+      if test -z "$dest"; then
+        echo "$progname: no file or destination specified" 1>&2
+      else
+	echo "$progname: you must specify a destination" 1>&2
+      fi
+      echo "$help" 1>&2
+      exit 1
+    fi
+
+    # Strip any trailing slash from the destination.
+    dest=`echo "$dest" | sed 's%/$%%'`
+
+    # Check to see that the destination is a directory.
+    test -d "$dest" && isdir=yes
+    if test -n "$isdir"; then
+      destdir="$dest"
+      destname=
+    else
+      destdir=`echo "$dest" | sed 's%/[^/]*$%%'`
+      test "$destdir" = "$dest" && destdir=.
+      destname=`echo "$dest" | sed 's%^.*/%%'`
+
+      # Not a directory, so check to see that there is only one file specified.
+      set dummy $files
+      if test $# -gt 2; then
+        echo "$progname: \`$dest' is not a directory" 1>&2
+        echo "$help" 1>&2
+	exit 1
+      fi
+    fi
+    case "$destdir" in
+    /*) ;;
+    *)
+      for file in $files; do
+	case "$file" in
+	*.lo) ;;
+	*)
+	  echo "$progname: \`$destdir' must be an absolute directory name" 1>&2
+	  echo "$help" 1>&2
+	  exit 1
+	  ;;
+	esac
+      done
+      ;;
+    esac
+
+    staticlibs=
+    future_libdirs=
+    current_libdirs=
+    for file in $files; do
+
+      # Do each installation.
+      case "$file" in
+      *.a)
+	# Do the static libraries later.
+	staticlibs="$staticlibs $file"
+	;;
+
+      *.la)
+	# Check to see that this really is a libtool archive.
+	if egrep "^# Generated by $PROGRAM" $file >/dev/null 2>&1; then :
+	else
+	  echo "$progname: \`$file' is not a valid libtool archive" 1>&2
+	  echo "$help" 1>&2
+	  exit 1
+	fi
+
+	library_names=
+	old_library=
+	# If there is no directory component, then add one.
+	case "$file" in
+	*/*) . $file ;;
+	*) . ./$file ;;
+	esac
+
+	# Add the libdir to current_libdirs if it is the destination.
+	if test "$destdir" = "$libdir"; then
+	  case "$current_libdirs " in
+	  "* $libdir *") ;;
+	  *) current_libdirs="$current_libdirs $libdir" ;;
+	  esac
+	else
+	  # Note the libdir as a future libdir.
+	  case "$future_libdirs " in
+	  "* $libdir *") ;;
+	  *) future_libdirs="$future_libdirs $libdir" ;;
+	  esac
+	fi
+
+	dir="`echo "$file" | sed 's%/[^/]*$%%'`/"
+	test "$dir" = "$file/" && dir=
+	dir="$dir$objdir"
+
+	# See the names of the shared library.
+	set dummy $library_names
+	if test -n "$2"; then
+	  realname="$2"
+	  shift
+	  shift
+
+	  # Install the shared library and build the symlinks.
+	  $show "$install_prog $dir/$realname $destdir/$realname"
+	  $run eval "$install_prog $dir/$realname $destdir/$realname" || exit $?
+	  test "X$dlname" = "X$realname" && dlname=
+
+	  # Support stripping libraries.
+	  if test -n "$stripme"; then
+	    if test -n "$striplib"; then
+	      $show "$striplib $destdir/$realname"
+	      $run $striplib $destdir/$realname || exit $?
+	    else
+	      echo "$progname: warning: no library stripping program" 1>&2
+	    fi
+	  fi
+
+	  if test $# -gt 0; then
+	    # Delete the old symlinks.
+            rmcmd="$rm"
+            for linkname
+            do
+              rmcmd="$rmcmd $destdir/$linkname"
+            done
+            $show "$rmcmd"
+            $run $rmcmd
+
+	    # ... and create new ones.
+	    for linkname
+	    do
+	      test "X$dlname" = "X$linkname" && dlname=
+	      $show "(cd $destdir && $LN_S $realname $linkname)"
+	      $run eval "(cd $destdir && $LN_S $realname $linkname)"
+	    done
+	  fi
+
+	  if test -n "$dlname"; then
+	    # Install the dynamically-loadable library.
+	    $show "$install_prog $dir/$dlname $destdir/$dlname"
+	    $run eval "$install_prog $dir/$dlname $destdir/$dlname" || exit $?
+	  fi
+
+	  # Do each command in the postinstall commands.
+	  lib="$destdir/$realname"
+	  cmds=`eval echo \"$postinstall_cmds\"`
+	  IFS="${IFS= 	}"; save_ifs="$IFS"; IFS=';'
+	  for cmd in $cmds; do
+	    IFS="$save_ifs"
+	    $show "$cmd"
+	    $run eval "$cmd" || exit $?
+	  done
+	  IFS="$save_ifs"
+	fi
+
+	# Install the pseudo-library for information purposes.
+	name=`echo "$file" | sed 's%^.*/%%'`
+	$show "$install_prog $file $destdir/$name"
+	$run $install_prog $file $destdir/$name || exit $?
+
+	# Maybe install the static library, too.
+	test -n "$old_library" && staticlibs="$staticlibs $dir/$old_library"
+	;;
+
+      *.lo)
+        # Install (i.e. copy) a libtool object.
+
+        # Figure out destination file name, if it wasn't already specified.
+        if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  destfile=`echo "$file" | sed 's%^.*/%%;'`
+	  destfile="$destdir/$destfile"
+        fi
+
+	# Deduce the name of the destination old-style object file.
+	case "$destfile" in
+	*.lo)
+	  staticdest=`echo "$destfile" | sed 's/\.lo$/\.o/;'`
+	  ;;
+	*.o)
+	  staticdest="$destfile"
+	  destfile=
+	  ;;
+	*)
+	  echo "$progname: cannot copy a libtool object to \`$destfile'" 1>&2
+	  echo "$help" 1>&2
+	  exit 1
+          ;;
+	esac
+
+	# Install the libtool object if requested.
+	if test -n "$destfile"; then
+	  $show "$install_prog $file $destfile"
+	  $run $install_prog $file $destfile || exit $?
+	fi
+
+	# Install the old object if enabled.
+	if test "$build_old_libs" = yes; then
+	  # Deduce the name of the old-style object file.
+	  staticobj=`echo "$file" | sed 's/\.lo$/\.o/;'`
+
+	  $show "$install_prog $staticobj $staticdest"
+	  $run $install_prog $staticobj $staticdest || exit $?
+	fi
+	exit 0
+	;;
+
+      *)
+	# Do a test to see if this is really a libtool program.
+	if egrep "^# Generated by $PROGRAM" $file >/dev/null 2>&1; then
+	  # This variable tells wrapper scripts just to set variables rather
+	  # than running their programs.
+	  libtool_install_magic="$magic"
+	  link_against_libtool_libs=
+	  finalize_command=
+
+	  # If there is no directory component, then add one.
+	  case "$file" in
+	  */*) . $file ;;
+	  *) . ./$file ;;
+	  esac
+
+	  # Check the variables that should have been set.
+	  if test -z "$link_against_libtool_libs" || test -z "$finalize_command"; then
+	    echo "$progname: invalid libtool wrapper script \`$file'" 1>&2
+	    exit 1
+	  fi
+
+	  finalize=yes
+	  for lib in $link_against_libtool_libs; do
+	    # Check to see that each library is installed.
+	    libdir=
+	    if test -f "$lib"; then
+	      # If there is no directory component, then add one.
+	      case "$lib" in
+	      */*) . $lib ;;
+	      *) . ./$lib ;;
+	      esac
+	    fi
+	    libfile="$libdir/`echo "$lib" | sed 's%^.*/%%g'`"
+	    if test -z "$libdir"; then
+	      echo "$progname: warning: \`$lib' contains no -rpath information" 1>&2
+	    elif test -f "$libfile"; then :
+	    else
+	      echo "$progname: warning: \`$lib' has not been installed in \`$libdir'" 1>&2
+	      finalize=no
+	    fi
+	  done
+
+	  if test "$hardcode_action" = relink; then
+	    if test "$finalize" = yes; then
+	      echo "$progname: warning: relinking \`$file' on behalf of your buggy system linker" 1>&2
+	      $show "$finalize_command"
+	      if $run $finalize_command; then :
+	      else
+		echo "$progname: error: relink \`$file' with the above command before installing it" 1>&2
+		continue
+	      fi
+	      file="$objdir/$file"T
+	    else
+	      echo "$progname: warning: cannot relink \`$file' on behalf of your buggy system linker" 1>&2
+	    fi
+	  else
+	    # Install the binary that we compiled earlier.
+	    dir=`echo "$file" | sed 's%/[^/]*$%%'`
+	    if test "$file" = "$dir"; then
+	      file="$objdir/$file"
+	    else
+	      file="$dir/$objdir/`echo "$file" | sed 's%^.*/%%'`"
+	    fi
+	  fi
+	fi
+
+	$show "$install_prog$stripme $file $dest"
+	$run $install_prog$stripme $file $dest || exit $?
+	;;
+      esac
+    done
+
+    for file in $staticlibs; do
+      name=`echo "$file" | sed 's%^.*/%%'`
+
+      # Set up the ranlib parameters.
+      oldlib="$destdir/$name"
+
+      $show "$install_prog $file $oldlib"
+      $run $install_prog $file $oldlib || exit $?
+
+      # Support stripping libraries.
+      if test -n "$stripme"; then
+	if test -n "$old_striplib"; then
+	  $show "$old_striplib $oldlib"
+	  $run $old_striplib $oldlib || exit $?
+	else
+	  echo "$progname: warning: no static library stripping program" 1>&2
+	fi
+      fi
+
+      # Do each command in the postinstall commands.
+      cmds=`eval echo \"$old_postinstall_cmds\"`
+      IFS="${IFS= 	}"; save_ifs="$IFS"; IFS=';'
+      for cmd in $cmds; do
+        IFS="$save_ifs"
+        $show "$cmd"
+        $run eval "$cmd" || exit $?
+      done
+      IFS="$save_ifs"
+    done
+
+    if test -n "$future_libdirs"; then
+      echo "$progname: warning: remember to run \`$progname --finish$future_libdirs'" 1>&2
+    fi
+
+    if test -n "$current_libdirs"; then
+      # Maybe just do a dry run.
+      test -n "$run" && current_libdirs=" -n$current_libdirs"
+      exec $0 --finish$current_libdirs
+      exit 1
+    fi
+
+    exit 0
+    ;;
+
+  # libtool dlname mode
+  dlname)
+    progname="$progname: dlname"
+    ltlibs="$nonopt"
+    for lib
+    do
+      ltlibs="$ltlibs $lib"
+    done
+
+    if test -z "$ltlibs"; then
+      echo "$progname: you must specify at least one LTLIBRARY" 1>&2
+      echo "$help" 1>&2
+      exit 1
+    fi
+
+    # Now check to make sure each one is a valid libtool library.
+    status=0
+    for lib in $ltlibs; do
+      dlname=
+      libdir=
+      library_names=
+
+      # Check to see that this really is a libtool archive.
+      if egrep "^# Generated by $PROGRAM" $arg >/dev/null 2>&1; then :
+      else
+        echo "$progname: \`$arg' is not a valid libtool archive" 1>&2
+	status=1
+	continue
+      fi
+
+      # If there is no directory component, then add one.
+      case "$arg" in
+      */*) . $arg ;;
+      *) . ./$arg ;;
+      esac
+
+      if test -z "$libdir"; then
+        echo "$progname: \`$arg' contains no -rpath information" 1>&2
+        status=1
+      elif test -n "$dlname"; then
+	echo "$libdir/$dlname"
+      elif test -z "$library_names"; then
+        echo "$progname: \`$arg' is not a shared library" 1>&2
+        status=1
+      else
+        echo "$progname: \`$arg' was not linked with \`-export-dynamic'" 1>&2
+        status=1
+      fi
+    done
+    exit $status
+    ;;
+
+  # libtool finish mode
+  finish)
+    progname="$progname: finish"
+    libdirs="$nonopt"
+
+    if test -n "$finish_cmds" && test -n "$libdirs"; then
+      for dir
+      do
+	libdirs="$libdirs $dir"
+      done
+
+      for libdir in $libdirs; do
+	# Do each command in the postinstall commands.
+	cmds=`eval echo \"$finish_cmds\"`
+	IFS="${IFS= 	}"; save_ifs="$IFS"; IFS=';'
+	for cmd in $cmds; do
+	  IFS="$save_ifs"
+	  $show "$cmd"
+	  $run eval "$cmd"
+	done
+	IFS="$save_ifs"
+      done
+    fi
+
+    echo "To link against installed libraries in LIBDIR, users may have to:"
+    if test -n "$shlibpath_var"; then
+      echo "   - add LIBDIR to their \`$shlibpath_var' environment variable"
+    fi
+    echo "   - use the \`-LLIBDIR' linker flag"
+    exit 0
+    ;;
+
+  # libtool uninstall mode
+  uninstall)
+    progname="$progname: uninstall"
+    rm="$nonopt"
+    files=
+
+    for arg
+    do
+      case "$arg" in
+      -*) rm="$rm $arg" ;;
+      *) files="$files $arg" ;;
+      esac
+    done
+
+    if test -z "$rm"; then
+      echo "$progname: you must specify an RM program" 1>&2
+      echo "$help" 1>&2
+      exit 1
+    fi
+
+    for file in $files; do
+      dir=`echo "$file" | sed -e 's%/[^/]*$%%'`
+      test "$dir" = "$file" && dir=.
+      name=`echo "$file" | sed -e 's%^.*/%%'`
+
+      rmfiles="$file"
+
+      case "$name" in
+      *.la)
+	# Possibly a libtool archive, so verify it.
+	if egrep "^# Generated by $PROGRAM" $file >/dev/null 2>&1; then
+	  . $dir/$name
+
+	  # Delete the libtool libraries and symlinks.
+	  for n in $library_names; do
+	    rmfiles="$rmfiles $dir/$n"
+	    test "X$n" = "X$dlname" && dlname=
+	  done
+	  test -n "$dlname" && rmfiles="$rmfiles $dir/$dlname"
+	  test -n "$old_library" && rmfiles="$rmfiles $dir/$old_library"
+
+	  # FIXME: should reinstall the best remaining shared library.
+	fi
+	;;
+
+      *.lo)
+	if test "$build_old_libs" = yes; then
+      	  oldobj=`echo "$name" | sed 's/\.lo$/\.o/'`
+	  rmfiles="$rmfiles $dir/$oldobj"
+	fi
+  	;;
+      esac
+
+      $show "$rm $rmfiles"
+      $run $rm $rmfiles
+    done
+    exit 0
+    ;;
+
+  NONE)
+    echo "$progname: you must specify a MODE" 1>&2
+    echo "$generic_help" 1>&2
+    exit 1
+    ;;
+  esac
+
+  echo "$progname: invalid operation mode \`$mode'" 1>&2
+  echo "$generic_help" 1>&2
+  exit 1
+fi # test -z "$show_help"
+
+# We need to display help for each of the modes.
+case "$mode" in
+NONE) cat <<EOF
+Usage: $progname [OPTION]... [MODE-ARG]...
+
+Provide generalized library-building support services.
+
+-n, --dry-run         display commands without modifying any files
+    --features        display configuration information and exit
+    --finish          same as \`--mode=finish'
+    --help            display this help message and exit
+    --mode=MODE       use operation mode MODE [default=inferred from MODE-ARGS]
+    --version         print version information
+
+MODE must be one of the following:
+
+      compile         compile a source file into a libtool object
+      dlname          print filenames to use to \`dlopen' libtool libraries
+      finish          complete the installation of libtool libraries
+      install         install libraries or executables
+      link            create a library or an executable
+      uninstall       remove libraries from an installed directory
+
+MODE-ARGS vary depending on the MODE.  Try \`$progname --help --mode=MODE' for
+a more detailed description of MODE.
+EOF
+  ;;
+
+compile)
+  cat <<EOF
+Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE
+
+Compile a source file into a libtool library object.
+
+COMPILE-COMMAND is a command to be used in creating a \`standard' object file
+from the given SOURCEFILE.
+
+The output file name is determined by removing the directory component from
+SOURCEFILE, then substituting the C source code suffix \`.c' with the
+library object suffix, \`.lo'.
+EOF
+  ;;
+
+dlname)
+  cat <<EOF
+Usage: $progname [OPTION]... --mode=dlname LTLIBRARY...
+
+Print filenames to use to \`dlopen' libtool libraries.
+
+Each LTLIBRARY is the name of a dynamically loadable libtool library (one that
+was linked using the \`-export-dynamic' option).
+
+The names to use are printed to standard output, one per line.
+EOF
+  ;;
+
+finish)
+  cat <<EOF
+Usage: $progname [OPTION]... --mode=finish [LIBDIR]...
+
+Complete the installation of libtool libraries.
+
+Each LIBDIR is a directory that contains libtool libraries.
+
+The commands that this mode executes may require superuser privileges.  Use
+the \`--dry-run' option if you just want to see what would be executed.
+EOF
+  ;;
+
+install)
+  cat <<EOF
+Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...
+
+Install executables or libraries.
+
+INSTALL-COMMAND is the installation command.  The first component should be
+either the \`install' or \`cp' program.
+
+The rest of the components are interpreted as arguments to that command (only
+BSD-compatible install options are recognized).
+EOF
+  ;;
+
+link)
+  cat <<EOF
+Usage: $progname [OPTION]... --mode=link LINK-COMMAND...
+
+Link object files or libraries together to form another library, or to
+create an executable program.
+
+LINK-COMMAND is a command using the C compiler that you would use to create
+a program from several object files.
+
+The following components of LINK-COMMAND are treated specially:
+
+  -allow-undefined  allow a libtool library to reference undefined symbols
+  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)
+  -LLIBDIR          search LIBDIR for required installed libraries
+  -lNAME            OUTPUT-FILE requires the installed library libNAME
+  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects
+  -rpath LIBDIR     the created library will eventually be installed in LIBDIR
+  -static           do not do any dynamic linking or shared library creation
+  -version-info CURRENT[:REVISION[:AGE]]
+		    specify library version info [each variable defaults to 0]
+
+All other options (arguments beginning with \`-') are ignored.
+
+Every other argument is treated as a filename.  Files ending in \`.la' are
+treated as uninstalled libtool libraries, other files are standard or library
+object files.
+
+If the OUTPUT-FILE ends in \`.la', then a libtool library is created, only
+library objects (\`.lo' files) may be specified, and \`-rpath' is required.
+
+If OUTPUT-FILE ends in \`.a', then a standard library is created using \`ar'
+and \`ranlib'.
+
+If OUTPUT-FILE ends in \`.lo' or \`.o', then a reloadable object file is
+created, otherwise an executable program is created.
+EOF
+  ;;
+
+uninstall)
+  cat <<EOF
+Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...
+
+Remove libraries from an installation directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, all the files associated with it are deleted.
+Otherwise, only FILE itself is deleted using RM.
+EOF
+  ;;
+
+*)
+  echo "$progname: invalid operation mode \`$mode'" 1>&2
+  echo "$help" 1>&2
+  exit 1
+  ;;
+esac
+
+case "$mode" in
+archive|compile)
+  echo
+  echo "Try \`$progname --help' for more information about other modes."
+  ;;
+esac
+
+exit 0
+
+# Local Variables:
+# mode:shell-script
+# sh-indentation:2
+# End:
diff --git a/pppd/plugins/radius/radiusclient/man/Makefile.am b/pppd/plugins/radius/radiusclient/man/Makefile.am
new file mode 100644
index 0000000..7138d04
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/man/Makefile.am
@@ -0,0 +1,13 @@
+#
+# $Id: Makefile.am,v 1.1 2002/01/22 16:03:02 dfs Exp $
+#
+# Copyright (C) 1995 Lars Fenneberg
+#
+# See the file COPYRIGHT for the respective terms and conditions. 
+# If the file is missing contact me at lf@elemental.net 
+# and I'll send you a copy.
+#
+
+AUTOMAKE_OPTIONS = foreign
+
+CLEANFILES = *~
diff --git a/pppd/plugins/radius/radiusclient/man/Makefile.in b/pppd/plugins/radius/radiusclient/man/Makefile.in
new file mode 100644
index 0000000..0081d99
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/man/Makefile.in
@@ -0,0 +1,185 @@
+# Makefile.in generated automatically by automake 1.3 from Makefile.am
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+#
+# $Id: Makefile.in,v 1.1 2002/01/22 16:03:02 dfs Exp $
+#
+# Copyright (C) 1995 Lars Fenneberg
+#
+# See the file COPYRIGHT for the respective terms and conditions. 
+# If the file is missing contact me at lf@elemental.net 
+# and I'll send you a copy.
+#
+
+
+SHELL = /bin/sh
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+sbindir = @sbindir@
+libexecdir = @libexecdir@
+datadir = @datadir@
+sysconfdir = @sysconfdir@
+sharedstatedir = @sharedstatedir@
+localstatedir = @localstatedir@
+libdir = @libdir@
+infodir = @infodir@
+mandir = @mandir@
+includedir = @includedir@
+oldincludedir = /usr/include
+
+DISTDIR =
+
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+
+top_builddir = ..
+
+ACLOCAL = @ACLOCAL@
+AUTOCONF = @AUTOCONF@
+AUTOMAKE = @AUTOMAKE@
+AUTOHEADER = @AUTOHEADER@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+transform = @program_transform_name@
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_alias = @build_alias@
+build_triplet = @build@
+host_alias = @host_alias@
+host_triplet = @host@
+target_alias = @target_alias@
+target_triplet = @target@
+AR = @AR@
+CC = @CC@
+LD = @LD@
+LIBTOOL = @LIBTOOL@
+LIBVERSION = @LIBVERSION@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+NM = @NM@
+PACKAGE = @PACKAGE@
+RANLIB = @RANLIB@
+RC_LOG_FACILITY = @RC_LOG_FACILITY@
+RC_SECURE_PATH = @RC_SECURE_PATH@
+VERSION = @VERSION@
+pkgsysconfdir = @pkgsysconfdir@
+
+AUTOMAKE_OPTIONS = foreign
+
+CLEANFILES = *~
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = ../config.h
+CONFIG_CLEAN_FILES = 
+DIST_COMMON =  Makefile.am Makefile.in
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = tar
+GZIP = --best
+all: Makefile
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && $(AUTOMAKE) --foreign --include-deps man/Makefile
+
+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+tags: TAGS
+TAGS:
+
+
+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
+
+subdir = man
+
+distdir: $(DISTFILES)
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  test -f $(distdir)/$$file \
+	  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	  || cp -p $$d/$$file $(distdir)/$$file; \
+	done
+info:
+dvi:
+check: all
+	$(MAKE)
+installcheck:
+install-exec: 
+	@$(NORMAL_INSTALL)
+
+install-data: 
+	@$(NORMAL_INSTALL)
+
+install: install-exec install-data all
+	@:
+
+uninstall: 
+
+install-strip:
+	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install
+installdirs:
+
+
+mostlyclean-generic:
+	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-rm -f Makefile $(DISTCLEANFILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+mostlyclean:  mostlyclean-generic
+
+clean:  clean-generic mostlyclean
+
+distclean:  distclean-generic clean
+	-rm -f config.status
+	-rm -f libtool
+
+maintainer-clean:  maintainer-clean-generic distclean
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+.PHONY: tags distdir info dvi installcheck install-exec install-data \
+install uninstall all installdirs mostlyclean-generic distclean-generic \
+clean-generic maintainer-clean-generic clean mostlyclean distclean \
+maintainer-clean
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/pppd/plugins/radius/radiusclient/missing b/pppd/plugins/radius/radiusclient/missing
new file mode 100755
index 0000000..a6abd06
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/missing
@@ -0,0 +1,134 @@
+#! /bin/sh
+# Common stub for a few missing GNU programs while installing.
+# Copyright (C) 1996, 1997 Free Software Foundation, Inc.
+# Franc,ois Pinard <pinard@iro.umontreal.ca>, 1996.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+# 02111-1307, USA.
+
+if test $# -eq 0; then
+  echo 1>&2 "Try \`$0 --help' for more information"
+  exit 1
+fi
+
+case "$1" in
+
+  -h|--h|--he|--hel|--help)
+    echo "\
+$0 [OPTION]... PROGRAM [ARGUMENT]...
+
+Handle \`PROGRAM [ARGUMENT]...' for when PROGRAM is missing, or return an
+error status if there is no known handling for PROGRAM.
+
+Options:
+  -h, --help      display this help and exit
+  -v, --version   output version information and exit
+
+Supported PROGRAM values:
+  aclocal      touch file \`aclocal.m4'
+  autoconf     touch file \`configure'
+  autoheader   touch file \`config.h.in'
+  automake     touch all \`Makefile.in' files
+  bison        touch file \`y.tab.c'
+  makeinfo     touch the output file
+  yacc         touch file \`y.tab.c'"
+    ;;
+
+  -v|--v|--ve|--ver|--vers|--versi|--versio|--version)
+    echo "missing - GNU libit 0.0"
+    ;;
+
+  -*)
+    echo 1>&2 "$0: Unknown \`$1' option"
+    echo 1>&2 "Try \`$0 --help' for more information"
+    exit 1
+    ;;
+
+  aclocal)
+    echo 1>&2 "\
+WARNING: \`$1' is missing on your system.  You should only need it if
+         you modified \`acinclude.m4' or \`configure.in'.  You might want
+         to install the \`Automake' and \`Perl' packages.  Grab them from
+         any GNU archive site."
+    touch aclocal.m4
+    ;;
+
+  autoconf)
+    echo 1>&2 "\
+WARNING: \`$1' is missing on your system.  You should only need it if
+         you modified \`configure.in'.  You might want to install the
+         \`Autoconf' and \`GNU m4' packages.  Grab them from any GNU
+         archive site."
+    touch configure
+    ;;
+
+  autoheader)
+    echo 1>&2 "\
+WARNING: \`$1' is missing on your system.  You should only need it if
+         you modified \`acconfig.h' or \`configure.in'.  You might want
+         to install the \`Autoconf' and \`GNU m4' packages.  Grab them
+         from any GNU archive site."
+    touch config.h.in
+    ;;
+
+  automake)
+    echo 1>&2 "\
+WARNING: \`$1' is missing on your system.  You should only need it if
+         you modified \`Makefile.am', \`acinclude.m4' or \`configure.in'.
+         You might want to install the \`Automake' and \`Perl' packages.
+         Grab them from any GNU archive site."
+    find . -type f -name Makefile.am -print \
+      | sed 's/^\(.*\).am$/touch \1.in/' \
+      | sh
+    ;;
+
+  bison|yacc)
+    echo 1>&2 "\
+WARNING: \`$1' is missing on your system.  You should only need it if
+         you modified a \`.y' file.  You may need the \`Bison' package
+         in order for those modifications to take effect.  You can get
+         \`Bison' from any GNU archive site."
+    touch y.tab.c
+    ;;
+
+  makeinfo)
+    echo 1>&2 "\
+WARNING: \`$1' is missing on your system.  You should only need it if
+         you modified a \`.texi' or \`.texinfo' file, or any other file
+         indirectly affecting the aspect of the manual.  The spurious
+         call might also be the consequence of using a buggy \`make' (AIX,
+         DU, IRIX).  You might want to install the \`Texinfo' package or
+         the \`GNU make' package.  Grab either from any GNU archive site."
+    file=`echo "$*" | sed -n 's/.*-o \([^ ]*\).*/\1/p'`
+    if test -z "$file"; then
+      file=`echo "$*" | sed 's/.* \([^ ]*\) *$/\1/'`
+      file=`sed -n '/^@setfilename/ { s/.* \([^ ]*\) *$/\1/; p; q; }' $file`
+    fi
+    touch $file
+    ;;
+
+  *)
+    echo 1>&2 "\
+WARNING: \`$1' is needed, and you do not seem to have it handy on your
+         system.  You might have modified some files without having the
+         proper tools for further handling them.  Check the \`README' file,
+         it often tells you about the needed prerequirements for installing
+         this package.  You may also peek at any GNU archive site, in case
+         some other package would contain this missing \`$1' program."
+    exit 1
+    ;;
+esac
+
+exit 0
diff --git a/pppd/plugins/radius/radiusclient/mkinstalldirs b/pppd/plugins/radius/radiusclient/mkinstalldirs
new file mode 100755
index 0000000..cc8783e
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/mkinstalldirs
@@ -0,0 +1,36 @@
+#! /bin/sh
+# mkinstalldirs --- make directory hierarchy
+# Author: Noah Friedman <friedman@prep.ai.mit.edu>
+# Created: 1993-05-16
+# Last modified: 1994-03-25
+# Public domain
+
+errstatus=0
+
+for file in ${1+"$@"} ; do 
+   set fnord `echo ":$file" | sed -ne 's/^:\//#/;s/^://;s/\// /g;s/^#/\//;p'`
+   shift
+
+   pathcomp=
+   for d in ${1+"$@"} ; do
+     pathcomp="$pathcomp$d"
+     case "$pathcomp" in
+       -* ) pathcomp=./$pathcomp ;;
+     esac
+
+     if test ! -d "$pathcomp"; then
+        echo "mkdir $pathcomp" 1>&2
+        mkdir "$pathcomp" > /dev/null 2>&1 || lasterr=$?
+     fi
+
+     if test ! -d "$pathcomp"; then
+	errstatus=$lasterr
+     fi
+
+     pathcomp="$pathcomp/"
+   done
+done
+
+exit $errstatus
+
+# mkinstalldirs ends here
diff --git a/pppd/plugins/radius/radiusclient/patches/Makefile.am b/pppd/plugins/radius/radiusclient/patches/Makefile.am
new file mode 100644
index 0000000..194646a
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/patches/Makefile.am
@@ -0,0 +1,16 @@
+#
+# $Id: Makefile.am,v 1.1 2002/01/22 16:03:03 dfs Exp $
+#
+# Copyright (C) 1997 Lars Fenneberg
+#
+# See the file COPYRIGHT for the respective terms and conditions. 
+# If the file is missing contact me at lf@elemental.net 
+# and I'll send you a copy.
+#
+
+AUTOMAKE_OPTIONS = foreign
+
+CLEANFILES = *~
+
+EXTRA_DIST = README merit-2.4.21-CHAP.diff radiusd-1.16.shadow.diff \
+	radiusd-1.16.accounting.diff
diff --git a/pppd/plugins/radius/radiusclient/patches/Makefile.in b/pppd/plugins/radius/radiusclient/patches/Makefile.in
new file mode 100644
index 0000000..3a7b55c
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/patches/Makefile.in
@@ -0,0 +1,188 @@
+# Makefile.in generated automatically by automake 1.3 from Makefile.am
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+#
+# $Id: Makefile.in,v 1.1 2002/01/22 16:03:03 dfs Exp $
+#
+# Copyright (C) 1997 Lars Fenneberg
+#
+# See the file COPYRIGHT for the respective terms and conditions. 
+# If the file is missing contact me at lf@elemental.net 
+# and I'll send you a copy.
+#
+
+
+SHELL = /bin/sh
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+sbindir = @sbindir@
+libexecdir = @libexecdir@
+datadir = @datadir@
+sysconfdir = @sysconfdir@
+sharedstatedir = @sharedstatedir@
+localstatedir = @localstatedir@
+libdir = @libdir@
+infodir = @infodir@
+mandir = @mandir@
+includedir = @includedir@
+oldincludedir = /usr/include
+
+DISTDIR =
+
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+
+top_builddir = ..
+
+ACLOCAL = @ACLOCAL@
+AUTOCONF = @AUTOCONF@
+AUTOMAKE = @AUTOMAKE@
+AUTOHEADER = @AUTOHEADER@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+transform = @program_transform_name@
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_alias = @build_alias@
+build_triplet = @build@
+host_alias = @host_alias@
+host_triplet = @host@
+target_alias = @target_alias@
+target_triplet = @target@
+AR = @AR@
+CC = @CC@
+LD = @LD@
+LIBTOOL = @LIBTOOL@
+LIBVERSION = @LIBVERSION@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+NM = @NM@
+PACKAGE = @PACKAGE@
+RANLIB = @RANLIB@
+RC_LOG_FACILITY = @RC_LOG_FACILITY@
+RC_SECURE_PATH = @RC_SECURE_PATH@
+VERSION = @VERSION@
+pkgsysconfdir = @pkgsysconfdir@
+
+AUTOMAKE_OPTIONS = foreign
+
+CLEANFILES = *~
+
+EXTRA_DIST = README merit-2.4.21-CHAP.diff radiusd-1.16.shadow.diff \
+	radiusd-1.16.accounting.diff
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = ../config.h
+CONFIG_CLEAN_FILES = 
+DIST_COMMON =  README Makefile.am Makefile.in
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = tar
+GZIP = --best
+all: Makefile
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && $(AUTOMAKE) --foreign --include-deps patches/Makefile
+
+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+tags: TAGS
+TAGS:
+
+
+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
+
+subdir = patches
+
+distdir: $(DISTFILES)
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  test -f $(distdir)/$$file \
+	  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	  || cp -p $$d/$$file $(distdir)/$$file; \
+	done
+info:
+dvi:
+check: all
+	$(MAKE)
+installcheck:
+install-exec: 
+	@$(NORMAL_INSTALL)
+
+install-data: 
+	@$(NORMAL_INSTALL)
+
+install: install-exec install-data all
+	@:
+
+uninstall: 
+
+install-strip:
+	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install
+installdirs:
+
+
+mostlyclean-generic:
+	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-rm -f Makefile $(DISTCLEANFILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+mostlyclean:  mostlyclean-generic
+
+clean:  clean-generic mostlyclean
+
+distclean:  distclean-generic clean
+	-rm -f config.status
+	-rm -f libtool
+
+maintainer-clean:  maintainer-clean-generic distclean
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+.PHONY: tags distdir info dvi installcheck install-exec install-data \
+install uninstall all installdirs mostlyclean-generic distclean-generic \
+clean-generic maintainer-clean-generic clean mostlyclean distclean \
+maintainer-clean
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/pppd/plugins/radius/radiusclient/patches/README b/pppd/plugins/radius/radiusclient/patches/README
new file mode 100644
index 0000000..891086b
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/patches/README
@@ -0,0 +1,31 @@
+$Id: README,v 1.1 2002/01/22 16:03:03 dfs Exp $
+
+ppp-2.2.0f-radclient.diff
+
+	NOW LONGER INCLUDED. For pppd patches see:
+
+	http://www.gams.net/~mla/radius.html
+        http://www.iphil.net/~map/radius/
+        http://linux.slovenija.net/radius/
+
+merit-2.4.21-CHAP.diff
+
+	Patch to the Merit radiusd 2.4.21 to support the CHAP-Challenge
+	attribute.  Doesn't work with earlier version of Merit radiusd. I sent
+	this patch to Merit, so hopefully it'll be included in the next release.
+	Apply this patch from the "src" directory of the radiusd sources.
+
+radiusd-1.16.shadow.diff
+
+	Patch to the original radiusd by Livingston to recognize "*"
+	as a special password to look for shadow passwords.
+	Apply this patch from the "src" directory of the radiusd sources.
+
+
+radiusd-1.16.accounting.diff
+
+	The patch for Livingston's (now Lucent's) radiusd 1.16 fixes the
+	accounting reply digest bug. When you've applied this patch to your
+	RADIUS server you no longer need to compile radiusclient with
+	--enable-radius-116. This patch was contributed by Tilman
+	Mueller-Gerbes <tmg@suse.de>. Thanks, Tilman!
diff --git a/pppd/plugins/radius/radiusclient/patches/merit-2.4.21-CHAP.diff b/pppd/plugins/radius/radiusclient/patches/merit-2.4.21-CHAP.diff
new file mode 100644
index 0000000..f6562a3
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/patches/merit-2.4.21-CHAP.diff
@@ -0,0 +1,41 @@
+--- funcs.c.dist	Mon May 13 00:37:37 1996
++++ funcs.c	Mon May 13 00:58:33 1996
+@@ -830,11 +830,12 @@
+ 				/* reply.*/
+ 
+ {
+-	VALUE_PAIR     *item;
++	VALUE_PAIR     *item, *chall;
+ 	u_char          buffer[AUTH_PASS_LEN + AUTH_VECTOR_LEN + 1];
+ 	int             i;
+ 	int             secretlen;
+ 	int             result;
++	int		chall_len;
+ 	u_char          digest[CHAP_VALUE_LENGTH];
+ 	u_char         *ptr;
+ 	char           *crypt ();
+@@ -896,10 +897,21 @@
+ 
+ 		secretlen = strlen ((char *) ptr);
+ 		ptr += secretlen;
+-		memcpy ((char *) ptr, (char *) authreq->vector,
+-			AUTH_VECTOR_LEN);
++
++		/* this uses CHAP-Challenge as the challenge if it exists */
++		/* lf, 5/13/96 */
++		if ((chall = get_vp (authreq->request, PW_CHAP_CHALLENGE))
++			!= (VALUE_PAIR *) NULL) {
++			memcpy ((char *) ptr, chall->strvalue, chall->lvalue);	
++			chall_len = chall->lvalue;
++		} else {
++			memcpy ((char *) ptr, (char *) authreq->vector,
++				AUTH_VECTOR_LEN);
++			chall_len = AUTH_VECTOR_LEN;
++		}	
++		
+ 		md5_calc (digest, buffer,
+-			  1 + CHAP_VALUE_LENGTH + secretlen);
++			  1 + chall_len + secretlen);
+ 		/* Compare them */
+ 		if ((result = memcmp ((char *) digest, item->strvalue + 1,
+ 				      CHAP_VALUE_LENGTH)) != 0)
diff --git a/pppd/plugins/radius/radiusclient/patches/radiusd-1.16.accounting.diff b/pppd/plugins/radius/radiusclient/patches/radiusd-1.16.accounting.diff
new file mode 100644
index 0000000..feda35c
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/patches/radiusd-1.16.accounting.diff
@@ -0,0 +1,82 @@
+Message-ID: <19980211151522.51612@Galerkin.fs100.suse.de>
+Date: Wed, 11 Feb 1998 15:15:22 +0100
+From: Tilman Mueller-Gerbes <tmg@suse.de>
+To: Lars Fenneberg <lf@elemental.net>
+Subject: Re: Radiusclient-0.3-alpha
+
+Hi!
+
+Das mit der spec-Datei dauert noch ein bisschen, allerdings habe
+ich einen Bug-Fix fuer den Radiusd, d.h. dein Problem mit
+den Radius-Accounting-Requests geloest:
+
+Es ist so, dass bei Radius-Accounting Requests im Response-MD5-Digest
+der radiusd 1.16 schlicht und einfach das secret nicht mit
+einrechnet. Das secret wird mehr oder weniger zufaellig gesetzt
+(d.h. gar nicht erst initialisiert :(.
+
+Ich habe einen Patch fuer den Radiusd 1.16.1 (unten angehaengt).
+
+Der Radiusd Berechnet die Digests bei Accounting Requests nicht -
+ob das so i.O. ist sei mal dahingestellt, andere Implementationen
+werden es wohl auch nicht tun.
+
+
+****
+
+--- src/Makefile
++++ src/Makefile	1998/02/11 14:09:51
+@@ -14,7 +14,7 @@
+ # unixware: add -Dunixware to CFLAGS, use LIBS= -lucb -lnsl -lsocket
+ #
+ SRCDIR=.
+-CFLAGS= -O -DNOSHADOW
++CFLAGS= -O -DFIX_ACCOUNTING_BUG
+ LDFLAGS=
+ CC=	cc
+ LIBS=
+--- src/acct.c
++++ src/acct.c	1998/02/11 14:09:10
+@@ -70,6 +70,31 @@
+ 	char		buffer[512];
+ 	VALUE_PAIR	*pair;
+ 	long		curtime;
++	char		pw_digest[16];
++	/*
++	 * fix accounting bug: when receiving an accounting request
++	 * the digest is not checked at all and a wrong
++	 * reply digest is calculated, as authreq->secret is not
++	 * initialized
++	 * this fix should not break any existing code, as the
++	 * reply digest was random anyway (and may be never checked
++	 * by anyone) -tmg@suse.de-
++	 */
++#if defined(FIX_ACCOUNTING_BUG)
++	/* Verify the client and Calculate the MD5 Password Digest */
++	if(calc_digest(pw_digest, authreq) != 0) {
++	        char		msg[512];
++		/* We dont respond when this fails */
++		sprintf(msg, "Authenticate: from %s - Security Breach Accounting\n",
++			ip_hostname(authreq->ipaddr));
++		msg[127] = '\0';
++		log_err(msg);
++		pairfree(authreq->request);
++		memset(authreq, 0, sizeof(AUTH_REQ));
++		free(authreq);
++		return;
++	}
++#endif
+ 
+ 	strncpy(clientname, ip_hostname(authreq->ipaddr), 128);
+ 	clientname[127] = '\0';
+
+
+
+
+-- 
+  Tilman Mueller-Gerbes, S.u.S.E. GmbH, Gebhardtstr. 2, 90762 Fuerth, Germany
+  Tel: +49-911-7405330,       Fax: +49-911-7417755,      Email: tmg@suse.de
++-------------------------------------------------------------------------+
+| S.u.S.E. auf der CeBIT '98!  --  Besuchen Sie uns in Halle 5, Stand A61 |
++-------------------------------------------------------------------------+
+
diff --git a/pppd/plugins/radius/radiusclient/patches/radiusd-1.16.shadow.diff b/pppd/plugins/radius/radiusclient/patches/radiusd-1.16.shadow.diff
new file mode 100644
index 0000000..ff2c162
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/patches/radiusd-1.16.shadow.diff
@@ -0,0 +1,12 @@
+--- radiusd.c~	Fri Jan  6 22:58:16 1995
++++ radiusd.c	Thu Apr  4 22:43:31 1996
+@@ -1426,7 +1426,8 @@
+ 	encrypted_pass = pwd->pw_passwd;
+ 
+ #if !defined(NOSHADOW)
+-	if(strcmp(pwd->pw_passwd, "x") == 0) {
++	if ((strcmp(pwd->pw_passwd, "x") == 0) ||
++	    (strcmp(pwd->pw_passwd, "*") == 0)) {
+ 		if((spwd = getspnam(name)) == NULL) {
+ 			return(-1);
+ 		}
diff --git a/pppd/plugins/radius/radiusclient/src/Makefile.am b/pppd/plugins/radius/radiusclient/src/Makefile.am
new file mode 100644
index 0000000..e89759f
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/src/Makefile.am
@@ -0,0 +1,28 @@
+#
+# $Id: Makefile.am,v 1.1 2002/01/22 16:03:04 dfs Exp $
+#
+# Copyright (C) 1995,1997,1998 Lars Fenneberg
+#
+# See the file COPYRIGHT for the respective terms and conditions. 
+# If the file is missing contact me at lf@elemental.net 
+# and I'll send you a copy.
+#
+
+AUTOMAKE_OPTIONS = foreign
+
+pkgsysconfdir=@pkgsysconfdir@
+
+DEFS = @DEFS@ -DRC_CONFIG_FILE=\"${pkgsysconfdir}/radiusclient.conf\" \
+	      -DRC_SECURE_PATH=\"@RC_SECURE_PATH@\"
+INCLUDES = -I$(srcdir) -I$(top_srcdir)/include -I$(top_builddir)
+LDADD = ../lib/libradiusclient.la
+
+CLEANFILES = *~
+
+noinst_HEADERS = radlogin.h
+
+sbin_PROGRAMS = radlogin radstatus radacct radexample
+radlogin_SOURCES = radlogin.c radius.c local.c
+radacct_SOURCES = radacct.c
+radstatus_SOURCES = radstatus.c
+radexample_SOURCES = radexample.c
diff --git a/pppd/plugins/radius/radiusclient/src/Makefile.in b/pppd/plugins/radius/radiusclient/src/Makefile.in
new file mode 100644
index 0000000..0ebcc6c
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/src/Makefile.in
@@ -0,0 +1,361 @@
+# Makefile.in generated automatically by automake 1.3 from Makefile.am
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+#
+# $Id: Makefile.in,v 1.1 2002/01/22 16:03:04 dfs Exp $
+#
+# Copyright (C) 1995,1997,1998 Lars Fenneberg
+#
+# See the file COPYRIGHT for the respective terms and conditions. 
+# If the file is missing contact me at lf@elemental.net 
+# and I'll send you a copy.
+#
+
+
+SHELL = /bin/sh
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+sbindir = @sbindir@
+libexecdir = @libexecdir@
+datadir = @datadir@
+sysconfdir = @sysconfdir@
+sharedstatedir = @sharedstatedir@
+localstatedir = @localstatedir@
+libdir = @libdir@
+infodir = @infodir@
+mandir = @mandir@
+includedir = @includedir@
+oldincludedir = /usr/include
+
+DISTDIR =
+
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+
+top_builddir = ..
+
+ACLOCAL = @ACLOCAL@
+AUTOCONF = @AUTOCONF@
+AUTOMAKE = @AUTOMAKE@
+AUTOHEADER = @AUTOHEADER@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+transform = @program_transform_name@
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_alias = @build_alias@
+build_triplet = @build@
+host_alias = @host_alias@
+host_triplet = @host@
+target_alias = @target_alias@
+target_triplet = @target@
+AR = @AR@
+CC = @CC@
+LD = @LD@
+LIBTOOL = @LIBTOOL@
+LIBVERSION = @LIBVERSION@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+NM = @NM@
+PACKAGE = @PACKAGE@
+RANLIB = @RANLIB@
+RC_LOG_FACILITY = @RC_LOG_FACILITY@
+RC_SECURE_PATH = @RC_SECURE_PATH@
+VERSION = @VERSION@
+
+AUTOMAKE_OPTIONS = foreign
+
+pkgsysconfdir=@pkgsysconfdir@
+
+DEFS = @DEFS@ -DRC_CONFIG_FILE=\"${pkgsysconfdir}/radiusclient.conf\" \
+	      -DRC_SECURE_PATH=\"@RC_SECURE_PATH@\"
+INCLUDES = -I$(srcdir) -I$(top_srcdir)/include -I$(top_builddir)
+LDADD = ../lib/libradiusclient.la
+
+CLEANFILES = *~
+
+noinst_HEADERS = radlogin.h
+
+sbin_PROGRAMS = radlogin radstatus radacct radexample
+radlogin_SOURCES = radlogin.c radius.c local.c
+radacct_SOURCES = radacct.c
+radstatus_SOURCES = radstatus.c
+radexample_SOURCES = radexample.c
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = ../config.h
+CONFIG_CLEAN_FILES = 
+PROGRAMS =  $(sbin_PROGRAMS)
+
+CPPFLAGS = @CPPFLAGS@
+LDFLAGS = @LDFLAGS@
+LIBS = @LIBS@
+radlogin_OBJECTS =  radlogin.o radius.o local.o
+radlogin_LDADD = $(LDADD)
+radlogin_DEPENDENCIES =  ../lib/libradiusclient.la
+radlogin_LDFLAGS = 
+radstatus_OBJECTS =  radstatus.o
+radstatus_LDADD = $(LDADD)
+radstatus_DEPENDENCIES =  ../lib/libradiusclient.la
+radstatus_LDFLAGS = 
+radacct_OBJECTS =  radacct.o
+radacct_LDADD = $(LDADD)
+radacct_DEPENDENCIES =  ../lib/libradiusclient.la
+radacct_LDFLAGS = 
+radexample_OBJECTS =  radexample.o
+radexample_LDADD = $(LDADD)
+radexample_DEPENDENCIES =  ../lib/libradiusclient.la
+radexample_LDFLAGS = 
+CFLAGS = @CFLAGS@
+COMPILE = $(CC) $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)
+LINK = $(LIBTOOL) --mode=link $(CC) $(CFLAGS) $(LDFLAGS) -o $@
+HEADERS =  $(noinst_HEADERS)
+
+DIST_COMMON =  Makefile.am Makefile.in
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = tar
+GZIP = --best
+SOURCES = $(radlogin_SOURCES) $(radstatus_SOURCES) $(radacct_SOURCES) $(radexample_SOURCES)
+OBJECTS = $(radlogin_OBJECTS) $(radstatus_OBJECTS) $(radacct_OBJECTS) $(radexample_OBJECTS)
+
+all: Makefile $(PROGRAMS) $(HEADERS)
+
+.SUFFIXES:
+.SUFFIXES: .S .c .lo .o .s
+$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && $(AUTOMAKE) --foreign --include-deps src/Makefile
+
+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+
+mostlyclean-sbinPROGRAMS:
+
+clean-sbinPROGRAMS:
+	-test -z "$(sbin_PROGRAMS)" || rm -f $(sbin_PROGRAMS)
+
+distclean-sbinPROGRAMS:
+
+maintainer-clean-sbinPROGRAMS:
+
+install-sbinPROGRAMS: $(sbin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(sbindir)
+	@list='$(sbin_PROGRAMS)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    echo " $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(DESTDIR)$(sbindir)/`echo $$p|sed '$(transform)'`"; \
+	    $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p $(DESTDIR)$(sbindir)/`echo $$p|sed '$(transform)'`; \
+	  else :; fi; \
+	done
+
+uninstall-sbinPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	list='$(sbin_PROGRAMS)'; for p in $$list; do \
+	  rm -f $(DESTDIR)$(sbindir)/`echo $$p|sed '$(transform)'`; \
+	done
+
+.c.o:
+	$(COMPILE) -c $<
+
+.s.o:
+	$(COMPILE) -c $<
+
+.S.o:
+	$(COMPILE) -c $<
+
+mostlyclean-compile:
+	-rm -f *.o core *.core
+
+clean-compile:
+
+distclean-compile:
+	-rm -f *.tab.c
+
+maintainer-clean-compile:
+
+.c.lo:
+	$(LIBTOOL) --mode=compile $(COMPILE) -c $<
+
+.s.lo:
+	$(LIBTOOL) --mode=compile $(COMPILE) -c $<
+
+.S.lo:
+	$(LIBTOOL) --mode=compile $(COMPILE) -c $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+
+maintainer-clean-libtool:
+
+radlogin: $(radlogin_OBJECTS) $(radlogin_DEPENDENCIES)
+	@rm -f radlogin
+	$(LINK) $(radlogin_LDFLAGS) $(radlogin_OBJECTS) $(radlogin_LDADD) $(LIBS)
+
+radstatus: $(radstatus_OBJECTS) $(radstatus_DEPENDENCIES)
+	@rm -f radstatus
+	$(LINK) $(radstatus_LDFLAGS) $(radstatus_OBJECTS) $(radstatus_LDADD) $(LIBS)
+
+radacct: $(radacct_OBJECTS) $(radacct_DEPENDENCIES)
+	@rm -f radacct
+	$(LINK) $(radacct_LDFLAGS) $(radacct_OBJECTS) $(radacct_LDADD) $(LIBS)
+
+radexample: $(radexample_OBJECTS) $(radexample_DEPENDENCIES)
+	@rm -f radexample
+	$(LINK) $(radexample_LDFLAGS) $(radexample_OBJECTS) $(radexample_LDADD) $(LIBS)
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP)
+	here=`pwd` && cd $(srcdir) \
+	  && mkid -f$$here/ID $(SOURCES) $(HEADERS) $(LISP)
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$unique$(LISP)$$tags" \
+	  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $$unique $(LISP) -o $$here/TAGS)
+
+mostlyclean-tags:
+
+clean-tags:
+
+distclean-tags:
+	-rm -f TAGS ID
+
+maintainer-clean-tags:
+
+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
+
+subdir = src
+
+distdir: $(DISTFILES)
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  test -f $(distdir)/$$file \
+	  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	  || cp -p $$d/$$file $(distdir)/$$file; \
+	done
+local.o: local.c ../config.h ../include/includes.h \
+	../include/radiusclient.h ../include/messages.h radlogin.h
+radacct.o: radacct.c ../config.h ../include/includes.h \
+	../include/radiusclient.h ../include/messages.h \
+	../include/pathnames.h
+radexample.o: radexample.c ../config.h ../include/includes.h \
+	../include/radiusclient.h ../include/pathnames.h
+radius.o: radius.c ../config.h ../include/includes.h \
+	../include/radiusclient.h ../include/messages.h radlogin.h
+radlogin.o: radlogin.c ../config.h ../include/includes.h \
+	../include/radiusclient.h ../include/messages.h \
+	../include/pathnames.h radlogin.h
+radstatus.o: radstatus.c ../config.h ../include/includes.h \
+	../include/radiusclient.h ../include/pathnames.h \
+	../include/messages.h
+
+info:
+dvi:
+check: all
+	$(MAKE)
+installcheck:
+install-exec: install-sbinPROGRAMS
+	@$(NORMAL_INSTALL)
+
+install-data: 
+	@$(NORMAL_INSTALL)
+
+install: install-exec install-data all
+	@:
+
+uninstall: uninstall-sbinPROGRAMS
+
+install-strip:
+	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install
+installdirs:
+	$(mkinstalldirs)  $(DATADIR)$(sbindir)
+
+
+mostlyclean-generic:
+	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-rm -f Makefile $(DISTCLEANFILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+mostlyclean:  mostlyclean-sbinPROGRAMS mostlyclean-compile \
+		mostlyclean-libtool mostlyclean-tags \
+		mostlyclean-generic
+
+clean:  clean-sbinPROGRAMS clean-compile clean-libtool clean-tags \
+		clean-generic mostlyclean
+
+distclean:  distclean-sbinPROGRAMS distclean-compile distclean-libtool \
+		distclean-tags distclean-generic clean
+	-rm -f config.status
+	-rm -f libtool
+
+maintainer-clean:  maintainer-clean-sbinPROGRAMS \
+		maintainer-clean-compile maintainer-clean-libtool \
+		maintainer-clean-tags maintainer-clean-generic \
+		distclean
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+.PHONY: mostlyclean-sbinPROGRAMS distclean-sbinPROGRAMS \
+clean-sbinPROGRAMS maintainer-clean-sbinPROGRAMS uninstall-sbinPROGRAMS \
+install-sbinPROGRAMS mostlyclean-compile distclean-compile \
+clean-compile maintainer-clean-compile mostlyclean-libtool \
+distclean-libtool clean-libtool maintainer-clean-libtool tags \
+mostlyclean-tags distclean-tags clean-tags maintainer-clean-tags \
+distdir info dvi installcheck install-exec install-data install \
+uninstall all installdirs mostlyclean-generic distclean-generic \
+clean-generic maintainer-clean-generic clean mostlyclean distclean \
+maintainer-clean
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/pppd/plugins/radius/radiusclient/src/local.c b/pppd/plugins/radius/radiusclient/src/local.c
new file mode 100644
index 0000000..57c38b7
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/src/local.c
@@ -0,0 +1,84 @@
+/*
+ * $Id: local.c,v 1.1 2002/01/22 16:03:04 dfs Exp $
+ *
+ * Copyright (C) 1996 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+#include <messages.h>
+#include <radlogin.h>
+
+extern ENV *env;
+
+LFUNC auth_local(char *username, char *passwd)
+{
+	struct passwd	*pw;
+	char		*xpasswd;
+#ifdef SHADOW_PASSWORD
+	struct spwd	*spw;
+#endif
+
+	if ((pw = getpwnam(username)) == NULL) {
+		endpwent();
+		rc_log(LOG_NOTICE, "authentication FAILED, type local, username %s", username);
+		printf(SC_LOCAL_FAILED);
+		return NULL;
+	}
+	endpwent();
+	
+#ifdef SHADOW_PASSWORD
+        if((spw = getspnam(pw->pw_name)) == NULL) {
+			endspent();
+			rc_log(LOG_NOTICE, "authentication FAILED, type local, username %s", username);
+			printf(SC_LOCAL_FAILED);
+			return NULL;
+        }
+        else 
+        { 
+        	pw->pw_passwd = spw->sp_pwdp; 
+        }
+        endspent();
+#endif /* SHADOW_PASSWORD */
+
+	xpasswd = crypt(passwd, pw->pw_passwd);
+	
+	if (*pw->pw_passwd == '\0' || strcmp(xpasswd, pw->pw_passwd)) {
+		rc_log(LOG_NOTICE, "authentication FAILED, type local, username %s", username);
+		printf(SC_LOCAL_FAILED);
+		return NULL;		
+	}
+
+	rc_log(LOG_NOTICE, "authentication OK, type local, username %s", username);
+	printf(SC_LOCAL_OK);
+	
+	return local_login;
+}
+
+void
+local_login(char *username)
+{
+	char *login_local = rc_conf_str("login_local");
+
+	/* login should spot this... but who knows what old /bin/logins
+	 * may be still around
+	 */
+	if (*username == '-') {
+		rc_log(LOG_WARNING, "username can't start with a dash");
+		exit(ERROR_RC);
+	}
+	/* the new shadow login seems to require either a -r or a -h
+	 * flag for -f to work (so source code, lmain.c) so we supply
+	 * it here. shouldn't hurt on other systems,	-lf, 03/13/96
+	 */
+	execle(login_local, login_local, "-h", "localhost", "-f", username, NULL, env->env);
+	rc_log(LOG_ERR, "couldn't execute %s: %s", login_local, strerror(errno));
+	sleep(1);	/* give the user time to read */
+	exit(ERROR_RC);
+}
diff --git a/pppd/plugins/radius/radiusclient/src/radacct.c b/pppd/plugins/radius/radiusclient/src/radacct.c
new file mode 100644
index 0000000..727f584
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/src/radacct.c
@@ -0,0 +1,149 @@
+/*
+ * $Id: radacct.c,v 1.1 2002/01/22 16:03:04 dfs Exp $
+ *
+ * Copyright (C) 1995,1996 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+static char	rcsid[] =
+		"$Id: radacct.c,v 1.1 2002/01/22 16:03:04 dfs Exp $";
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+#include <messages.h>
+#include <pathnames.h>
+
+static char *pname;
+
+void usage(void)
+{
+	fprintf(stderr,"Usage: %s [-Vh] [-f <config_file>] [-i <client_port>]\n\n", pname);
+	fprintf(stderr,"  -V            output version information\n");
+	fprintf(stderr,"  -h            output this text\n");
+	fprintf(stderr,"  -f		filename of alternate config file\n");
+	fprintf(stderr,"  -i            ttyname to send to the server\n");
+	exit(ERROR_RC);
+}
+
+void version(void)
+{
+	fprintf(stderr,"%s: %s\n", pname ,rcsid);
+	exit(ERROR_RC);
+}
+
+int
+main (int argc, char **argv)
+{
+	int			result = ERROR_RC;
+	VALUE_PAIR	*send = NULL;
+   	UINT4		client_port;
+   	int			c;
+	VALUE_PAIR	*vp;
+	DICT_VALUE  *dval;
+	char *username, *service, *fproto, *type;
+	char *path_radiusclient_conf = RC_CONFIG_FILE;
+	char *ttyn = NULL;
+
+	extern char *optarg;
+
+	pname = (pname = strrchr(argv[0],'/'))?pname+1:argv[0];
+
+	rc_openlog(pname);
+
+	while ((c = getopt(argc,argv,"f:i:hV")) > 0)
+	{
+		switch(c)
+		{
+			case 'f':
+				path_radiusclient_conf = optarg;
+				break;
+			case 'i':
+				ttyn = optarg;
+				break;
+			case 'V':
+				version();
+				break;
+			case 'h':
+				usage();
+				break;
+			default:
+				exit(ERROR_RC);
+				break;
+		}
+	}
+
+	if (rc_read_config(path_radiusclient_conf) != 0)
+		exit(ERROR_RC);
+	
+	if (rc_read_dictionary(rc_conf_str("dictionary")) != 0)
+		exit (ERROR_RC);
+
+	if (rc_read_mapfile(rc_conf_str("mapfile")) != 0)
+		exit (ERROR_RC);
+
+	if (ttyn != NULL)
+	{
+		client_port = rc_map2id(ttyn);
+	}
+	else
+	{	
+		/* we take stdout here, because stdin is usually connected
+	 	 *  to our input file
+	 	 */
+	 	if ((ttyn = ttyname(1)) != NULL)
+	 	{
+			client_port = rc_map2id(ttyn);
+		}
+		else
+		{
+			client_port = 0;
+		}
+	}
+
+	if ((send = rc_avpair_readin(stdin))) {
+
+		username = service = type = "(unknown)";
+		fproto = NULL;
+	
+		if ((vp = rc_avpair_get(send, PW_ACCT_STATUS_TYPE)) != NULL)
+				if ((dval = rc_dict_getval(vp->lvalue, vp->name)) != NULL) {
+					type = dval->name;
+				}
+
+		if ((vp = rc_avpair_get(send, PW_USER_NAME)) != NULL)
+				username = vp->strvalue;
+
+		if ((vp = rc_avpair_get(send, PW_SERVICE_TYPE)) != NULL)
+				if ((dval = rc_dict_getval(vp->lvalue, vp->name)) != NULL) {
+					service = dval->name;
+				}
+
+		if (vp && (vp->lvalue == PW_FRAMED) &&
+			((vp = rc_avpair_get(send, PW_FRAMED_PROTOCOL)) != NULL))
+				if ((dval = rc_dict_getval(vp->lvalue, vp->name)) != NULL) {
+					fproto = dval->name;
+				}
+
+		result = rc_acct(client_port, send);
+		if (result == OK_RC)
+		{
+			fprintf(stderr, SC_ACCT_OK);
+			rc_log(LOG_NOTICE, "accounting OK, type %s, username %s, service %s%s%s",
+				   type, username, service,(fproto)?"/":"", (fproto)?fproto:"");
+		}
+		else
+		{
+			fprintf(stderr, SC_ACCT_FAILED, result);
+			rc_log(LOG_NOTICE, "accounting FAILED, type %s, username %s, service %s%s%s",
+				   type, username, service,(fproto)?"/":"", (fproto)?fproto:"");
+		}
+		rc_avpair_free(send);
+	}
+
+	exit (result);
+}
diff --git a/pppd/plugins/radius/radiusclient/src/radexample-debug b/pppd/plugins/radius/radiusclient/src/radexample-debug
new file mode 100755
index 0000000..43b6be5
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/src/radexample-debug
@@ -0,0 +1,61 @@
+#! /bin/sh
+
+# radexample - temporary wrapper script for .libs/radexample
+# Generated by ltmain.sh - GNU libtool 1.0
+#
+# The radexample program cannot be directly executed until all the libtool
+# libraries that it depends on are installed.
+#
+# This wrapper script should never be moved out of `/home/dfs/Servpoet/radiusclient-0.3.1/src'.
+# If it is, it will not operate correctly.
+
+# This environment variable determines our operation mode.
+if test "$libtool_install_magic" = "%%%MAGIC variable%%%"; then
+  # install mode needs the following variables:
+  link_against_libtool_libs=' ../lib/libradiusclient.la'
+  finalize_command='gcc -g -O2 -o .libs/radexampleT radexample.o -Wl,-rpath -Wl,/usr/lib -L/usr/lib -lradiusclient -lcrypt -lnsl'
+else
+  # Find the directory that this script lives in.
+  thisdir=`echo $0 | sed 's%/[^/]*$%%'`
+  test "x$thisdir" = "x$0" && thisdir=.
+
+  # Try to get the absolute directory name.
+  absdir=`cd "$thisdir" && pwd`
+  test -n "$absdir" && thisdir="$absdir"
+
+  progdir="$thisdir/.libs"
+  program="radexample"
+
+  if test -f "$progdir/$program"; then
+    # Run the actual program with our arguments.
+    args=
+    for arg
+    do
+      # Quote arguments (to preserve shell metacharacters).
+      args="$args '$arg'"
+    done
+
+    # Export the path to the program.
+    PATH="$progdir:$PATH"
+    export PATH
+
+    # Add our own library path to LD_LIBRARY_PATH
+    LD_LIBRARY_PATH="$thisdir/../lib/.libs:$LD_LIBRARY_PATH"
+
+    # Some systems cannot cope with colon-terminated LD_LIBRARY_PATH
+    LD_LIBRARY_PATH=`echo $LD_LIBRARY_PATH | sed -e 's/:*$//'`
+
+    export LD_LIBRARY_PATH
+
+    eval "exec ddd ./.libs/$program $args"
+
+    echo "$0: cannot exec $program $args"
+    exit 1
+  else
+    # The program doesn't exist.
+    echo "$0: error: $progdir/$program does not exist" 1>&2
+    echo "This script is just a wrapper for $program." 1>&2
+    echo "See the libtool documentation for more information." 1>&2
+    exit 1
+  fi
+fi
diff --git a/pppd/plugins/radius/radiusclient/src/radexample.c b/pppd/plugins/radius/radiusclient/src/radexample.c
new file mode 100644
index 0000000..2670837
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/src/radexample.c
@@ -0,0 +1,112 @@
+/*
+ * $Id: radexample.c,v 1.1 2002/01/22 16:03:04 dfs Exp $
+ *
+ * Copyright (C) 1995,1996,1997 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions.
+ * If the file is missing contact me at lf@elemental.net
+ * and I'll send you a copy.
+ *
+ */
+
+
+static char	rcsid[] =
+		"$Id: radexample.c,v 1.1 2002/01/22 16:03:04 dfs Exp $";
+
+#include	<config.h>
+#include	<includes.h>
+#include	<radiusclient.h>
+#include	<pathnames.h>
+
+static char *pname = NULL;
+
+int
+main (int argc, char **argv)
+{
+	int             result;
+	char		username[128];
+	char            passwd[AUTH_PASS_LEN + 1];
+	VALUE_PAIR	*send, *received;
+	UINT4		service;
+	char		msg[4096], username_realm[256];
+	char		*default_realm = rc_conf_str("default_realm");
+	char name[2048];
+	char value[2048]; /* more than enough */
+	char *cfile;
+
+	pname = (pname = strrchr(argv[0],'/'))?pname+1:argv[0];
+
+	rc_openlog(pname);
+
+
+	if (argc >= 2) {
+	    cfile = argv[1];
+	} else {
+	    cfile = RC_CONFIG_FILE;
+	}
+	if (rc_read_config(cfile) != 0)
+		return(ERROR_RC);
+
+	if (rc_read_dictionary(rc_conf_str("dictionary")) != 0)
+		return(ERROR_RC);
+
+	strncpy(username, rc_getstr ("login: ",1), sizeof(username));
+	strncpy (passwd, rc_getstr("Password: ",0), sizeof (passwd));
+
+	send = NULL;
+
+	/*
+	 * Fill in User-Name
+	 */
+
+	strncpy(username_realm, username, sizeof(username_realm));
+
+	/* Append default realm */
+	if ((strchr(username_realm, '@') == NULL) && default_realm &&
+	    (*default_realm != '\0'))
+	{
+		strncat(username_realm, "@", sizeof(username_realm));
+		strncat(username_realm, default_realm, sizeof(username_realm));
+	}
+
+	if (rc_avpair_add(&send, PW_USER_NAME, username_realm, 0, VENDOR_NONE) == NULL)
+		return(ERROR_RC);
+
+	/*
+	 * Fill in User-Password
+	 */
+
+	if (rc_avpair_add(&send, PW_USER_PASSWORD, passwd, 0, VENDOR_NONE) == NULL)
+		return (ERROR_RC);
+
+	/*
+	 * Fill in Service-Type
+	 */
+
+	service = PW_AUTHENTICATE_ONLY;
+	if (rc_avpair_add(&send, PW_SERVICE_TYPE, &service, 0, VENDOR_NONE) == NULL)
+		return (ERROR_RC);
+
+	result = rc_auth(0, send, &received, msg);
+
+	if (result == OK_RC)
+	{
+		fprintf(stderr, "\"%s\" RADIUS Authentication OK\n", username);
+	}
+	else
+	{
+		fprintf(stderr, "\"%s\" RADIUS Authentication failure (RC=%i)\n", username, result);
+	}
+
+	/* Print returned attributes */
+	for( ; received ; received = received->next) {
+	    if (rc_avpair_tostr(received, name, sizeof(name), value,
+				sizeof(value)) < 0) {
+		continue;
+	    }
+	    printf("Attr '%s' ==> Val '%s'\n",
+		   name, value);
+	}
+
+	return result;
+}
diff --git a/pppd/plugins/radius/radiusclient/src/radius.c b/pppd/plugins/radius/radiusclient/src/radius.c
new file mode 100644
index 0000000..ce5fdcc
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/src/radius.c
@@ -0,0 +1,230 @@
+/*
+ * $Id: radius.c,v 1.1 2002/01/22 16:03:04 dfs Exp $
+ *
+ * Copyright (C) 1996 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions.
+ * If the file is missing contact me at lf@elemental.net
+ * and I'll send you a copy.
+ *
+ */
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+#include <messages.h>
+#include <radlogin.h>
+
+extern ENV *env;
+
+LFUNC auth_radius(UINT4 client_port, char *username, char *passwd)
+{
+
+	VALUE_PAIR	*send, *received, *vp, *service_vp;
+	UINT4		service, ftype, ctype;
+	char		msg[4096], *p, username_realm[256];
+	char            name[2048], value[2048]; /* more than enough */
+	int		result;
+	char		*default_realm, *service_str, *ftype_str;
+	DICT_VALUE	*dval;
+
+	send = received = NULL;
+
+	/*
+	 * Determine and fill in Service-Type
+	 */
+
+#ifdef SCP
+	/* determine based on the username what kind of service is requested.
+	   this allows you to use one password for all accounts, but the
+	   Merit radiusd supplies you just with the right information you
+	   need for the specified service type	-lf, 03/15/96 */
+
+	switch (*username)
+	{
+		case 'S':
+				service = PW_FRAMED;
+				ftype = PW_SLIP;
+				ctype = 0;
+				username++;
+				break;
+		case 'C':
+				service = PW_FRAMED;
+				ftype = PW_SLIP;
+				ctype = PW_VAN_JACOBSON_TCP_IP;
+				username++;
+				break;
+		case 'P':
+				service = PW_FRAMED;
+				ftype = PW_PPP;
+				ctype = 0;
+				username++;
+				break;
+		default:
+				service = PW_LOGIN;
+				ftype = 0;
+				ctype = 0;
+				break;
+	}
+#else
+	service = PW_LOGIN;
+	ftype = 0;
+	ctype = 0;
+#endif
+
+	if (rc_avpair_add(&send, PW_SERVICE_TYPE, &service, 0, VENDOR_NONE) == NULL)
+		return (LFUNC) NULL;
+
+	/* Fill in Framed-Protocol, if neccessary */
+
+	if (ftype != 0)
+	{
+		if (rc_avpair_add(&send, PW_FRAMED_PROTOCOL, &ftype, 0, VENDOR_NONE) == NULL)
+			return (LFUNC) NULL;
+	}
+
+	/* Fill in Framed-Compression, if neccessary */
+
+	if (ctype != 0)
+	{
+		if (rc_avpair_add(&send, PW_FRAMED_COMPRESSION, &ctype, 0, VENDOR_NONE) == NULL)
+			return (LFUNC) NULL;
+	}
+
+	/*
+	 * Fill in User-Name
+	 */
+
+	 strncpy(username_realm, username, sizeof(username_realm));
+
+	 /* Append default realm */
+	 default_realm = rc_conf_str("default_realm");
+
+	 if ((strchr(username_realm, '@') == NULL) && default_realm &&
+	     ((*default_realm) != '\0'))
+	 {
+		strncat(username_realm, "@", sizeof(username_realm));
+		strncat(username_realm, default_realm, sizeof(username_realm));
+	 }
+
+	if (rc_avpair_add(&send, PW_USER_NAME, username_realm, 0, VENDOR_NONE) == NULL)
+		return (LFUNC) NULL;
+
+	/*
+	 * Fill in User-Password
+	 */
+
+	if (rc_avpair_add(&send, PW_USER_PASSWORD, passwd, 0, VENDOR_NONE) == NULL)
+		return (LFUNC) NULL;
+
+	result = rc_auth(client_port, send, &received, msg);
+
+	if (result == OK_RC)
+	{
+		/* Set up a running count of attributes saved. */
+		int acount[256], attr;
+
+		memset(acount, 0, sizeof(acount));
+
+		rc_add_env(env, "RADIUS_USER_NAME", username);
+
+		vp = received;
+
+		/* map-- keep track of the attributes so that we know
+		   when to add the delimiters. Note that we can only
+		   handle attributes < 256, which is the standard anyway. */
+
+		while (vp)
+		{
+			strcpy(name, "RADIUS_");
+			if (rc_avpair_tostr(vp, name+7, sizeof(name)-7, value, sizeof(value)) < 0) {
+				rc_avpair_free(send);
+				rc_avpair_free(received);
+				return (LFUNC) NULL;
+			}
+
+			/* Translate "-" => "_" and uppercase*/
+			for(p = name; *p; p++) {
+				*p = toupper(*p);
+				if (*p == '-') *p = '_';
+			}
+
+			/* Add to the attribute count and append the var
+			   if necessary. */
+			if ((attr = vp->attribute) < 256)
+			{
+				int count;
+				if ((count = acount[attr]++) > 0) {
+					char buf[10];
+					sprintf(buf, "_%d", count);
+					strcat(name,buf);
+				}
+			}
+
+			if (rc_add_env(env, name, value) < 0)
+			{
+				rc_avpair_free(send);
+				rc_avpair_free(received);
+				return (LFUNC) NULL;
+			}
+
+			vp = vp->next;
+		}
+
+		service_str = "(unknown)";
+		ftype_str = NULL;
+
+		if ((service_vp = rc_avpair_get(received, PW_SERVICE_TYPE)) != NULL)
+				if ((dval = rc_dict_getval(service_vp->lvalue, service_vp->name)) != NULL) {
+					service_str = dval->name;
+				}
+
+		if (service_vp && (service_vp->lvalue == PW_FRAMED) &&
+			((vp = rc_avpair_get(received, PW_FRAMED_PROTOCOL)) != NULL))
+				if ((dval = rc_dict_getval(vp->lvalue, vp->name)) != NULL) {
+					ftype_str = dval->name;
+				}
+
+		rc_log(LOG_NOTICE, "authentication OK, username %s, service %s%s%s",
+				username, service_str,(ftype_str)?"/":"", (ftype_str)?ftype_str:"");
+
+		if (msg && (*msg != '\0'))
+			printf(SC_SERVER_REPLY, msg);
+		else
+			printf(SC_RADIUS_OK);
+
+		rc_avpair_free(send);
+		rc_avpair_free(received);
+
+		return radius_login;
+	}
+	else
+	{
+		rc_log(LOG_NOTICE, "authentication FAILED, type RADIUS, username %s",
+			   username_realm);
+		if (msg && (*msg != '\0'))
+			printf(SC_SERVER_REPLY, msg);
+		else
+			printf(SC_RADIUS_FAILED);
+	}
+
+	rc_avpair_free(send);
+	if (received)
+		rc_avpair_free(received);
+
+	return (LFUNC) NULL;
+}
+
+void
+radius_login(char *username)
+{
+	char *login_radius = rc_conf_str("login_radius");
+
+	execle(login_radius, login_radius, NULL, env->env);
+
+	rc_log(LOG_ERR, "couldn't execute %s: %s", login_radius, strerror(errno));
+	fprintf(stderr, "couldn't execute %s: %s", login_radius, strerror(errno));
+
+	sleep(1);	/* give the user time to read */
+	exit(ERROR_RC);
+}
diff --git a/pppd/plugins/radius/radiusclient/src/radlogin.c b/pppd/plugins/radius/radiusclient/src/radlogin.c
new file mode 100644
index 0000000..9876286
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/src/radlogin.c
@@ -0,0 +1,385 @@
+/*
+ * $Id: radlogin.c,v 1.1 2002/01/22 16:03:04 dfs Exp $
+ *
+ * Copyright (C) 1995,1996 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+static char	rcsid[] =
+		"$Id: radlogin.c,v 1.1 2002/01/22 16:03:04 dfs Exp $";
+
+#include	<config.h>
+#include	<includes.h>
+#include	<radiusclient.h>
+#include	<messages.h>
+#include	<pathnames.h>
+#include	<radlogin.h>
+
+ENV *env = NULL;
+static char *pname = NULL;
+
+static RETSIGTYPE
+alarm_handler(int sn)
+{
+	fprintf(stderr, SC_TIMEOUT, rc_conf_int("login_timeout"));
+	sleep(1);
+	exit(ERROR_RC);	
+}
+
+static int
+login_allowed(char *tty)
+{
+	FILE *fp;
+	char fname[PATH_MAX];
+	int c;
+
+	strcpy(fname, rc_conf_str("nologin"));
+	if (access(fname, F_OK) < 0) {
+		if (tty) {
+			sprintf(fname, "%s.%s", rc_conf_str("nologin"), tty);
+			if (access(fname, F_OK) < 0)
+				return 1;
+		} else {
+			return 1;
+		}
+	}
+
+	if ((fp = fopen(fname, "r")) != NULL)
+	{
+		while ((c = fgetc(fp)) != EOF)
+		{
+			if (c == '\n')
+				fputc('\r', stdout);
+			fputc(c, stdout);
+		}
+		fflush(stdout);
+		fclose(fp);
+	} else {
+		printf(SC_NOLOGIN);
+	}
+	return (0);		
+}
+
+static char *
+subst_placeholders(char *str, char *tty)
+{
+	char *p,*q;
+	static char buf[4096];
+#if defined(HAVE_UNAME)
+	struct utsname uts;
+#endif
+#if !defined(HAVE_STRUCT_UTSNAME_DOMAINNAME) && defined(HAVE_GETDOMAINNAME)
+	char domainname[256];
+#endif
+
+#if defined(HAVE_UNAME)	
+	uname(&uts);
+#endif
+	
+	p = str;
+	q = buf;	
+
+	while (*p != '\0') {
+		switch (*p) {
+			case '\\':
+				if (*(p+1) == '\0')
+					break;
+				p++;
+				switch (*p) {
+					case 'I':
+						strcpy(q, rcsid);
+						q += strlen(rcsid);
+						break;
+					case 'L':
+					case 'P':
+						strcpy(q, tty);
+						q += strlen(tty);
+						break;
+#if defined(HAVE_UNAME)
+					case 'S':
+						strcpy(q, uts.sysname);
+						q += strlen(uts.sysname);
+						break;
+					case 'N':
+						strcpy(q, uts.nodename);
+						q += strlen(uts.nodename);
+						break;
+					case 'R':
+						strcpy(q, uts.release);
+						q += strlen(uts.release);
+						break;
+					case 'V':
+						strcpy(q, uts.version);
+						q += strlen(uts.version);
+						break;
+					case 'M':
+						strcpy(q, uts.machine);
+						q += strlen(uts.machine);
+						break;
+#endif
+					case 'D':
+#if defined(HAVE_STRUCT_UTSNAME_DOMAINNAME)
+						strcpy(q, uts.domainname);
+						q += strlen(uts.domainname);
+#elif defined(HAVE_GETDOMAINNAME)
+						getdomainname(domainname, sizeof(domainname));
+						strcpy(q, domainname);
+						q += strlen(domainname);
+#endif
+						break;
+					case '\\':
+						*q = '\\';
+						q++;
+						break;
+				}
+				break;
+#if defined(HAVE_UNAME)
+			case '@':
+				strcpy(q, uts.nodename);
+				q += strlen(uts.nodename);
+				break;
+#endif
+			case '\n':
+				strcpy(q,"\r\n");
+				q += 2;
+				break;
+			default:
+				*q = *p;
+				q++;
+				break;
+		}
+
+		p++;
+	}
+	*q = '\0';
+
+	return buf;
+}
+
+static void
+usage(void)
+{
+	fprintf(stderr,"Usage: %s [-Vhnd] [-f <config_file>] [-i <client_port>] [-m <login_tries>]\n\n", pname);
+	fprintf(stderr,"  -V		output version information\n");
+	fprintf(stderr,"  -h		output this text\n");     
+	fprintf(stderr,"  -n		don't display issue file\n");
+	fprintf(stderr,"  -f		filename of alternate config file\n");
+	fprintf(stderr,"  -i		ttyname to send to the server\n");
+	fprintf(stderr,"  -m		maximum login tries (overrides value in config file)\n");
+        exit(ERROR_RC);
+}
+
+static void
+version(void)
+{
+	fprintf(stderr,"%s: %s\n", pname ,rcsid);
+	exit(ERROR_RC);
+}
+
+int
+main (int argc, char **argv)
+{
+	char		username[128];
+	char		passwd[AUTH_PASS_LEN + 1];
+	int 		tries, remaining, c;
+	UINT4		client_port;
+	void 		(*login_func)(char *);	
+	FILE		*fp;
+	char 		buf[4096];
+	char		tty[1024], *p;
+	int		noissue = 0;
+	int		maxtries = 0;
+	char		*ttyn  = NULL;
+	char            *path_radiusclient_conf = RC_CONFIG_FILE;
+
+        extern char *optarg;
+        extern int optind;
+
+	pname = (pname = strrchr(argv[0],'/'))?pname+1:argv[0];
+	
+	rc_openlog(pname);
+
+	while ((c = getopt(argc,argv,"f:m:i:nhV")) > 0)
+	{
+		switch(c) {
+			case 'f':
+				path_radiusclient_conf = optarg;
+				break;
+			case 'i':
+				ttyn = optarg;
+				break;
+			case 'n':
+				noissue = 1;
+				break;
+			case 'm':
+				maxtries = atoi(optarg);
+				break;
+			case 'V':
+				version();
+				break;
+			case 'h':
+				usage();
+				break;
+			default:
+				exit(ERROR_RC);
+				break;
+		}
+	}
+
+	if (rc_read_config(path_radiusclient_conf) != 0)
+		exit(ERROR_RC);
+	
+	if (rc_read_dictionary(rc_conf_str("dictionary")) != 0)
+		exit (ERROR_RC);
+
+	if (rc_read_mapfile(rc_conf_str("mapfile")) != 0)
+		exit (ERROR_RC);
+
+	if (ttyn != NULL)
+	{
+		client_port = rc_map2id(ttyn);
+		
+		if ((p = strrchr(ttyn, '/')) == NULL)
+			strncpy(tty, ttyn, sizeof(tty));
+		else
+			strncpy(tty, p+1, sizeof(tty));
+	}
+	else
+	{
+		ttyn = ttyname(0);
+		if (ttyn)
+		{
+			if ((p = strrchr(ttyn, '/')) == NULL)
+				strncpy(tty, ttyn, sizeof(tty));
+			else
+				strncpy(tty, p+1, sizeof(tty));
+
+			client_port = rc_map2id(ttyn);
+		}
+		else 
+		{
+			*tty = '\0';
+			client_port = 0;
+		}
+	}
+
+#ifdef SETVBUF_REVERSED
+	setvbuf(stdout, _IONBF, NULL, 0);
+#else
+	setvbuf(stdout, NULL, _IONBF, 0);
+#endif
+
+	if ((argc - optind) == 1)
+	{
+		strncpy(username,argv[optind], sizeof(username));
+	}
+	else
+	{
+		*username = '\0';
+		
+		if (!noissue) {
+			if (rc_conf_str("issue") && ((fp = fopen(rc_conf_str("issue"), "r")) != NULL))
+			{
+				while (fgets(buf, sizeof(buf), fp) != NULL)
+					fputs(subst_placeholders(buf, tty), stdout);
+
+				fflush(stdout);
+				fclose(fp);
+			} else {
+				fputs(subst_placeholders(SC_DEFAULT_ISSUE, tty), stdout);
+				fflush(stdout);
+			}
+		}
+	}
+
+	if ((env = rc_new_env(ENV_SIZE)) == NULL)
+	{
+		rc_log(LOG_CRIT, "rc_new_env: FATAL: out of memory");
+		abort();
+	}
+	
+#ifdef SECURITY_DISABLED
+	if (rc_import_env(env,environ) < 0)
+	{
+		rc_log(LOG_CRIT, "rc_import_env: FATAL: not enough space for environment (increase ENV_SIZE)");
+		abort();
+	}
+#else
+	rc_add_env(env, "IFS", " ");
+	rc_add_env(env, "PATH", RC_SECURE_PATH);
+#endif
+
+	signal(SIGALRM, alarm_handler);
+
+	remaining = rc_conf_int("login_timeout");
+	
+	if (!maxtries)
+		maxtries = rc_conf_int("login_tries");
+		
+	tries = 1;
+	while (tries <= maxtries)
+	{
+	 alarm(remaining);
+
+	 while (!*username) {
+	 	p = rc_getstr (SC_LOGIN, 1);
+	 	if (p)
+	 		strncpy(username, p, sizeof(username));
+	 	else
+	 		exit (ERROR_RC);
+	 }
+	 p = rc_getstr(SC_PASSWORD,0);
+	 if (p) 
+	 	strncpy (passwd, p, sizeof (passwd));		
+	 else 
+		exit (ERROR_RC);
+
+	 remaining = alarm(0);
+	 
+	 login_func = NULL;
+
+ 	 if (rc_conf_int("auth_order") & AUTH_LOCAL_FST)
+ 	 {
+ 	 	login_func = auth_local(username, passwd);
+ 	 		
+ 	 	if (!login_func)
+ 	 		if (rc_conf_int("auth_order") & AUTH_RADIUS_SND)
+ 	 			login_func = auth_radius(client_port, username, passwd);
+ 	 }
+ 	 else
+ 	 {
+		login_func = auth_radius(client_port, username, passwd);
+ 	 	if (!login_func)
+ 	 		if (rc_conf_int("auth_order") & AUTH_LOCAL_SND)
+ 	 			login_func = auth_local(username, passwd);
+ 	 }
+
+	 memset(passwd, '\0', sizeof(passwd));
+
+	 if (login_func != NULL)
+	 	if (login_allowed(tty)) {
+	 		(*login_func)(username);
+		} else {
+			sleep(1);
+			exit (ERROR_RC);
+		}
+
+	 *username = '\0';
+	 
+	 if ((++tries) <= maxtries) {
+		alarm(remaining);
+	 	sleep(tries * 2);
+	 	remaining = alarm(0);
+	 }
+
+	}
+
+	fprintf(stderr, SC_EXCEEDED);
+	sleep(1);
+	
+	exit (ERROR_RC);
+}
diff --git a/pppd/plugins/radius/radiusclient/src/radlogin.h b/pppd/plugins/radius/radiusclient/src/radlogin.h
new file mode 100644
index 0000000..ac2af1a
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/src/radlogin.h
@@ -0,0 +1,32 @@
+/*
+ * $Id: radlogin.h,v 1.1 2002/01/22 16:03:05 dfs Exp $
+ *
+ * Copyright (C) 1996 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+#ifndef RADLOGIN_H
+#define RADLOGIN_H
+
+#undef __P
+#if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(WIN32) || defined(__cplusplus)
+# define __P(protos) protos
+#else
+# define __P(protos) ()
+#endif
+
+typedef void (*LFUNC)(char *);
+
+/* radius.c */
+LFUNC auth_radius(UINT4, char *, char *);
+void radius_login(char *);
+
+/* local.c */
+LFUNC auth_local __P((char *, char *));
+void local_login __P((char *));
+
+#endif /* RADLOGIN_H */
diff --git a/pppd/plugins/radius/radiusclient/src/radstatus.c b/pppd/plugins/radius/radiusclient/src/radstatus.c
new file mode 100644
index 0000000..fc5d7b2
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/src/radstatus.c
@@ -0,0 +1,114 @@
+/*
+ * $Id: radstatus.c,v 1.1 2002/01/22 16:03:05 dfs Exp $
+ *
+ * Copyright (C) 1995,1996 Lars Fenneberg
+ *
+ * See the file COPYRIGHT for the respective terms and conditions. 
+ * If the file is missing contact me at lf@elemental.net 
+ * and I'll send you a copy.
+ *
+ */
+
+static char	rcsid[] =
+		"$Id: radstatus.c,v 1.1 2002/01/22 16:03:05 dfs Exp $";
+
+#include <config.h>
+#include <includes.h>
+#include <radiusclient.h>
+#include <pathnames.h>
+#include <messages.h>
+
+static char *pname;
+
+void usage(void)
+{
+	fprintf(stderr,"Usage: %s [-Vh] [-f <config_file>] [server[:port]]...\n\n", pname);
+	fprintf(stderr,"  -V            output version information\n");
+	fprintf(stderr,"  -h            output this text\n");
+	fprintf(stderr,"  -f		filename of alternate config file\n");
+	exit(ERROR_RC);
+}
+
+void version(void)
+{
+	fprintf(stderr,"%s: %s\n", pname ,rcsid);
+	exit(ERROR_RC);
+}
+
+int main (int argc, char **argv)
+{
+	int	result = ERROR_RC;
+   	int	c,i;
+	char	*p, msg[4096];
+	SERVER	*srv;
+	char	*path_radiusclient_conf = RC_CONFIG_FILE;
+	
+	extern int optind;
+
+	pname = (pname = strrchr(argv[0],'/'))?pname+1:argv[0];
+
+	rc_openlog(pname);
+
+	while ((c = getopt(argc,argv,"hVf:")) > 0)
+	{
+		switch(c) {
+			case 'f':
+				path_radiusclient_conf = optarg;
+				break;
+			case 'V':
+				version();
+				break;
+			case 'h':
+				usage();
+				break;
+			default:
+				exit(ERROR_RC);
+				break;
+		}
+	}
+
+	argc -= optind;
+	argv += optind;
+
+	if (rc_read_config(path_radiusclient_conf) != 0)
+		exit(ERROR_RC);
+	
+	if (rc_read_dictionary(rc_conf_str("dictionary")) != 0)
+		exit (ERROR_RC);
+
+	if (argc > 0) {
+		for (i = 0; i < argc; i++) {
+			if ((p = strchr(argv[i], ':')) == NULL) {
+				result = rc_check(argv[i],rc_getport(AUTH), msg);
+			} else if (!strcmp(p+1, "auth")) {
+				*p = '\0';
+				result = rc_check(argv[i],rc_getport(AUTH), msg);
+			} else if (!strcmp(p+1, "acct")) {
+				*p = '\0';
+				result = rc_check(argv[i],rc_getport(ACCT), msg);
+			} else {
+				*p = '\0';
+				result = rc_check(argv[i], atoi(p+1), msg);
+			}
+			if (result == OK_RC)
+				fputs(msg, stdout);
+			else
+				printf(SC_STATUS_FAILED);
+		}
+	} else {
+		srv = rc_conf_srv("authserver");
+		for(i=0; i<srv->max ; i++)
+		{
+			result = rc_check(srv->name[i], srv->port[i], msg);
+			fputs(msg, stdout);
+		}
+		
+		srv = rc_conf_srv("acctserver");
+		for(i=0; i<srv->max ; i++)
+		{
+			result = rc_check(srv->name[i], srv->port[i], msg);
+			fputs(msg, stdout);
+		}
+	}
+	return 0;
+}
diff --git a/pppd/plugins/radius/radiusclient/stamp-h.in b/pppd/plugins/radius/radiusclient/stamp-h.in
new file mode 100644
index 0000000..9788f70
--- /dev/null
+++ b/pppd/plugins/radius/radiusclient/stamp-h.in
@@ -0,0 +1 @@
+timestamp
diff --git a/pppd/plugins/rp-pppoe/plugin.c b/pppd/plugins/rp-pppoe/plugin.c
index bad8113..ceef051 100644
--- a/pppd/plugins/rp-pppoe/plugin.c
+++ b/pppd/plugins/rp-pppoe/plugin.c
@@ -22,7 +22,7 @@
 ***********************************************************************/
 
 static char const RCSID[] =
-"$Id: plugin.c,v 1.1 2001/12/14 02:55:20 mostrows Exp $";
+"$Id: plugin.c,v 1.2 2002/01/22 16:03:05 dfs Exp $";
 
 #define _GNU_SOURCE 1
 #include "pppoe.h"
@@ -54,6 +54,8 @@ static char const RCSID[] =
 
 #define _PATH_ETHOPT         _ROOT_PATH "/etc/ppp/options."
 
+char pppd_version[] = VERSION;
+
 /* From sys-linux.c in pppd -- MUST FIX THIS! */
 extern int new_style_driver;
 
@@ -142,10 +144,8 @@ PPPOEConnectDevice(void)
 	}
     }
 
-#ifdef HAVE_LICENSE
     /* Set PPPoE session-number for further consumption */
-    pppd_pppoe_session = ntohs(conn->session);
-#endif
+    ppp_session_number = ntohs(conn->session);
 
     /* Make the session socket */
     conn->sessionSocket = socket(AF_PPPOX, SOCK_STREAM, PX_PROTO_OE);
@@ -157,7 +157,7 @@ PPPOEConnectDevice(void)
     sp.sa_addr.pppoe.sid = conn->session;
     memcpy(sp.sa_addr.pppoe.dev, conn->ifName, IFNAMSIZ);
     memcpy(sp.sa_addr.pppoe.remote, conn->peerEth, ETH_ALEN);
-#ifdef HAVE_LICENSE
+
     /* Set remote_number for ServPoET */
     sprintf(remote_number, "%02X:%02X:%02X:%02X:%02X:%02X",
 	    (unsigned) conn->peerEth[0],
@@ -166,7 +166,6 @@ PPPOEConnectDevice(void)
 	    (unsigned) conn->peerEth[3],
 	    (unsigned) conn->peerEth[4],
 	    (unsigned) conn->peerEth[5]);
-#endif
 
     if (connect(conn->sessionSocket, (struct sockaddr *) &sp,
 		sizeof(struct sockaddr_pppox)) < 0) {
diff --git a/pppd/pppd.h b/pppd/pppd.h
index f645eb4..9e9f87b 100644
--- a/pppd/pppd.h
+++ b/pppd/pppd.h
@@ -16,7 +16,7 @@
  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  *
- * $Id: pppd.h,v 1.63 2002/01/11 18:31:42 etbe Exp $
+ * $Id: pppd.h,v 1.64 2002/01/22 16:02:58 dfs Exp $
  */
 
 /*
@@ -214,6 +214,9 @@ extern int	unsuccess;	/* # unsuccessful connection attempts */
 extern int	do_callback;	/* set if we want to do callback next */
 extern int	doing_callback;	/* set if this is a callback */
 extern char	ppp_devnam[MAXPATHLEN];
+extern char     remote_number[MAXNAMELEN]; /* Remote telephone number, if avail. */
+extern int      ppp_session_number; /* Session number (eg PPPoE session) */
+
 extern int	listen_time;	/* time to listen first (ms) */
 extern struct notifier *pidchange;   /* for notifications of pid changing */
 extern struct notifier *phasechange; /* for notifications of phase changes */
@@ -617,10 +620,14 @@ extern int (*pap_auth_hook) __P((char *user, char *passwd, char **msgp,
 				 struct wordlist **popts));
 extern void (*pap_logout_hook) __P((void));
 extern int (*pap_passwd_hook) __P((char *user, char *passwd));
+extern int (*allowed_address_hook) __P((u_int32_t addr));
 extern void (*ip_up_hook) __P((void));
 extern void (*ip_down_hook) __P((void));
 extern void (*ip_choose_hook) __P((u_int32_t *));
 
+extern int (*chap_check_hook) __P((void));
+extern int (*chap_passwd_hook) __P((char *user, char *passwd));
+
 /*
  * Inline versions of get/put char/short/long.
  * Pointer is advanced; we assume that both arguments
-- 
2.20.1

